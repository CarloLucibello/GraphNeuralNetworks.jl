<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>GNNGraph · GraphNeuralNetworks.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../democards/gridtheme.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="GraphNeuralNetworks.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GraphNeuralNetworks.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Graphs</span><ul><li><a class="tocitem" href="../../gnngraph/">Working with GNNGraph</a></li><li><a class="tocitem" href="../../heterograph/">Heterogeneous Graphs</a></li><li><a class="tocitem" href="../../temporalgraph/">Temporal Graphs</a></li></ul></li><li><a class="tocitem" href="../../messagepassing/">Message Passing</a></li><li><a class="tocitem" href="../../models/">Model Building</a></li><li><a class="tocitem" href="../../datasets/">Datasets</a></li><li><a class="tocitem" href="../../tutorials/">Tutorials</a></li><li><span class="tocitem">API Reference</span><ul><li class="is-active"><a class="tocitem" href>GNNGraph</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#GNNGraph-type"><span>GNNGraph type</span></a></li><li><a class="tocitem" href="#DataStore"><span>DataStore</span></a></li><li><a class="tocitem" href="#Query"><span>Query</span></a></li><li><a class="tocitem" href="#Transform"><span>Transform</span></a></li><li><a class="tocitem" href="#Generate"><span>Generate</span></a></li><li><a class="tocitem" href="#Operators"><span>Operators</span></a></li><li><a class="tocitem" href="#Sampling"><span>Sampling</span></a></li></ul></li><li><a class="tocitem" href="../basic/">Basic Layers</a></li><li><a class="tocitem" href="../conv/">Convolutional Layers</a></li><li><a class="tocitem" href="../pool/">Pooling Layers</a></li><li><a class="tocitem" href="../messagepassing/">Message Passing</a></li><li><a class="tocitem" href="../heterograph/">Heterogeneous Graphs</a></li><li><a class="tocitem" href="../temporalgraph/">Temporal Graphs</a></li><li><a class="tocitem" href="../utils/">Utils</a></li></ul></li><li><a class="tocitem" href="../../dev/">Developer Notes</a></li><li><a class="tocitem" href="../../gsoc/">Summer Of Code</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>GNNGraph</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>GNNGraph</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/master/docs/src/api/gnngraph.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="GNNGraph"><a class="docs-heading-anchor" href="#GNNGraph">GNNGraph</a><a id="GNNGraph-1"></a><a class="docs-heading-anchor-permalink" href="#GNNGraph" title="Permalink"></a></h1><p>Documentation page for the graph type <code>GNNGraph</code> provided by GraphNeuralNetworks.jl and related methods. </p><p>Besides the methods documented here, one can rely on the large set of functionalities given by <a href="https://github.com/JuliaGraphs/Graphs.jl">Graphs.jl</a> thanks to the fact that <code>GNNGraph</code> inherits from <code>Graphs.AbstractGraph</code>.</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#GraphNeuralNetworks.GNNGraphs.DataStore"><code>GraphNeuralNetworks.GNNGraphs.DataStore</code></a></li><li><a href="#GraphNeuralNetworks.GNNGraphs.GNNGraph"><code>GraphNeuralNetworks.GNNGraphs.GNNGraph</code></a></li><li><a href="#GraphNeuralNetworks.GNNGraphs.TemporalSnapshotsGNNGraph"><code>GraphNeuralNetworks.GNNGraphs.TemporalSnapshotsGNNGraph</code></a></li><li><a href="#Base.intersect"><code>Base.intersect</code></a></li><li><a href="#GraphNeuralNetworks.GNNGraphs.add_edges-Tuple{GNNHeteroGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}, Pair{Tuple{Symbol, Symbol, Symbol}, &lt;:Tuple}}"><code>GraphNeuralNetworks.GNNGraphs.add_edges</code></a></li><li><a href="#GraphNeuralNetworks.GNNGraphs.add_edges-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}}"><code>GraphNeuralNetworks.GNNGraphs.add_edges</code></a></li><li><a href="#GraphNeuralNetworks.GNNGraphs.add_nodes-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}, Integer}"><code>GraphNeuralNetworks.GNNGraphs.add_nodes</code></a></li><li><a href="#GraphNeuralNetworks.GNNGraphs.add_self_loops-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}}"><code>GraphNeuralNetworks.GNNGraphs.add_self_loops</code></a></li><li><a href="#GraphNeuralNetworks.GNNGraphs.add_snapshot-Tuple{TemporalSnapshotsGNNGraph, Int64, GNNGraph}"><code>GraphNeuralNetworks.GNNGraphs.add_snapshot</code></a></li><li><a href="#GraphNeuralNetworks.GNNGraphs.adjacency_list-Tuple{GNNGraph, Any}"><code>GraphNeuralNetworks.GNNGraphs.adjacency_list</code></a></li><li><a href="#GraphNeuralNetworks.GNNGraphs.edge_index-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}}"><code>GraphNeuralNetworks.GNNGraphs.edge_index</code></a></li><li><a href="#GraphNeuralNetworks.GNNGraphs.edge_index-Tuple{GNNHeteroGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}, Tuple{Symbol, Symbol, Symbol}}"><code>GraphNeuralNetworks.GNNGraphs.edge_index</code></a></li><li><a href="#GraphNeuralNetworks.GNNGraphs.getgraph-Tuple{GNNGraph, Int64}"><code>GraphNeuralNetworks.GNNGraphs.getgraph</code></a></li><li><a href="#GraphNeuralNetworks.GNNGraphs.graph_indicator-Tuple{Any}"><code>GraphNeuralNetworks.GNNGraphs.graph_indicator</code></a></li><li><a href="#GraphNeuralNetworks.GNNGraphs.has_isolated_nodes-Tuple{GNNGraph}"><code>GraphNeuralNetworks.GNNGraphs.has_isolated_nodes</code></a></li><li><a href="#GraphNeuralNetworks.GNNGraphs.has_multi_edges-Tuple{GNNGraph}"><code>GraphNeuralNetworks.GNNGraphs.has_multi_edges</code></a></li><li><a href="#GraphNeuralNetworks.GNNGraphs.is_bidirected-Tuple{GNNGraph}"><code>GraphNeuralNetworks.GNNGraphs.is_bidirected</code></a></li><li><a href="#GraphNeuralNetworks.GNNGraphs.khop_adj"><code>GraphNeuralNetworks.GNNGraphs.khop_adj</code></a></li><li><a href="#GraphNeuralNetworks.GNNGraphs.knn_graph-Tuple{AbstractMatrix, Int64}"><code>GraphNeuralNetworks.GNNGraphs.knn_graph</code></a></li><li><a href="#GraphNeuralNetworks.GNNGraphs.laplacian_lambda_max"><code>GraphNeuralNetworks.GNNGraphs.laplacian_lambda_max</code></a></li><li><a href="#GraphNeuralNetworks.GNNGraphs.negative_sample-Tuple{GNNGraph}"><code>GraphNeuralNetworks.GNNGraphs.negative_sample</code></a></li><li><a href="#GraphNeuralNetworks.GNNGraphs.normalized_laplacian"><code>GraphNeuralNetworks.GNNGraphs.normalized_laplacian</code></a></li><li><a href="#GraphNeuralNetworks.GNNGraphs.radius_graph-Tuple{AbstractMatrix, AbstractFloat}"><code>GraphNeuralNetworks.GNNGraphs.radius_graph</code></a></li><li><a href="#GraphNeuralNetworks.GNNGraphs.rand_bipartite_heterograph"><code>GraphNeuralNetworks.GNNGraphs.rand_bipartite_heterograph</code></a></li><li><a href="#GraphNeuralNetworks.GNNGraphs.rand_edge_split-Tuple{GNNGraph, Any}"><code>GraphNeuralNetworks.GNNGraphs.rand_edge_split</code></a></li><li><a href="#GraphNeuralNetworks.GNNGraphs.rand_graph-Tuple{Integer, Integer}"><code>GraphNeuralNetworks.GNNGraphs.rand_graph</code></a></li><li><a href="#GraphNeuralNetworks.GNNGraphs.rand_heterograph"><code>GraphNeuralNetworks.GNNGraphs.rand_heterograph</code></a></li><li><a href="#GraphNeuralNetworks.GNNGraphs.rand_temporal_hyperbolic_graph-Tuple{Int64, Int64}"><code>GraphNeuralNetworks.GNNGraphs.rand_temporal_hyperbolic_graph</code></a></li><li><a href="#GraphNeuralNetworks.GNNGraphs.rand_temporal_radius_graph-Tuple{Int64, Int64, AbstractFloat, AbstractFloat}"><code>GraphNeuralNetworks.GNNGraphs.rand_temporal_radius_graph</code></a></li><li><a href="#GraphNeuralNetworks.GNNGraphs.random_walk_pe-Tuple{GNNGraph, Int64}"><code>GraphNeuralNetworks.GNNGraphs.random_walk_pe</code></a></li><li><a href="#GraphNeuralNetworks.GNNGraphs.remove_multi_edges-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}}"><code>GraphNeuralNetworks.GNNGraphs.remove_multi_edges</code></a></li><li><a href="#GraphNeuralNetworks.GNNGraphs.remove_self_loops-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}}"><code>GraphNeuralNetworks.GNNGraphs.remove_self_loops</code></a></li><li><a href="#GraphNeuralNetworks.GNNGraphs.remove_snapshot-Tuple{TemporalSnapshotsGNNGraph, Int64}"><code>GraphNeuralNetworks.GNNGraphs.remove_snapshot</code></a></li><li><a href="#GraphNeuralNetworks.GNNGraphs.sample_neighbors"><code>GraphNeuralNetworks.GNNGraphs.sample_neighbors</code></a></li><li><a href="#GraphNeuralNetworks.GNNGraphs.scaled_laplacian"><code>GraphNeuralNetworks.GNNGraphs.scaled_laplacian</code></a></li><li><a href="#GraphNeuralNetworks.GNNGraphs.set_edge_weight-Tuple{GNNGraph, AbstractVector}"><code>GraphNeuralNetworks.GNNGraphs.set_edge_weight</code></a></li><li><a href="#GraphNeuralNetworks.GNNGraphs.to_bidirected-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}}"><code>GraphNeuralNetworks.GNNGraphs.to_bidirected</code></a></li><li><a href="#GraphNeuralNetworks.GNNGraphs.to_unidirected-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}}"><code>GraphNeuralNetworks.GNNGraphs.to_unidirected</code></a></li><li><a href="#Graphs.LinAlg.adjacency_matrix"><code>Graphs.LinAlg.adjacency_matrix</code></a></li><li><a href="#Graphs.degree-Union{Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}}, Tuple{TT}, Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}, TT}} where TT&lt;:Union{Nothing, Type{&lt;:Number}}"><code>Graphs.degree</code></a></li><li><a href="#Graphs.has_self_loops-Tuple{GNNGraph}"><code>Graphs.has_self_loops</code></a></li><li><a href="#Graphs.inneighbors"><code>Graphs.inneighbors</code></a></li><li><a href="#Graphs.outneighbors"><code>Graphs.outneighbors</code></a></li><li><a href="#MLUtils.batch-Tuple{AbstractVector{&lt;:GNNGraph}}"><code>MLUtils.batch</code></a></li><li><a href="#MLUtils.unbatch-Union{Tuple{GNNGraph{T}}, Tuple{T}} where T&lt;:(Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V})"><code>MLUtils.unbatch</code></a></li><li><a href="#SparseArrays.blockdiag-Tuple{GNNGraph, Vararg{GNNGraph}}"><code>SparseArrays.blockdiag</code></a></li></ul><h2 id="GNNGraph-type"><a class="docs-heading-anchor" href="#GNNGraph-type">GNNGraph type</a><a id="GNNGraph-type-1"></a><a class="docs-heading-anchor-permalink" href="#GNNGraph-type" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GraphNeuralNetworks.GNNGraphs.GNNGraph" href="#GraphNeuralNetworks.GNNGraphs.GNNGraph"><code>GraphNeuralNetworks.GNNGraphs.GNNGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GNNGraph(data; [graph_type, ndata, edata, gdata, num_nodes, graph_indicator, dir])
GNNGraph(g::GNNGraph; [ndata, edata, gdata])</code></pre><p>A type representing a graph structure that also stores feature arrays associated to nodes, edges, and the graph itself.</p><p>The feature arrays are stored in the fields <code>ndata</code>, <code>edata</code>, and <code>gdata</code> as <a href="#GraphNeuralNetworks.GNNGraphs.DataStore"><code>DataStore</code></a> objects offering a convenient dictionary-like  and namedtuple-like interface. The features can be passed at construction time or added later.</p><p>A <code>GNNGraph</code> can be constructed out of different <code>data</code> objects expressing the connections inside the graph. The internal representation type is determined by <code>graph_type</code>.</p><p>When constructed from another <code>GNNGraph</code>, the internal graph representation is preserved and shared. The node/edge/graph features are retained as well, unless explicitely set by the keyword arguments <code>ndata</code>, <code>edata</code>, and <code>gdata</code>.</p><p>A <code>GNNGraph</code> can also represent multiple graphs batched togheter (see <a href="#MLUtils.batch-Tuple{AbstractVector{&lt;:GNNGraph}}"><code>Flux.batch</code></a> or <a href="#SparseArrays.blockdiag-Tuple{GNNGraph, Vararg{GNNGraph}}"><code>SparseArrays.blockdiag</code></a>). The field <code>g.graph_indicator</code> contains the graph membership of each node.</p><p><code>GNNGraph</code>s are always directed graphs, therefore each edge is defined by a source node and a target node (see <a href="#GraphNeuralNetworks.GNNGraphs.edge_index-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}}"><code>edge_index</code></a>). Self loops (edges connecting a node to itself) and multiple edges (more than one edge between the same pair of nodes) are supported.</p><p>A <code>GNNGraph</code> is a Graphs.jl&#39;s <code>AbstractGraph</code>, therefore it supports most functionality from that library.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: Some data representing the graph topology. Possible type are<ul><li>An adjacency matrix</li><li>An adjacency list.</li><li>A tuple containing the source and target vectors (COO representation)</li><li>A Graphs.jl&#39; graph.</li></ul></li><li><code>graph_type</code>: A keyword argument that specifies               the underlying representation used by the GNNGraph.               Currently supported values are<ul><li><code>:coo</code>. Graph represented as a tuple <code>(source, target)</code>, such that the <code>k</code>-th edge         connects the node <code>source[k]</code> to node <code>target[k]</code>.         Optionally, also edge weights can be given: <code>(source, target, weights)</code>.</li><li><code>:sparse</code>. A sparse adjacency matrix representation.</li><li><code>:dense</code>. A dense adjacency matrix representation.</li></ul>Defaults to <code>:coo</code>, currently the most supported type.</li><li><code>dir</code>: The assumed edge direction when given adjacency matrix or adjacency list input data <code>g</code>.       Possible values are <code>:out</code> and <code>:in</code>. Default <code>:out</code>.</li><li><code>num_nodes</code>: The number of nodes. If not specified, inferred from <code>g</code>. Default <code>nothing</code>.</li><li><code>graph_indicator</code>: For batched graphs, a vector containing the graph assignment of each node. Default <code>nothing</code>.</li><li><code>ndata</code>: Node features. An array or named tuple of arrays whose last dimension has size <code>num_nodes</code>.</li><li><code>edata</code>: Edge features. An array or named tuple of arrays whose last dimension has size <code>num_edges</code>.</li><li><code>gdata</code>: Graph features. An array or named tuple of arrays whose last dimension has size <code>num_graphs</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Flux, GraphNeuralNetworks, CUDA

# Construct from adjacency list representation
data = [[2,3], [1,4,5], [1], [2,5], [2,4]]
g = GNNGraph(data)

# Number of nodes, edges, and batched graphs
g.num_nodes  # 5
g.num_edges  # 10
g.num_graphs # 1

# Same graph in COO representation
s = [1,1,2,2,2,3,4,4,5,5]
t = [2,3,1,4,5,3,2,5,2,4]
g = GNNGraph(s, t)

# From a Graphs&#39; graph
g = GNNGraph(erdos_renyi(100, 20))

# Add 2 node feature arrays at creation time
g = GNNGraph(g, ndata = (x=rand(100, g.num_nodes), y=rand(g.num_nodes)))

# Add 1 edge feature array, after the graph creation
g.edata.z = rand(16, g.num_edges)

# Add node features and edge features with default names `x` and `e`
g = GNNGraph(g, ndata = rand(100, g.num_nodes), edata = rand(16, g.num_edges))

g.ndata.x # or just g.x
g.ndata.e # or just g.e

# Send to gpu
g = g |&gt; gpu

# Collect edges&#39; source and target nodes.
# Both source and target are vectors of length num_edges
source, target = edge_index(g)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/gnngraph.jl#L8-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphNeuralNetworks.GNNGraphs.TemporalSnapshotsGNNGraph" href="#GraphNeuralNetworks.GNNGraphs.TemporalSnapshotsGNNGraph"><code>GraphNeuralNetworks.GNNGraphs.TemporalSnapshotsGNNGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TemporalSnapshotsGNNGraph(snapshots::AbstractVector{&lt;:GNNGraph})</code></pre><p>A type representing a temporal graph as a sequence of snapshots. In this case a snapshot is a <a href="#GraphNeuralNetworks.GNNGraphs.GNNGraph"><code>GNNGraph</code></a>.</p><p><code>TemporalSnapshotsGNNGraph</code> can store the feature array associated to the graph itself as a <a href="#GraphNeuralNetworks.GNNGraphs.DataStore"><code>DataStore</code></a> object,  and it uses the <a href="#GraphNeuralNetworks.GNNGraphs.DataStore"><code>DataStore</code></a> objects of each snapshot for the node and edge features. The features can be passed at construction time or added later.</p><p><strong>Constructor Arguments</strong></p><ul><li><code>snapshot</code>: a vector of snapshots, where each snapshot must have the same number of nodes.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; using GraphNeuralNetworks

julia&gt; snapshots = [rand_graph(10,20) for i in 1:5];

julia&gt; tg = TemporalSnapshotsGNNGraph(snapshots)
TemporalSnapshotsGNNGraph:
  num_nodes: [10, 10, 10, 10, 10]
  num_edges: [20, 20, 20, 20, 20]
  num_snapshots: 5

julia&gt; tg.tgdata.x = rand(4); # add temporal graph feature

julia&gt; tg # show temporal graph with new feature
TemporalSnapshotsGNNGraph:
  num_nodes: [10, 10, 10, 10, 10]
  num_edges: [20, 20, 20, 20, 20]
  num_snapshots: 5
  tgdata:
        x = 4-element Vector{Float64}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/temporalsnapshotsgnngraph.jl#L1-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphNeuralNetworks.GNNGraphs.add_snapshot-Tuple{TemporalSnapshotsGNNGraph, Int64, GNNGraph}" href="#GraphNeuralNetworks.GNNGraphs.add_snapshot-Tuple{TemporalSnapshotsGNNGraph, Int64, GNNGraph}"><code>GraphNeuralNetworks.GNNGraphs.add_snapshot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_snapshot(tg::TemporalSnapshotsGNNGraph, t::Int, g::GNNGraph)</code></pre><p>Return a <code>TemporalSnapshotsGNNGraph</code> created starting from <code>tg</code> by adding the snapshot <code>g</code> at time index <code>t</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using GraphNeuralNetworks

julia&gt; snapshots = [rand_graph(10, 20) for i in 1:5];

julia&gt; tg = TemporalSnapshotsGNNGraph(snapshots)
TemporalSnapshotsGNNGraph:
  num_nodes: [10, 10, 10, 10, 10]
  num_edges: [20, 20, 20, 20, 20]
  num_snapshots: 5

julia&gt; new_tg = add_snapshot(tg, 3, rand_graph(10, 16)) # add a new snapshot at time 3
TemporalSnapshotsGNNGraph:
  num_nodes: [10, 10, 10, 10, 10, 10]
  num_edges: [20, 20, 16, 20, 20, 20]
  num_snapshots: 6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/temporalsnapshotsgnngraph.jl#L73-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphNeuralNetworks.GNNGraphs.remove_snapshot-Tuple{TemporalSnapshotsGNNGraph, Int64}" href="#GraphNeuralNetworks.GNNGraphs.remove_snapshot-Tuple{TemporalSnapshotsGNNGraph, Int64}"><code>GraphNeuralNetworks.GNNGraphs.remove_snapshot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">remove_snapshot(tg::TemporalSnapshotsGNNGraph, t::Int)</code></pre><p>Return a <a href="#GraphNeuralNetworks.GNNGraphs.TemporalSnapshotsGNNGraph"><code>TemporalSnapshotsGNNGraph</code></a> created starting from <code>tg</code> by removing the snapshot at time index <code>t</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using GraphNeuralNetworks

julia&gt; snapshots = [rand_graph(10,20), rand_graph(10,14), rand_graph(10,22)];

julia&gt; tg = TemporalSnapshotsGNNGraph(snapshots)
TemporalSnapshotsGNNGraph:
  num_nodes: [10, 10, 10]
  num_edges: [20, 14, 22]
  num_snapshots: 3

julia&gt; new_tg = remove_snapshot(tg, 2) # remove snapshot at time 2
TemporalSnapshotsGNNGraph:
  num_nodes: [10, 10]
  num_edges: [20, 22]
  num_snapshots: 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/temporalsnapshotsgnngraph.jl#L133-L157">source</a></section></article><h2 id="DataStore"><a class="docs-heading-anchor" href="#DataStore">DataStore</a><a id="DataStore-1"></a><a class="docs-heading-anchor-permalink" href="#DataStore" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GraphNeuralNetworks.GNNGraphs.DataStore" href="#GraphNeuralNetworks.GNNGraphs.DataStore"><code>GraphNeuralNetworks.GNNGraphs.DataStore</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DataStore([n, data])
DataStore([n,] k1 = x1, k2 = x2, ...)</code></pre><p>A container for feature arrays. The optional argument <code>n</code> enforces that <code>numobs(x) == n</code> for each array contained in the datastore.</p><p>At construction time, the <code>data</code> can be provided as any iterables of pairs of symbols and arrays or as keyword arguments:</p><pre><code class="language-julia-repl hljs">julia&gt; ds = DataStore(3, x = rand(2, 3), y = rand(3))
DataStore(3) with 2 elements:
  y = 3-element Vector{Float64}
  x = 2×3 Matrix{Float64}

julia&gt; ds = DataStore(3, Dict(:x =&gt; rand(2, 3), :y =&gt; rand(3))); # equivalent to above

julia&gt; ds = DataStore(3, (x = rand(2, 3), y = rand(30)))
ERROR: AssertionError: DataStore: data[y] has 30 observations, but n = 3
Stacktrace:
 [1] DataStore(n::Int64, data::Dict{Symbol, Any})
   @ GraphNeuralNetworks.GNNGraphs ~/.julia/dev/GraphNeuralNetworks/src/GNNGraphs/datastore.jl:54
 [2] DataStore(n::Int64, data::NamedTuple{(:x, :y), Tuple{Matrix{Float64}, Vector{Float64}}})
   @ GraphNeuralNetworks.GNNGraphs ~/.julia/dev/GraphNeuralNetworks/src/GNNGraphs/datastore.jl:73
 [3] top-level scope
   @ REPL[13]:1

julia&gt; ds = DataStore(x = rand(2, 3), y = rand(30)) # no checks
DataStore() with 2 elements:
  y = 30-element Vector{Float64}
  x = 2×3 Matrix{Float64}</code></pre><p>The <code>DataStore</code> has an interface similar to both dictionaries and named tuples. Arrays can be accessed and added using either the indexing or the property syntax:</p><pre><code class="language-julia-repl hljs">julia&gt; ds = DataStore(x = ones(2, 3), y = zeros(3))
DataStore() with 2 elements:
  y = 3-element Vector{Float64}
  x = 2×3 Matrix{Float64}

julia&gt; ds.x   # same as `ds[:x]`
2×3 Matrix{Float64}:
 1.0  1.0  1.0
 1.0  1.0  1.0

julia&gt; ds.z = zeros(3)  # Add new feature array `z`. Same as `ds[:z] = rand(3)`
3-element Vector{Float64}:
0.0
0.0
0.0</code></pre><p>The <code>DataStore</code> can be iterated over, and the keys and values can be accessed using <code>keys(ds)</code> and <code>values(ds)</code>. <code>map(f, ds)</code> applies the function <code>f</code> to each feature array:</p><pre><code class="language-julia-repl hljs">julia&gt; ds = DataStore(a = zeros(2), b = zeros(2));

julia&gt; ds2 = map(x -&gt; x .+ 1, ds)

julia&gt; ds2.a
2-element Vector{Float64}:
 1.0
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/datastore.jl#L1-L70">source</a></section></article><h2 id="Query"><a class="docs-heading-anchor" href="#Query">Query</a><a id="Query-1"></a><a class="docs-heading-anchor-permalink" href="#Query" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GraphNeuralNetworks.GNNGraphs.adjacency_list-Tuple{GNNGraph, Any}" href="#GraphNeuralNetworks.GNNGraphs.adjacency_list-Tuple{GNNGraph, Any}"><code>GraphNeuralNetworks.GNNGraphs.adjacency_list</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">adjacency_list(g; dir=:out)
adjacency_list(g, nodes; dir=:out)</code></pre><p>Return the adjacency list representation (a vector of vectors) of the graph <code>g</code>.</p><p>Calling <code>a</code> the adjacency list, if <code>dir=:out</code> than <code>a[i]</code> will contain the neighbors of node <code>i</code> through outgoing edges. If <code>dir=:in</code>, it will contain neighbors from incoming edges instead.</p><p>If <code>nodes</code> is given, return the neighborhood of the nodes in <code>nodes</code> only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/query.jl#L124-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphNeuralNetworks.GNNGraphs.edge_index-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}}" href="#GraphNeuralNetworks.GNNGraphs.edge_index-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}}"><code>GraphNeuralNetworks.GNNGraphs.edge_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">edge_index(g::GNNGraph)</code></pre><p>Return a tuple containing two vectors, respectively storing  the source and target nodes for each edges in <code>g</code>.</p><pre><code class="language-julia hljs">s, t = edge_index(g)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/query.jl#L2-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphNeuralNetworks.GNNGraphs.edge_index-Tuple{GNNHeteroGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}, Tuple{Symbol, Symbol, Symbol}}" href="#GraphNeuralNetworks.GNNGraphs.edge_index-Tuple{GNNHeteroGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}, Tuple{Symbol, Symbol, Symbol}}"><code>GraphNeuralNetworks.GNNGraphs.edge_index</code></a> — <span class="docstring-category">Method</span></header><section><div><p>&quot;     edge<em>index(g::GNNHeteroGraph, [edge</em>t])</p><p>Return a tuple containing two vectors, respectively storing the source and target nodes for each edges in <code>g</code> of type <code>edge_t = (:node1_t, :rel, :node2_t)</code>.</p><p>If <code>edge_t</code> is not provided, it will error if <code>g</code> has more than one edge type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/query.jl#L16-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphNeuralNetworks.GNNGraphs.graph_indicator-Tuple{Any}" href="#GraphNeuralNetworks.GNNGraphs.graph_indicator-Tuple{Any}"><code>GraphNeuralNetworks.GNNGraphs.graph_indicator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">graph_indicator(g)</code></pre><p>Return a vector containing the graph membership (an integer from <code>1</code> to <code>g.num_graphs</code>) of each node in the graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/query.jl#L456-L461">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphNeuralNetworks.GNNGraphs.has_isolated_nodes-Tuple{GNNGraph}" href="#GraphNeuralNetworks.GNNGraphs.has_isolated_nodes-Tuple{GNNGraph}"><code>GraphNeuralNetworks.GNNGraphs.has_isolated_nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_isolated_nodes(g::GNNGraph; dir=:out)</code></pre><p>Return true if the graph <code>g</code> contains nodes with out-degree (if <code>dir=:out</code>) or in-degree (if <code>dir=:in</code>) equal to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/query.jl#L377-L382">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphNeuralNetworks.GNNGraphs.has_multi_edges-Tuple{GNNGraph}" href="#GraphNeuralNetworks.GNNGraphs.has_multi_edges-Tuple{GNNGraph}"><code>GraphNeuralNetworks.GNNGraphs.has_multi_edges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_multi_edges(g::GNNGraph)</code></pre><p>Return <code>true</code> if <code>g</code> has any multiple edges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/query.jl#L530-L534">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphNeuralNetworks.GNNGraphs.is_bidirected-Tuple{GNNGraph}" href="#GraphNeuralNetworks.GNNGraphs.is_bidirected-Tuple{GNNGraph}"><code>GraphNeuralNetworks.GNNGraphs.is_bidirected</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_bidirected(g::GNNGraph)</code></pre><p>Check if the directed graph <code>g</code> essentially corresponds to an undirected graph, i.e. if for each edge it also contains the  reverse edge. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/query.jl#L506-L512">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphNeuralNetworks.GNNGraphs.khop_adj" href="#GraphNeuralNetworks.GNNGraphs.khop_adj"><code>GraphNeuralNetworks.GNNGraphs.khop_adj</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">khop_adj(g::GNNGraph,k::Int,T::DataType=eltype(g); dir=:out, weighted=true)</code></pre><p>Return <span>$A^k$</span> where <span>$A$</span> is the adjacency matrix of the graph &#39;g&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/query.jl#L541-L546">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphNeuralNetworks.GNNGraphs.laplacian_lambda_max" href="#GraphNeuralNetworks.GNNGraphs.laplacian_lambda_max"><code>GraphNeuralNetworks.GNNGraphs.laplacian_lambda_max</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">laplacian_lambda_max(g::GNNGraph, T=Float32; add_self_loops=false, dir=:out)</code></pre><p>Return the largest eigenvalue of the normalized symmetric Laplacian of the graph <code>g</code>.</p><p>If the graph is batched from multiple graphs, return the list of the largest eigenvalue for each graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/query.jl#L551-L557">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphNeuralNetworks.GNNGraphs.normalized_laplacian" href="#GraphNeuralNetworks.GNNGraphs.normalized_laplacian"><code>GraphNeuralNetworks.GNNGraphs.normalized_laplacian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">normalized_laplacian(g, T=Float32; add_self_loops=false, dir=:out)</code></pre><p>Normalized Laplacian matrix of graph <code>g</code>.</p><p><strong>Arguments</strong></p><ul><li><code>g</code>: A <code>GNNGraph</code>.</li><li><code>T</code>: result element type.</li><li><code>add_self_loops</code>: add self-loops while calculating the matrix.</li><li><code>dir</code>: the edge directionality considered (:out, :in, :both).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/query.jl#L393-L404">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphNeuralNetworks.GNNGraphs.scaled_laplacian" href="#GraphNeuralNetworks.GNNGraphs.scaled_laplacian"><code>GraphNeuralNetworks.GNNGraphs.scaled_laplacian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">scaled_laplacian(g, T=Float32; dir=:out)</code></pre><p>Scaled Laplacian matrix of graph <code>g</code>, defined as <span>$\hat{L} = \frac{2}{\lambda_{max}} L - I$</span> where <span>$L$</span> is the normalized Laplacian matrix.</p><p><strong>Arguments</strong></p><ul><li><code>g</code>: A <code>GNNGraph</code>.</li><li><code>T</code>: result element type.</li><li><code>dir</code>: the edge directionality considered (:out, :in, :both).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/query.jl#L425-L436">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.LinAlg.adjacency_matrix" href="#Graphs.LinAlg.adjacency_matrix"><code>Graphs.LinAlg.adjacency_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">adjacency_matrix(g::GNNGraph, T=eltype(g); dir=:out, weighted=true)</code></pre><p>Return the adjacency matrix <code>A</code> for the graph <code>g</code>. </p><p>If <code>dir=:out</code>, <code>A[i,j] &gt; 0</code> denotes the presence of an edge from node <code>i</code> to node <code>j</code>. If <code>dir=:in</code> instead, <code>A[i,j] &gt; 0</code> denotes the presence of an edge from node <code>j</code> to node <code>i</code>.</p><p>User may specify the eltype <code>T</code> of the returned matrix. </p><p>If <code>weighted=true</code>, the <code>A</code> will contain the edge weights if any, otherwise the elements of <code>A</code> will be either 0 or 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/query.jl#L170-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.degree-Union{Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}}, Tuple{TT}, Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}, TT}} where TT&lt;:Union{Nothing, Type{&lt;:Number}}" href="#Graphs.degree-Union{Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}}, Tuple{TT}, Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}, TT}} where TT&lt;:Union{Nothing, Type{&lt;:Number}}"><code>Graphs.degree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">degree(g::GNNGraph, T=nothing; dir=:out, edge_weight=true)</code></pre><p>Return a vector containing the degrees of the nodes in <code>g</code>.</p><p>The gradient is propagated through this function only if <code>edge_weight</code> is <code>true</code> or a vector.</p><p><strong>Arguments</strong></p><ul><li><code>g</code>: A graph.</li><li><code>T</code>: Element type of the returned vector. If <code>nothing</code>, is      chosen based on the graph type and will be an integer      if <code>edge_weight=false</code>. Default <code>nothing</code>.</li><li><code>dir</code>: For <code>dir=:out</code> the degree of a node is counted based on the outgoing edges.        For <code>dir=:in</code>, the ingoing edges are used. If <code>dir=:both</code> we have the sum of the two.</li><li><code>edge_weight</code>: If <code>true</code> and the graph contains weighted edges, the degree will                be weighted. Set to <code>false</code> instead to just count the number of               outgoing/ingoing edges.                Finally, you can also pass a vector of weights to be used               instead of the graph&#39;s own weights.               Default <code>true</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/query.jl#L252-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.has_self_loops-Tuple{GNNGraph}" href="#Graphs.has_self_loops-Tuple{GNNGraph}"><code>Graphs.has_self_loops</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_self_loops(g::GNNGraph)</code></pre><p>Return <code>true</code> if <code>g</code> has any self loops.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/query.jl#L520-L524">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.outneighbors" href="#Graphs.outneighbors"><code>Graphs.outneighbors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">outneighbors(g, v)</code></pre><p>Return a list of all neighbors connected to vertex <code>v</code> by an outgoing edge.</p><p><strong>Implementation Notes</strong></p><p>Returns a reference to the current graph&#39;s internal structures, not a copy. Do not modify result. If the graph is modified, the behavior is undefined: the array behind this reference may be modified too, but this is not guaranteed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);

julia&gt; outneighbors(g, 4)
1-element Array{Int64,1}:
 5</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.inneighbors" href="#Graphs.inneighbors"><code>Graphs.inneighbors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inneighbors(g, v)</code></pre><p>Return a list of all neighbors connected to vertex <code>v</code> by an incoming edge.</p><p><strong>Implementation Notes</strong></p><p>Returns a reference to the current graph&#39;s internal structures, not a copy. Do not modify result. If the graph is modified, the behavior is undefined: the array behind this reference may be modified too, but this is not guaranteed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);

julia&gt; inneighbors(g, 4)
2-element Array{Int64,1}:
 3
 5</code></pre></div></section></article><h2 id="Transform"><a class="docs-heading-anchor" href="#Transform">Transform</a><a id="Transform-1"></a><a class="docs-heading-anchor-permalink" href="#Transform" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GraphNeuralNetworks.GNNGraphs.add_edges-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}}" href="#GraphNeuralNetworks.GNNGraphs.add_edges-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}}"><code>GraphNeuralNetworks.GNNGraphs.add_edges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_edges(g::GNNGraph, s::AbstractVector, t::AbstractVector; [edata])</code></pre><p>Add to graph <code>g</code> the edges with source nodes <code>s</code> and target nodes <code>t</code>. Optionally, pass the features  <code>edata</code> for the new edges. Returns a new graph sharing part of the underlying data with <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/transform.jl#L119-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphNeuralNetworks.GNNGraphs.add_edges-Tuple{GNNHeteroGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}, Pair{Tuple{Symbol, Symbol, Symbol}, &lt;:Tuple}}" href="#GraphNeuralNetworks.GNNGraphs.add_edges-Tuple{GNNHeteroGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}, Pair{Tuple{Symbol, Symbol, Symbol}, &lt;:Tuple}}"><code>GraphNeuralNetworks.GNNGraphs.add_edges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_edges(g::GNNHeteroGraph, edge_t, s, t; [edata, num_nodes])
add_edges(g::GNNHeteroGraph, edge_t =&gt; (s, t); [edata, num_nodes])</code></pre><p>Add to heterograph <code>g</code> the releation of type <code>edge_t</code> with source node vector <code>s</code> and target node vector <code>t</code>. Optionally, pass the features  <code>edata</code> for the new edges. <code>edge_t</code> is a triplet of symbols <code>(srctype, etype, dsttype)</code>. </p><p>If the edge type is not already present in the graph, it is added. If it involves new node types, they are added to the graph as well. In this case, a dictionary or named tuple of <code>num_nodes</code> can be passed to specify the number of nodes of the new types, otherwise the number of nodes is inferred from the maximum node id in <code>s</code> and <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/transform.jl#L148-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphNeuralNetworks.GNNGraphs.add_nodes-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}, Integer}" href="#GraphNeuralNetworks.GNNGraphs.add_nodes-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}, Integer}"><code>GraphNeuralNetworks.GNNGraphs.add_nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_nodes(g::GNNGraph, n; [ndata])</code></pre><p>Add <code>n</code> new nodes to graph <code>g</code>. In the  new graph, these nodes will have indexes from <code>g.num_nodes + 1</code> to <code>g.num_nodes + n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/transform.jl#L349-L355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphNeuralNetworks.GNNGraphs.add_self_loops-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}}" href="#GraphNeuralNetworks.GNNGraphs.add_self_loops-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}}"><code>GraphNeuralNetworks.GNNGraphs.add_self_loops</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_self_loops(g::GNNGraph)</code></pre><p>Return a graph with the same features as <code>g</code> but also adding edges connecting the nodes to themselves.</p><p>Nodes with already existing self-loops will obtain a second self-loop.</p><p>If the graphs has edge weights, the new edges will have weight 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/transform.jl#L2-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphNeuralNetworks.GNNGraphs.getgraph-Tuple{GNNGraph, Int64}" href="#GraphNeuralNetworks.GNNGraphs.getgraph-Tuple{GNNGraph, Int64}"><code>GraphNeuralNetworks.GNNGraphs.getgraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getgraph(g::GNNGraph, i; nmap=false)</code></pre><p>Return the subgraph of <code>g</code> induced by those nodes <code>j</code> for which <code>g.graph_indicator[j] == i</code> or, if <code>i</code> is a collection, <code>g.graph_indicator[j] ∈ i</code>.  In other words, it extract the component graphs from a batched graph. </p><p>If <code>nmap=true</code>, return also a vector <code>v</code> mapping the new nodes to the old ones.  The node <code>i</code> in the subgraph will correspond to the node <code>v[i]</code> in <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/transform.jl#L672-L682">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphNeuralNetworks.GNNGraphs.negative_sample-Tuple{GNNGraph}" href="#GraphNeuralNetworks.GNNGraphs.negative_sample-Tuple{GNNGraph}"><code>GraphNeuralNetworks.GNNGraphs.negative_sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">negative_sample(g::GNNGraph; 
                num_neg_edges = g.num_edges, 
                bidirected = is_bidirected(g))</code></pre><p>Return a graph containing random negative edges (i.e. non-edges) from graph <code>g</code> as edges.</p><p>If <code>bidirected=true</code>, the output graph will be bidirected and there will be no leakage from the origin graph. </p><p>See also <a href="#GraphNeuralNetworks.GNNGraphs.is_bidirected-Tuple{GNNGraph}"><code>is_bidirected</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/transform.jl#L736-L747">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphNeuralNetworks.GNNGraphs.rand_edge_split-Tuple{GNNGraph, Any}" href="#GraphNeuralNetworks.GNNGraphs.rand_edge_split-Tuple{GNNGraph, Any}"><code>GraphNeuralNetworks.GNNGraphs.rand_edge_split</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rand_edge_split(g::GNNGraph, frac; bidirected=is_bidirected(g)) -&gt; g1, g2</code></pre><p>Randomly partition the edges in <code>g</code> to form two graphs, <code>g1</code> and <code>g2</code>. Both will have the same number of nodes as <code>g</code>. <code>g1</code> will contain a fraction <code>frac</code> of the original edges,  while <code>g2</code> wil contain the rest.</p><p>If <code>bidirected = true</code> makes sure that an edge and its reverse go into the same split. This option is supported only for bidirected graphs with no self-loops and multi-edges.</p><p><code>rand_edge_split</code> is tipically used to create train/test splits in link prediction tasks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/transform.jl#L792-L805">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphNeuralNetworks.GNNGraphs.random_walk_pe-Tuple{GNNGraph, Int64}" href="#GraphNeuralNetworks.GNNGraphs.random_walk_pe-Tuple{GNNGraph, Int64}"><code>GraphNeuralNetworks.GNNGraphs.random_walk_pe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">random_walk_pe(g, walk_length)</code></pre><p>Return the random walk positional encoding from the paper <a href="https://arxiv.org/abs/2110.07875">Graph Neural Networks with Learnable Structural and Positional Representations</a> of the given graph <code>g</code> and the length of the walk <code>walk_length</code> as a matrix of size <code>(walk_length, g.num_nodes)</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/transform.jl#L831-L835">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphNeuralNetworks.GNNGraphs.remove_multi_edges-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}}" href="#GraphNeuralNetworks.GNNGraphs.remove_multi_edges-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}}"><code>GraphNeuralNetworks.GNNGraphs.remove_multi_edges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">remove_multi_edges(g::GNNGraph; aggr=+)</code></pre><p>Remove multiple edges (also called parallel edges or repeated edges) from graph <code>g</code>. Possible edge features are aggregated according to <code>aggr</code>, that can take value  <code>+</code>,<code>min</code>, <code>max</code> or <code>mean</code>.</p><p>See also <a href="#GraphNeuralNetworks.GNNGraphs.remove_self_loops-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}}"><code>remove_self_loops</code></a>, <a href="#GraphNeuralNetworks.GNNGraphs.has_multi_edges-Tuple{GNNGraph}"><code>has_multi_edges</code></a>, and <a href="#GraphNeuralNetworks.GNNGraphs.to_bidirected-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}}"><code>to_bidirected</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/transform.jl#L80-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphNeuralNetworks.GNNGraphs.remove_self_loops-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}}" href="#GraphNeuralNetworks.GNNGraphs.remove_self_loops-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}}"><code>GraphNeuralNetworks.GNNGraphs.remove_self_loops</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">remove_self_loops(g::GNNGraph)</code></pre><p>Return a graph constructed from <code>g</code> where self-loops (edges from a node to itself) are removed. </p><p>See also <a href="#GraphNeuralNetworks.GNNGraphs.add_self_loops-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}}"><code>add_self_loops</code></a> and <a href="#GraphNeuralNetworks.GNNGraphs.remove_multi_edges-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}}"><code>remove_multi_edges</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/transform.jl#L41-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphNeuralNetworks.GNNGraphs.set_edge_weight-Tuple{GNNGraph, AbstractVector}" href="#GraphNeuralNetworks.GNNGraphs.set_edge_weight-Tuple{GNNGraph, AbstractVector}"><code>GraphNeuralNetworks.GNNGraphs.set_edge_weight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_edge_weight(g::GNNGraph, w::AbstractVector)</code></pre><p>Set <code>w</code> as edge weights in the returned graph. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/transform.jl#L366-L370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphNeuralNetworks.GNNGraphs.to_bidirected-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}}" href="#GraphNeuralNetworks.GNNGraphs.to_bidirected-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}}"><code>GraphNeuralNetworks.GNNGraphs.to_bidirected</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_bidirected(g)</code></pre><p>Adds a reverse edge for each edge in the graph, then calls  <a href="#GraphNeuralNetworks.GNNGraphs.remove_multi_edges-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}}"><code>remove_multi_edges</code></a> with <code>mean</code> aggregation to simplify the graph. </p><p>See also <a href="#GraphNeuralNetworks.GNNGraphs.is_bidirected-Tuple{GNNGraph}"><code>is_bidirected</code></a>. </p><p><strong>Examples</strong></p><pre><code class="language-juliarepl hljs">julia&gt; s, t = [1, 2, 3, 3, 4], [2, 3, 4, 4, 4];

julia&gt; w = [1.0, 2.0, 3.0, 4.0, 5.0];

julia&gt; e = [10.0, 20.0, 30.0, 40.0, 50.0];

julia&gt; g = GNNGraph(s, t, w, edata = e)
GNNGraph:
    num_nodes = 4
    num_edges = 5
    edata:
        e =&gt; (5,)

julia&gt; g2 = to_bidirected(g)
GNNGraph:
    num_nodes = 4
    num_edges = 7
    edata:
        e =&gt; (7,)

julia&gt; edge_index(g2)
([1, 2, 2, 3, 3, 4, 4], [2, 1, 3, 2, 4, 3, 4])

julia&gt; get_edge_weight(g2)
7-element Vector{Float64}:
 1.0
 1.0
 2.0
 2.0
 3.5
 3.5
 5.0

julia&gt; g2.edata.e
7-element Vector{Float64}:
 10.0
 10.0
 20.0
 20.0
 35.0
 35.0
 50.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/transform.jl#L243-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphNeuralNetworks.GNNGraphs.to_unidirected-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}}" href="#GraphNeuralNetworks.GNNGraphs.to_unidirected-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V}}}"><code>GraphNeuralNetworks.GNNGraphs.to_unidirected</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_unidirected(g::GNNGraph)</code></pre><p>Return a graph that for each multiple edge between two nodes in <code>g</code> keeps only an edge in one direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/transform.jl#L314-L319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.batch-Tuple{AbstractVector{&lt;:GNNGraph}}" href="#MLUtils.batch-Tuple{AbstractVector{&lt;:GNNGraph}}"><code>MLUtils.batch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">batch(gs::Vector{&lt;:GNNGraph})</code></pre><p>Batch together multiple <code>GNNGraph</code>s into a single one  containing the total number of original nodes and edges.</p><p>Equivalent to <a href="#SparseArrays.blockdiag-Tuple{GNNGraph, Vararg{GNNGraph}}"><code>SparseArrays.blockdiag</code></a>. See also <a href="#MLUtils.unbatch-Union{Tuple{GNNGraph{T}}, Tuple{T}} where T&lt;:(Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V})"><code>Flux.unbatch</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-juliarepl hljs">julia&gt; g1 = rand_graph(4, 6, ndata=ones(8, 4))
GNNGraph:
    num_nodes = 4
    num_edges = 6
    ndata:
        x =&gt; (8, 4)

julia&gt; g2 = rand_graph(7, 4, ndata=zeros(8, 7))
GNNGraph:
    num_nodes = 7
    num_edges = 4
    ndata:
        x =&gt; (8, 7)

julia&gt; g12 = Flux.batch([g1, g2])
GNNGraph:
    num_nodes = 11
    num_edges = 10
    num_graphs = 2
    ndata:
        x =&gt; (8, 11)

julia&gt; g12.ndata.x
8×11 Matrix{Float64}:
 1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/transform.jl#L432-L477">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.unbatch-Union{Tuple{GNNGraph{T}}, Tuple{T}} where T&lt;:(Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V})" href="#MLUtils.unbatch-Union{Tuple{GNNGraph{T}}, Tuple{T}} where T&lt;:(Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V})"><code>MLUtils.unbatch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unbatch(g::GNNGraph)</code></pre><p>Opposite of the <a href="#MLUtils.batch-Tuple{AbstractVector{&lt;:GNNGraph}}"><code>Flux.batch</code></a> operation, returns  an array of the individual graphs batched together in <code>g</code>.</p><p>See also <a href="#MLUtils.batch-Tuple{AbstractVector{&lt;:GNNGraph}}"><code>Flux.batch</code></a> and <a href="#GraphNeuralNetworks.GNNGraphs.getgraph-Tuple{GNNGraph, Int64}"><code>getgraph</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-juliarepl hljs">julia&gt; gbatched = Flux.batch([rand_graph(5, 6), rand_graph(10, 8), rand_graph(4,2)])
GNNGraph:
    num_nodes = 19
    num_edges = 16
    num_graphs = 3

julia&gt; Flux.unbatch(gbatched)
3-element Vector{GNNGraph{Tuple{Vector{Int64}, Vector{Int64}, Nothing}}}:
 GNNGraph:
    num_nodes = 5
    num_edges = 6

 GNNGraph:
    num_nodes = 10
    num_edges = 8

 GNNGraph:
    num_nodes = 4
    num_edges = 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/transform.jl#L567-L598">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.blockdiag-Tuple{GNNGraph, Vararg{GNNGraph}}" href="#SparseArrays.blockdiag-Tuple{GNNGraph, Vararg{GNNGraph}}"><code>SparseArrays.blockdiag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">blockdiag(xs::GNNGraph...)</code></pre><p>Equivalent to <a href="#MLUtils.batch-Tuple{AbstractVector{&lt;:GNNGraph}}"><code>Flux.batch</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/transform.jl#L419-L423">source</a></section></article><h2 id="Generate"><a class="docs-heading-anchor" href="#Generate">Generate</a><a id="Generate-1"></a><a class="docs-heading-anchor-permalink" href="#Generate" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GraphNeuralNetworks.GNNGraphs.knn_graph-Tuple{AbstractMatrix, Int64}" href="#GraphNeuralNetworks.GNNGraphs.knn_graph-Tuple{AbstractMatrix, Int64}"><code>GraphNeuralNetworks.GNNGraphs.knn_graph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">knn_graph(points::AbstractMatrix, 
          k::Int; 
          graph_indicator = nothing,
          self_loops = false, 
          dir = :in, 
          kws...)</code></pre><p>Create a <code>k</code>-nearest neighbor graph where each node is linked  to its <code>k</code> closest <code>points</code>.  </p><p><strong>Arguments</strong></p><ul><li><code>points</code>: A num<em>features × num</em>nodes matrix storing the Euclidean positions of the nodes.</li><li><code>k</code>: The number of neighbors considered in the kNN algorithm.</li><li><code>graph_indicator</code>: Either nothing or a vector containing the graph assignment of each node,                     in which case the returned graph will be a batch of graphs. </li><li><code>self_loops</code>: If <code>true</code>, consider the node itself among its <code>k</code> nearest neighbors, in which               case the graph will contain self-loops. </li><li><code>dir</code>: The direction of the edges. If <code>dir=:in</code> edges go from the <code>k</code>         neighbors to the central node. If <code>dir=:out</code> we have the opposite        direction.</li><li><code>kws</code>: Further keyword arguments will be passed to the <a href="#GraphNeuralNetworks.GNNGraphs.GNNGraph"><code>GNNGraph</code></a> constructor.</li></ul><p><strong>Examples</strong></p><pre><code class="language-juliarepl hljs">julia&gt; n, k = 10, 3;

julia&gt; x = rand(3, n);

julia&gt; g = knn_graph(x, k)
GNNGraph:
    num_nodes = 10
    num_edges = 30

julia&gt; graph_indicator = [1,1,1,1,1,2,2,2,2,2];

julia&gt; g = knn_graph(x, k; graph_indicator)
GNNGraph:
    num_nodes = 10
    num_edges = 30
    num_graphs = 2
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/generate.jl#L147-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphNeuralNetworks.GNNGraphs.radius_graph-Tuple{AbstractMatrix, AbstractFloat}" href="#GraphNeuralNetworks.GNNGraphs.radius_graph-Tuple{AbstractMatrix, AbstractFloat}"><code>GraphNeuralNetworks.GNNGraphs.radius_graph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">radius_graph(points::AbstractMatrix, 
             r::AbstractFloat; 
             graph_indicator = nothing,
             self_loops = false, 
             dir = :in, 
             kws...)</code></pre><p>Create a graph where each node is linked  to its neighbors within a given distance <code>r</code>.  </p><p><strong>Arguments</strong></p><ul><li><code>points</code>: A num<em>features × num</em>nodes matrix storing the Euclidean positions of the nodes.</li><li><code>r</code>: The radius.</li><li><code>graph_indicator</code>: Either nothing or a vector containing the graph assignment of each node,                     in which case the returned graph will be a batch of graphs. </li><li><code>self_loops</code>: If <code>true</code>, consider the node itself among its neighbors, in which               case the graph will contain self-loops. </li><li><code>dir</code>: The direction of the edges. If <code>dir=:in</code> edges go from the        neighbors to the central node. If <code>dir=:out</code> we have the opposite        direction.</li><li><code>kws</code>: Further keyword arguments will be passed to the <a href="#GraphNeuralNetworks.GNNGraphs.GNNGraph"><code>GNNGraph</code></a> constructor.</li></ul><p><strong>Examples</strong></p><pre><code class="language-juliarepl hljs">julia&gt; n, r = 10, 0.75;

julia&gt; x = rand(3, n);

julia&gt; g = radius_graph(x, r)
GNNGraph:
    num_nodes = 10
    num_edges = 46

julia&gt; graph_indicator = [1,1,1,1,1,2,2,2,2,2];

julia&gt; g = radius_graph(x, r; graph_indicator)
GNNGraph:
    num_nodes = 10
    num_edges = 20
    num_graphs = 2
</code></pre><p><strong>References</strong></p><p>Section B paragraphs 1 and 2 of the paper <a href="https://arxiv.org/pdf/2101.00414.pdf">Dynamic Hidden-Variable Network Models</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/generate.jl#L228-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphNeuralNetworks.GNNGraphs.rand_bipartite_heterograph" href="#GraphNeuralNetworks.GNNGraphs.rand_bipartite_heterograph"><code>GraphNeuralNetworks.GNNGraphs.rand_bipartite_heterograph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rand_bipartite_heterograph(n1, n2, m; [bidirected, seed, node_t, edge_t, kws...])
rand_bipartite_heterograph((n1, n2), m; ...)
rand_bipartite_heterograph((n1, n2), (m1, m2); ...)</code></pre><p>Construct an <a href="../heterograph/#GraphNeuralNetworks.GNNGraphs.GNNHeteroGraph"><code>GNNHeteroGraph</code></a> with number of nodes and edges specified by <code>n1</code>, <code>n2</code> and <code>m1</code> and <code>m2</code> respectively.</p><p>See <a href="#GraphNeuralNetworks.GNNGraphs.rand_heterograph"><code>rand_heterograph</code></a> for a more general version.</p><p><strong>Keyword arguments</strong></p><ul><li><code>bidirected</code>: whether to generate a bidirected graph. Default is <code>true</code>.</li><li><code>seed</code>: random seed. Default is <code>-1</code> (no seed).</li><li><code>node_t</code>: node types. If <code>bipartite=true</code>, this should be a tuple of two node types, otherwise it should be a single node type.</li><li><code>edge_t</code>: edge types. If <code>bipartite=true</code>, this should be a tuple of two edge types, otherwise it should be a single edge type.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/generate.jl#L114-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphNeuralNetworks.GNNGraphs.rand_graph-Tuple{Integer, Integer}" href="#GraphNeuralNetworks.GNNGraphs.rand_graph-Tuple{Integer, Integer}"><code>GraphNeuralNetworks.GNNGraphs.rand_graph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rand_graph(n, m; bidirected=true, seed=-1, edge_weight = nothing, kws...)</code></pre><p>Generate a random (Erdós-Renyi) <code>GNNGraph</code> with <code>n</code> nodes and <code>m</code> edges.</p><p>If <code>bidirected=true</code> the reverse edge of each edge will be present. If <code>bidirected=false</code> instead, <code>m</code> unrelated edges are generated. In any case, the output graph will contain no self-loops or multi-edges.</p><p>A vector can be passed  as <code>edge_weight</code>. Its length has to be equal to <code>m</code> in the directed case, and <code>m÷2</code> in the bidirected one.</p><p>Use a <code>seed &gt; 0</code> for reproducibility.</p><p>Additional keyword arguments will be passed to the <a href="#GraphNeuralNetworks.GNNGraphs.GNNGraph"><code>GNNGraph</code></a> constructor.</p><p><strong>Examples</strong></p><pre><code class="language-juliarepl hljs">julia&gt; g = rand_graph(5, 4, bidirected=false)
GNNGraph:
    num_nodes = 5
    num_edges = 4

julia&gt; edge_index(g)
([1, 3, 3, 4], [5, 4, 5, 2])

# In the bidirected case, edge data will be duplicated on the reverse edges if needed.
julia&gt; g = rand_graph(5, 4, edata=rand(16, 2))
GNNGraph:
    num_nodes = 5
    num_edges = 4
    edata:
        e =&gt; (16, 4)

# Each edge has a reverse
julia&gt; edge_index(g)
([1, 3, 3, 4], [3, 4, 1, 3])
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/generate.jl#L1-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphNeuralNetworks.GNNGraphs.rand_heterograph" href="#GraphNeuralNetworks.GNNGraphs.rand_heterograph"><code>GraphNeuralNetworks.GNNGraphs.rand_heterograph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rand_heterograph(n, m; seed=-1, bidirected=false, kws...)</code></pre><p>Construct an <a href="../heterograph/#GraphNeuralNetworks.GNNGraphs.GNNHeteroGraph"><code>GNNHeteroGraph</code></a> with number of nodes and edges  specified by <code>n</code> and <code>m</code> respectively. <code>n</code> and <code>m</code> can be any iterable of pairs specifing node/edge types and their numbers.</p><p>Use a <code>seed &gt; 0</code> for reproducibility.</p><p>Setting <code>bidirected=true</code> will generate a bidirected graph, i.e. each edge will have a reverse edge. Therefore, for each edge type <code>(:A, :rel, :B)</code> a corresponding reverse edge type <code>(:B, :rel, :A)</code> will be generated.</p><p>Additional keyword arguments will be passed to the <a href="../heterograph/#GraphNeuralNetworks.GNNGraphs.GNNHeteroGraph"><code>GNNHeteroGraph</code></a> constructor.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g = rand_heterograph((:user =&gt; 10, :movie =&gt; 20),
                            (:user, :rate, :movie) =&gt; 30)
GNNHeteroGraph:
  num_nodes: (:user =&gt; 10, :movie =&gt; 20)         
  num_edges: ((:user, :rate, :movie) =&gt; 30,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/generate.jl#L50-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphNeuralNetworks.GNNGraphs.rand_temporal_hyperbolic_graph-Tuple{Int64, Int64}" href="#GraphNeuralNetworks.GNNGraphs.rand_temporal_hyperbolic_graph-Tuple{Int64, Int64}"><code>GraphNeuralNetworks.GNNGraphs.rand_temporal_hyperbolic_graph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rand_temporal_hyperbolic_graph(number_nodes::Int, 
                               number_snapshots::Int;
                               α::Real,
                               R::Real,
                               speed::Real,
                               ζ::Real=1,
                               self_loop = false,
                               kws...)</code></pre><p>Create a random temporal graph given <code>number_nodes</code> nodes and <code>number_snapshots</code> snapshots. First, the positions of the nodes are generated with a quasi-uniform distribution (depending on the parameter <code>α</code>) in hyperbolic space within a disk of radius <code>R</code>. Two nodes are connected if their hyperbolic distance is less than <code>R</code>. Each following snapshot is created in order to keep the same initial distribution.</p><p><strong>Arguments</strong></p><ul><li><code>number_nodes</code>: The number of nodes of each snapshot.</li><li><code>number_snapshots</code>: The number of snapshots.</li><li><code>α</code>: The parameter that controls the position of the points. If <code>α=ζ</code>, the points are uniformly distributed on the disk of radius <code>R</code>. If <code>α&gt;ζ</code>, the points are more concentrated in the center of the disk. If <code>α&lt;ζ</code>, the points are more concentrated at the boundary of the disk.</li><li><code>R</code>: The radius of the disk and of connection.</li><li><code>speed</code>: The speed to update the nodes.</li><li><code>ζ</code>: The parameter that controls the curvature of the disk.</li><li><code>self_loops</code>: If <code>true</code>, consider the node itself among its neighbors, in which               case the graph will contain self-loops.</li><li><code>kws</code>: Further keyword arguments will be passed to the <a href="#GraphNeuralNetworks.GNNGraphs.GNNGraph"><code>GNNGraph</code></a> constructor of each snapshot.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; n, snaps, α, R, speed, ζ = 10, 5, 1.0, 4.0, 0.1, 1.0;

julia&gt; thg = rand_temporal_hyperbolic_graph(n, snaps; α, R, speed, ζ)
TemporalSnapshotsGNNGraph:
  num_nodes: [10, 10, 10, 10, 10]
  num_edges: [44, 46, 48, 42, 38]
  num_snapshots: 5</code></pre><p><strong>References</strong></p><p>Section D of the paper <a href="https://arxiv.org/pdf/2101.00414.pdf">Dynamic Hidden-Variable Network Models</a> and the paper  <a href="https://arxiv.org/pdf/1006.5169.pdf">Hyperbolic Geometry of Complex Networks</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/generate.jl#L379-L419">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphNeuralNetworks.GNNGraphs.rand_temporal_radius_graph-Tuple{Int64, Int64, AbstractFloat, AbstractFloat}" href="#GraphNeuralNetworks.GNNGraphs.rand_temporal_radius_graph-Tuple{Int64, Int64, AbstractFloat, AbstractFloat}"><code>GraphNeuralNetworks.GNNGraphs.rand_temporal_radius_graph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rand_temporal_radius_graph(number_nodes::Int, 
                           number_snapshots::Int,
                           speed::AbstractFloat,
                           r::AbstractFloat;
                           self_loops = false,
                           dir = :in,
                           kws...)</code></pre><p>Create a random temporal graph given <code>number_nodes</code> nodes and <code>number_snapshots</code> snapshots. First, the positions of the nodes are randomly generated in the unit square. Two nodes are connected if their distance is less than a given radius <code>r</code>. Each following snapshot is obtained by applying the same construction to new positions obtained as follows. For each snapshot, the new positions of the points are determined by applying random independent displacement vectors to the previous positions. The direction of the displacement is chosen uniformly at random and its length is chosen uniformly in <code>[0, speed]</code>. Then the connections are recomputed. If a point happens to move outside the boundary, its position is updated as if it had bounced off the boundary.</p><p><strong>Arguments</strong></p><ul><li><code>number_nodes</code>: The number of nodes of each snapshot.</li><li><code>number_snapshots</code>: The number of snapshots.</li><li><code>speed</code>: The speed to update the nodes.</li><li><code>r</code>: The radius of connection.</li><li><code>self_loops</code>: If <code>true</code>, consider the node itself among its neighbors, in which               case the graph will contain self-loops. </li><li><code>dir</code>: The direction of the edges. If <code>dir=:in</code> edges go from the        neighbors to the central node. If <code>dir=:out</code> we have the opposite        direction.</li><li><code>kws</code>: Further keyword arguments will be passed to the <a href="#GraphNeuralNetworks.GNNGraphs.GNNGraph"><code>GNNGraph</code></a> constructor of each snapshot.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; n, snaps, s, r = 10, 5, 0.1, 1.5;

julia&gt; tg = rand_temporal_radius_graph(n,snaps,s,r) # complete graph at each snapshot
TemporalSnapshotsGNNGraph:
  num_nodes: [10, 10, 10, 10, 10]
  num_edges: [90, 90, 90, 90, 90]
  num_snapshots: 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/generate.jl#L304-L344">source</a></section></article><h2 id="Operators"><a class="docs-heading-anchor" href="#Operators">Operators</a><a id="Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Operators" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.intersect" href="#Base.intersect"><code>Base.intersect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">intersect(g, h)</code></pre><p>Return a graph with edges that are only in both graph <code>g</code> and graph <code>h</code>.</p><p><strong>Implementation Notes</strong></p><p>This function may produce a graph with 0-degree vertices. Preserves the eltype of the input graph.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g1 = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);

julia&gt; g2 = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);

julia&gt; foreach(println, edges(intersect(g1, g2)))
Edge 1 =&gt; 2
Edge 2 =&gt; 3
Edge 3 =&gt; 1</code></pre></div></section></article><h2 id="Sampling"><a class="docs-heading-anchor" href="#Sampling">Sampling</a><a id="Sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GraphNeuralNetworks.GNNGraphs.sample_neighbors" href="#GraphNeuralNetworks.GNNGraphs.sample_neighbors"><code>GraphNeuralNetworks.GNNGraphs.sample_neighbors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sample_neighbors(g, nodes, K=-1; dir=:in, replace=false, dropnodes=false)</code></pre><p>Sample neighboring edges of the given nodes and return the induced subgraph. For each node, a number of inbound (or outbound when <code>dir = :out</code><code>) edges will be randomly chosen.  If</code>dropnodes=false`, the graph returned will then contain all the nodes in the original graph,  but only the sampled edges.</p><p>The returned graph will contain an edge feature <code>EID</code> corresponding to the id of the edge in the original graph. If <code>dropnodes=true</code>, it will also contain a node feature <code>NID</code> with the node ids in the original graph.</p><p><strong>Arguments</strong></p><ul><li><code>g</code>. The graph.</li><li><code>nodes</code>. A list of node IDs to sample neighbors from.</li><li><code>K</code>. The maximum number of edges to be sampled for each node.      If -1, all the neighboring edges will be selected.</li><li><code>dir</code>. Determines whether to sample inbound (<code>:in</code>) or outbound (`<code>:out</code>) edges (Default <code>:in</code>).</li><li><code>replace</code>. If <code>true</code>, sample with replacement.</li><li><code>dropnodes</code>. If <code>true</code>, the resulting subgraph will contain only the nodes involved in the sampled edges.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; g = rand_graph(20, 100)
GNNGraph:
    num_nodes = 20
    num_edges = 100

julia&gt; sample_neighbors(g, 2:3)
GNNGraph:
    num_nodes = 20
    num_edges = 9
    edata:
        EID =&gt; (9,)

julia&gt; sg = sample_neighbors(g, 2:3, dropnodes=true)
GNNGraph:
    num_nodes = 10
    num_edges = 9
    ndata:
        NID =&gt; (10,)
    edata:
        EID =&gt; (9,)

julia&gt; sg.ndata.NID
10-element Vector{Int64}:
  2
  3
 17
 14
 18
 15
 16
 20
  7
 10

julia&gt; sample_neighbors(g, 2:3, 5, replace=true)
GNNGraph:
    num_nodes = 20
    num_edges = 10
    edata:
        EID =&gt; (10,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/1a4c62ba8351cf0744bdaac3ab7821ace25fa8de/src/GNNGraphs/sampling.jl#L1-L67">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../tutorials/">« Tutorials</a><a class="docs-footer-nextpage" href="../basic/">Basic Layers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 7 August 2023 22:19">Monday 7 August 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
