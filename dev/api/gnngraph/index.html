<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>GNNGraph · GraphNeuralNetworks.jl</title><meta name="title" content="GNNGraph · GraphNeuralNetworks.jl"/><meta property="og:title" content="GNNGraph · GraphNeuralNetworks.jl"/><meta property="twitter:title" content="GNNGraph · GraphNeuralNetworks.jl"/><meta name="description" content="Documentation for GraphNeuralNetworks.jl."/><meta property="og:description" content="Documentation for GraphNeuralNetworks.jl."/><meta property="twitter:description" content="Documentation for GraphNeuralNetworks.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../democards/gridtheme.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="GraphNeuralNetworks.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GraphNeuralNetworks.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Graphs</span><ul><li><a class="tocitem" href="../../gnngraph/">Working with GNNGraph</a></li><li><a class="tocitem" href="../../heterograph/">Heterogeneous Graphs</a></li><li><a class="tocitem" href="../../temporalgraph/">Temporal Graphs</a></li></ul></li><li><a class="tocitem" href="../../messagepassing/">Message Passing</a></li><li><a class="tocitem" href="../../models/">Model Building</a></li><li><a class="tocitem" href="../../datasets/">Datasets</a></li><li><a class="tocitem" href="../../tutorials/">Tutorials</a></li><li><span class="tocitem">API Reference</span><ul><li class="is-active"><a class="tocitem" href>GNNGraph</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#GNNGraph-type"><span>GNNGraph type</span></a></li><li><a class="tocitem" href="#DataStore"><span>DataStore</span></a></li><li><a class="tocitem" href="#Query"><span>Query</span></a></li><li><a class="tocitem" href="#Transform"><span>Transform</span></a></li><li><a class="tocitem" href="#Utils"><span>Utils</span></a></li><li><a class="tocitem" href="#Generate"><span>Generate</span></a></li><li><a class="tocitem" href="#Operators"><span>Operators</span></a></li><li><a class="tocitem" href="#Sampling"><span>Sampling</span></a></li></ul></li><li><a class="tocitem" href="../basic/">Basic Layers</a></li><li><a class="tocitem" href="../conv/">Convolutional Layers</a></li><li><a class="tocitem" href="../pool/">Pooling Layers</a></li><li><a class="tocitem" href="../messagepassing/">Message Passing</a></li><li><a class="tocitem" href="../heterograph/">Heterogeneous Graphs</a></li><li><a class="tocitem" href="../temporalgraph/">Temporal Graphs</a></li><li><a class="tocitem" href="../samplers/">Samplers</a></li><li><a class="tocitem" href="../utils/">Utils</a></li></ul></li><li><a class="tocitem" href="../../dev/">Developer Notes</a></li><li><a class="tocitem" href="../../gsoc/">Summer Of Code</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>GNNGraph</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>GNNGraph</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/master/GraphNeuralNetworks/docs/src/api/gnngraph.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="GNNGraph"><a class="docs-heading-anchor" href="#GNNGraph">GNNGraph</a><a id="GNNGraph-1"></a><a class="docs-heading-anchor-permalink" href="#GNNGraph" title="Permalink"></a></h1><p>Documentation page for the graph type <code>GNNGraph</code> provided by GraphNeuralNetworks.jl and related methods. </p><p>Besides the methods documented here, one can rely on the large set of functionalities given by <a href="https://github.com/JuliaGraphs/Graphs.jl">Graphs.jl</a> thanks to the fact that <code>GNNGraph</code> inherits from <code>Graphs.AbstractGraph</code>.</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#GNNGraphs.DataStore"><code>GNNGraphs.DataStore</code></a></li><li><a href="#GNNGraphs.GNNGraph"><code>GNNGraphs.GNNGraph</code></a></li><li><a href="#Base.copy"><code>Base.copy</code></a></li><li><a href="#Base.intersect"><code>Base.intersect</code></a></li><li><a href="#GNNGraphs.add_edges-Tuple{GNNHeteroGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, Tuple{Symbol, Symbol, Symbol}, AbstractVector, AbstractVector}"><code>GNNGraphs.add_edges</code></a></li><li><a href="#GNNGraphs.add_edges-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, AbstractVector, AbstractVector}"><code>GNNGraphs.add_edges</code></a></li><li><a href="#GNNGraphs.add_nodes-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, Integer}"><code>GNNGraphs.add_nodes</code></a></li><li><a href="#GNNGraphs.add_self_loops-Tuple{GNNHeteroGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, Tuple{Symbol, Symbol, Symbol}}"><code>GNNGraphs.add_self_loops</code></a></li><li><a href="#GNNGraphs.add_self_loops-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}"><code>GNNGraphs.add_self_loops</code></a></li><li><a href="#GNNGraphs.adjacency_list-Tuple{GNNGraph, Any}"><code>GNNGraphs.adjacency_list</code></a></li><li><a href="#GNNGraphs.color_refinement"><code>GNNGraphs.color_refinement</code></a></li><li><a href="#GNNGraphs.edge_index-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}"><code>GNNGraphs.edge_index</code></a></li><li><a href="#GNNGraphs.edge_index-Tuple{GNNHeteroGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, Tuple{Symbol, Symbol, Symbol}}"><code>GNNGraphs.edge_index</code></a></li><li><a href="#GNNGraphs.getgraph-Tuple{GNNGraph, Int64}"><code>GNNGraphs.getgraph</code></a></li><li><a href="#GNNGraphs.graph_indicator-Tuple{GNNGraph}"><code>GNNGraphs.graph_indicator</code></a></li><li><a href="#GNNGraphs.graph_indicator-Tuple{GNNHeteroGraph}"><code>GNNGraphs.graph_indicator</code></a></li><li><a href="#GNNGraphs.has_isolated_nodes-Tuple{GNNGraph}"><code>GNNGraphs.has_isolated_nodes</code></a></li><li><a href="#GNNGraphs.has_multi_edges-Tuple{GNNGraph}"><code>GNNGraphs.has_multi_edges</code></a></li><li><a href="#GNNGraphs.is_bidirected-Tuple{GNNGraph}"><code>GNNGraphs.is_bidirected</code></a></li><li><a href="#GNNGraphs.khop_adj"><code>GNNGraphs.khop_adj</code></a></li><li><a href="#GNNGraphs.knn_graph-Tuple{AbstractMatrix, Int64}"><code>GNNGraphs.knn_graph</code></a></li><li><a href="#GNNGraphs.laplacian_lambda_max"><code>GNNGraphs.laplacian_lambda_max</code></a></li><li><a href="#GNNGraphs.negative_sample-Tuple{GNNGraph}"><code>GNNGraphs.negative_sample</code></a></li><li><a href="#GNNGraphs.normalized_laplacian"><code>GNNGraphs.normalized_laplacian</code></a></li><li><a href="#GNNGraphs.perturb_edges-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, AbstractFloat}"><code>GNNGraphs.perturb_edges</code></a></li><li><a href="#GNNGraphs.ppr_diffusion-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}"><code>GNNGraphs.ppr_diffusion</code></a></li><li><a href="#GNNGraphs.radius_graph-Tuple{AbstractMatrix, AbstractFloat}"><code>GNNGraphs.radius_graph</code></a></li><li><a href="#GNNGraphs.rand_bipartite_heterograph-Tuple{Any, Any}"><code>GNNGraphs.rand_bipartite_heterograph</code></a></li><li><a href="#GNNGraphs.rand_edge_split-Tuple{GNNGraph, Any}"><code>GNNGraphs.rand_edge_split</code></a></li><li><a href="#GNNGraphs.rand_graph-Tuple{Integer, Integer}"><code>GNNGraphs.rand_graph</code></a></li><li><a href="#GNNGraphs.rand_heterograph"><code>GNNGraphs.rand_heterograph</code></a></li><li><a href="#GNNGraphs.random_walk_pe-Tuple{GNNGraph, Int64}"><code>GNNGraphs.random_walk_pe</code></a></li><li><a href="#GNNGraphs.remove_edges-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, AbstractVector{&lt;:Integer}}"><code>GNNGraphs.remove_edges</code></a></li><li><a href="#GNNGraphs.remove_multi_edges-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}"><code>GNNGraphs.remove_multi_edges</code></a></li><li><a href="#GNNGraphs.remove_nodes-Tuple{GNNGraph, AbstractFloat}"><code>GNNGraphs.remove_nodes</code></a></li><li><a href="#GNNGraphs.remove_nodes-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, AbstractVector}"><code>GNNGraphs.remove_nodes</code></a></li><li><a href="#GNNGraphs.remove_self_loops-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}"><code>GNNGraphs.remove_self_loops</code></a></li><li><a href="#GNNGraphs.sample_neighbors"><code>GNNGraphs.sample_neighbors</code></a></li><li><a href="#GNNGraphs.scaled_laplacian"><code>GNNGraphs.scaled_laplacian</code></a></li><li><a href="#GNNGraphs.set_edge_weight-Tuple{GNNGraph, AbstractVector}"><code>GNNGraphs.set_edge_weight</code></a></li><li><a href="#GNNGraphs.sort_edge_index"><code>GNNGraphs.sort_edge_index</code></a></li><li><a href="#GNNGraphs.to_bidirected-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}"><code>GNNGraphs.to_bidirected</code></a></li><li><a href="#GNNGraphs.to_unidirected-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}"><code>GNNGraphs.to_unidirected</code></a></li><li><a href="#Graphs.LinAlg.adjacency_matrix"><code>Graphs.LinAlg.adjacency_matrix</code></a></li><li><a href="#Graphs.degree-Union{Tuple{TT}, Tuple{GNNHeteroGraph, Tuple{Symbol, Symbol, Symbol}}, Tuple{GNNHeteroGraph, Tuple{Symbol, Symbol, Symbol}, TT}} where TT&lt;:Union{Nothing, Type{&lt;:Number}}"><code>Graphs.degree</code></a></li><li><a href="#Graphs.degree-Union{Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}, Tuple{TT}, Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, TT}} where TT&lt;:Union{Nothing, Type{&lt;:Number}}"><code>Graphs.degree</code></a></li><li><a href="#Graphs.has_self_loops-Tuple{GNNGraph}"><code>Graphs.has_self_loops</code></a></li><li><a href="#Graphs.induced_subgraph-Tuple{GNNGraph, Vector{Int64}}"><code>Graphs.induced_subgraph</code></a></li><li><a href="#Graphs.inneighbors-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, Integer}"><code>Graphs.inneighbors</code></a></li><li><a href="#Graphs.neighbors-Tuple{GNNGraph, Integer}"><code>Graphs.neighbors</code></a></li><li><a href="#Graphs.outneighbors-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, Integer}"><code>Graphs.outneighbors</code></a></li><li><a href="#MLUtils.batch-Tuple{AbstractVector{&lt;:GNNGraph}}"><code>MLUtils.batch</code></a></li><li><a href="#MLUtils.unbatch-Union{Tuple{GNNGraph{T}}, Tuple{T}} where T&lt;:(Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}})"><code>MLUtils.unbatch</code></a></li><li><a href="#SparseArrays.blockdiag-Tuple{GNNGraph, Vararg{GNNGraph}}"><code>SparseArrays.blockdiag</code></a></li></ul><h2 id="GNNGraph-type"><a class="docs-heading-anchor" href="#GNNGraph-type">GNNGraph type</a><a id="GNNGraph-type-1"></a><a class="docs-heading-anchor-permalink" href="#GNNGraph-type" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.GNNGraph" href="#GNNGraphs.GNNGraph"><code>GNNGraphs.GNNGraph</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GNNGraph(data; [graph_type, ndata, edata, gdata, num_nodes, graph_indicator, dir])
GNNGraph(g::GNNGraph; [ndata, edata, gdata])</code></pre><p>A type representing a graph structure that also stores feature arrays associated to nodes, edges, and the graph itself.</p><p>The feature arrays are stored in the fields <code>ndata</code>, <code>edata</code>, and <code>gdata</code> as <a href="#DataStore"><code>DataStore</code></a> objects offering a convenient dictionary-like  and namedtuple-like interface. The features can be passed at construction time or added later.</p><p>A <code>GNNGraph</code> can be constructed out of different <code>data</code> objects expressing the connections inside the graph. The internal representation type is determined by <code>graph_type</code>.</p><p>When constructed from another <code>GNNGraph</code>, the internal graph representation is preserved and shared. The node/edge/graph features are retained as well, unless explicitely set by the keyword arguments <code>ndata</code>, <code>edata</code>, and <code>gdata</code>.</p><p>A <code>GNNGraph</code> can also represent multiple graphs batched togheter (see <a href="#MLUtils.batch-Tuple{AbstractVector{&lt;:GNNGraph}}"><code>MLUtils.batch</code></a> or <a href="#SparseArrays.blockdiag-Tuple{GNNGraph, Vararg{GNNGraph}}"><code>SparseArrays.blockdiag</code></a>). The field <code>g.graph_indicator</code> contains the graph membership of each node.</p><p><code>GNNGraph</code>s are always directed graphs, therefore each edge is defined by a source node and a target node (see <a href="#GNNGraphs.edge_index-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}"><code>edge_index</code></a>). Self loops (edges connecting a node to itself) and multiple edges (more than one edge between the same pair of nodes) are supported.</p><p>A <code>GNNGraph</code> is a Graphs.jl&#39;s <code>AbstractGraph</code>, therefore it supports most functionality from that library.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: Some data representing the graph topology. Possible type are<ul><li>An adjacency matrix</li><li>An adjacency list.</li><li>A tuple containing the source and target vectors (COO representation)</li><li>A Graphs.jl&#39; graph.</li></ul></li><li><code>graph_type</code>: A keyword argument that specifies               the underlying representation used by the GNNGraph.               Currently supported values are<ul><li><code>:coo</code>. Graph represented as a tuple <code>(source, target)</code>, such that the <code>k</code>-th edge         connects the node <code>source[k]</code> to node <code>target[k]</code>.         Optionally, also edge weights can be given: <code>(source, target, weights)</code>.</li><li><code>:sparse</code>. A sparse adjacency matrix representation.</li><li><code>:dense</code>. A dense adjacency matrix representation.</li></ul>Defaults to <code>:coo</code>, currently the most supported type.</li><li><code>dir</code>: The assumed edge direction when given adjacency matrix or adjacency list input data <code>g</code>.       Possible values are <code>:out</code> and <code>:in</code>. Default <code>:out</code>.</li><li><code>num_nodes</code>: The number of nodes. If not specified, inferred from <code>g</code>. Default <code>nothing</code>.</li><li><code>graph_indicator</code>: For batched graphs, a vector containing the graph assignment of each node. Default <code>nothing</code>.</li><li><code>ndata</code>: Node features. An array or named tuple of arrays whose last dimension has size <code>num_nodes</code>.</li><li><code>edata</code>: Edge features. An array or named tuple of arrays whose last dimension has size <code>num_edges</code>.</li><li><code>gdata</code>: Graph features. An array or named tuple of arrays whose last dimension has size <code>num_graphs</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using GraphNeuralNetworks

# Construct from adjacency list representation
data = [[2,3], [1,4,5], [1], [2,5], [2,4]]
g = GNNGraph(data)

# Number of nodes, edges, and batched graphs
g.num_nodes  # 5
g.num_edges  # 10
g.num_graphs # 1

# Same graph in COO representation
s = [1,1,2,2,2,3,4,4,5,5]
t = [2,3,1,4,5,3,2,5,2,4]
g = GNNGraph(s, t)

# From a Graphs&#39; graph
g = GNNGraph(erdos_renyi(100, 20))

# Add 2 node feature arrays at creation time
g = GNNGraph(g, ndata = (x=rand(100, g.num_nodes), y=rand(g.num_nodes)))

# Add 1 edge feature array, after the graph creation
g.edata.z = rand(16, g.num_edges)

# Add node features and edge features with default names `x` and `e`
g = GNNGraph(g, ndata = rand(100, g.num_nodes), edata = rand(16, g.num_edges))

g.ndata.x # or just g.x
g.edata.e # or just g.e

# Collect edges&#39; source and target nodes.
# Both source and target are vectors of length num_edges
source, target = edge_index(g)</code></pre><p>A <code>GNNGraph</code> can be sent to the GPU using e.g. Flux&#39;s <code>gpu</code> function:</p><pre><code class="nohighlight hljs"># Send to gpu
using Flux, CUDA
g = g |&gt; Flux.gpu</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/gnngraph.jl#L8-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.copy" href="#Base.copy"><code>Base.copy</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">copy(g::GNNGraph; deep=false)</code></pre><p>Create a copy of <code>g</code>. If <code>deep</code> is <code>true</code>, then copy will be a deep copy (equivalent to <code>deepcopy(g)</code>), otherwise it will be a shallow copy with the same underlying graph data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/gnngraph.jl#L218-L223">source</a></section></article><h2 id="DataStore"><a class="docs-heading-anchor" href="#DataStore">DataStore</a><a id="DataStore-1"></a><a class="docs-heading-anchor-permalink" href="#DataStore" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.DataStore" href="#GNNGraphs.DataStore"><code>GNNGraphs.DataStore</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DataStore([n, data])
DataStore([n,] k1 = x1, k2 = x2, ...)</code></pre><p>A container for feature arrays. The optional argument <code>n</code> enforces that <code>numobs(x) == n</code> for each array contained in the datastore.</p><p>At construction time, the <code>data</code> can be provided as any iterables of pairs of symbols and arrays or as keyword arguments:</p><pre><code class="language-julia-repl hljs">julia&gt; ds = DataStore(3, x = rand(Float32, 2, 3), y = rand(Float32, 3))
DataStore(3) with 2 elements:
  y = 3-element Vector{Float32}
  x = 2×3 Matrix{Float32}

julia&gt; ds = DataStore(3, Dict(:x =&gt; rand(Float32, 2, 3), :y =&gt; rand(Float32, 3))); # equivalent to above

julia&gt; ds = DataStore(3, (x = rand(Float32, 2, 3), y = rand(Float32, 30)))
ERROR: AssertionError: DataStore: data[y] has 30 observations, but n = 3
Stacktrace:
 [1] DataStore(n::Int64, data::Dict{Symbol, Any})
   @ GNNGraphs ~/.julia/dev/GNNGraphs/datastore.jl:54
 [2] DataStore(n::Int64, data::NamedTuple{(:x, :y), Tuple{Matrix{Float32}, Vector{Float32}}})
   @ GNNGraphs ~/.julia/dev/GNNGraphs/datastore.jl:73
 [3] top-level scope
   @ REPL[13]:1

julia&gt; ds = DataStore(x = randFloat32, 2, 3), y = rand(Float32, 30)) # no checks
DataStore() with 2 elements:
  y = 30-element Vector{Float32}
  x = 2×3 Matrix{Float32}
  y = 30-element Vector{Float64}
  x = 2×3 Matrix{Float64}</code></pre><p>The <code>DataStore</code> has an interface similar to both dictionaries and named tuples. Arrays can be accessed and added using either the indexing or the property syntax:</p><pre><code class="language-julia-repl hljs">julia&gt; ds = DataStore(x = ones(Float32, 2, 3), y = zeros(Float32, 3))
DataStore() with 2 elements:
  y = 3-element Vector{Float32}
  x = 2×3 Matrix{Float32}

julia&gt; ds.x   # same as `ds[:x]`
2×3 Matrix{Float32}:
 1.0  1.0  1.0
 1.0  1.0  1.0

julia&gt; ds.z = zeros(Float32, 3)  # Add new feature array `z`. Same as `ds[:z] = rand(Float32, 3)`
3-element Vector{Float64}:
0.0
0.0
0.0</code></pre><p>The <code>DataStore</code> can be iterated over, and the keys and values can be accessed using <code>keys(ds)</code> and <code>values(ds)</code>. <code>map(f, ds)</code> applies the function <code>f</code> to each feature array:</p><pre><code class="language-julia-repl hljs">julia&gt; ds = DataStore(a = zeros(2), b = zeros(2));

julia&gt; ds2 = map(x -&gt; x .+ 1, ds)

julia&gt; ds2.a
2-element Vector{Float64}:
 1.0
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/datastore.jl#L1-L72">source</a></section></article><h2 id="Query"><a class="docs-heading-anchor" href="#Query">Query</a><a id="Query-1"></a><a class="docs-heading-anchor-permalink" href="#Query" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.adjacency_list-Tuple{GNNGraph, Any}" href="#GNNGraphs.adjacency_list-Tuple{GNNGraph, Any}"><code>GNNGraphs.adjacency_list</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">adjacency_list(g; dir=:out)
adjacency_list(g, nodes; dir=:out)</code></pre><p>Return the adjacency list representation (a vector of vectors) of the graph <code>g</code>.</p><p>Calling <code>a</code> the adjacency list, if <code>dir=:out</code> than <code>a[i]</code> will contain the neighbors of node <code>i</code> through outgoing edges. If <code>dir=:in</code>, it will contain neighbors from incoming edges instead.</p><p>If <code>nodes</code> is given, return the neighborhood of the nodes in <code>nodes</code> only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/query.jl#L148-L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.edge_index-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}" href="#GNNGraphs.edge_index-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}"><code>GNNGraphs.edge_index</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">edge_index(g::GNNGraph)</code></pre><p>Return a tuple containing two vectors, respectively storing  the source and target nodes for each edges in <code>g</code>.</p><pre><code class="language-julia hljs">s, t = edge_index(g)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/query.jl#L2-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.edge_index-Tuple{GNNHeteroGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, Tuple{Symbol, Symbol, Symbol}}" href="#GNNGraphs.edge_index-Tuple{GNNHeteroGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, Tuple{Symbol, Symbol, Symbol}}"><code>GNNGraphs.edge_index</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">edge_index(g::GNNHeteroGraph, [edge_t])</code></pre><p>Return a tuple containing two vectors, respectively storing the source and target nodes for each edges in <code>g</code> of type <code>edge_t = (src_t, rel_t, trg_t)</code>.</p><p>If <code>edge_t</code> is not provided, it will error if <code>g</code> has more than one edge type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/query.jl#L16-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.graph_indicator-Tuple{GNNGraph}" href="#GNNGraphs.graph_indicator-Tuple{GNNGraph}"><code>GNNGraphs.graph_indicator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">graph_indicator(g::GNNGraph; edges=false)</code></pre><p>Return a vector containing the graph membership (an integer from <code>1</code> to <code>g.num_graphs</code>) of each node in the graph. If <code>edges=true</code>, return the graph membership of each edge instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/query.jl#L509-L515">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.graph_indicator-Tuple{GNNHeteroGraph}" href="#GNNGraphs.graph_indicator-Tuple{GNNHeteroGraph}"><code>GNNGraphs.graph_indicator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">graph_indicator(g::GNNHeteroGraph, [node_t])</code></pre><p>Return a Dict of vectors containing the graph membership (an integer from <code>1</code> to <code>g.num_graphs</code>) of each node in the graph for each node type. If <code>node_t</code> is provided, return the graph membership of each node of type <code>node_t</code> instead.</p><p>See also <a href="#MLUtils.batch-Tuple{AbstractVector{&lt;:GNNGraph}}"><code>batch</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/query.jl#L530-L538">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.has_isolated_nodes-Tuple{GNNGraph}" href="#GNNGraphs.has_isolated_nodes-Tuple{GNNGraph}"><code>GNNGraphs.has_isolated_nodes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_isolated_nodes(g::GNNGraph; dir=:out)</code></pre><p>Return true if the graph <code>g</code> contains nodes with out-degree (if <code>dir=:out</code>) or in-degree (if <code>dir = :in</code>) equal to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/query.jl#L430-L435">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.has_multi_edges-Tuple{GNNGraph}" href="#GNNGraphs.has_multi_edges-Tuple{GNNGraph}"><code>GNNGraphs.has_multi_edges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_multi_edges(g::GNNGraph)</code></pre><p>Return <code>true</code> if <code>g</code> has any multiple edges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/query.jl#L607-L611">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.is_bidirected-Tuple{GNNGraph}" href="#GNNGraphs.is_bidirected-Tuple{GNNGraph}"><code>GNNGraphs.is_bidirected</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_bidirected(g::GNNGraph)</code></pre><p>Check if the directed graph <code>g</code> essentially corresponds to an undirected graph, i.e. if for each edge it also contains the  reverse edge. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/query.jl#L583-L589">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.khop_adj" href="#GNNGraphs.khop_adj"><code>GNNGraphs.khop_adj</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">khop_adj(g::GNNGraph,k::Int,T::DataType=eltype(g); dir=:out, weighted=true)</code></pre><p>Return <span>$A^k$</span> where <span>$A$</span> is the adjacency matrix of the graph &#39;g&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/query.jl#L618-L623">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.laplacian_lambda_max" href="#GNNGraphs.laplacian_lambda_max"><code>GNNGraphs.laplacian_lambda_max</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">laplacian_lambda_max(g::GNNGraph, T=Float32; add_self_loops=false, dir=:out)</code></pre><p>Return the largest eigenvalue of the normalized symmetric Laplacian of the graph <code>g</code>.</p><p>If the graph is batched from multiple graphs, return the list of the largest eigenvalue for each graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/query.jl#L628-L634">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.normalized_laplacian" href="#GNNGraphs.normalized_laplacian"><code>GNNGraphs.normalized_laplacian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normalized_laplacian(g, T=Float32; add_self_loops=false, dir=:out)</code></pre><p>Normalized Laplacian matrix of graph <code>g</code>.</p><p><strong>Arguments</strong></p><ul><li><code>g</code>: A <code>GNNGraph</code>.</li><li><code>T</code>: result element type.</li><li><code>add_self_loops</code>: add self-loops while calculating the matrix.</li><li><code>dir</code>: the edge directionality considered (:out, :in, :both).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/query.jl#L446-L457">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.scaled_laplacian" href="#GNNGraphs.scaled_laplacian"><code>GNNGraphs.scaled_laplacian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">scaled_laplacian(g, T=Float32; dir=:out)</code></pre><p>Scaled Laplacian matrix of graph <code>g</code>, defined as <span>$\hat{L} = \frac{2}{\lambda_{max}} L - I$</span> where <span>$L$</span> is the normalized Laplacian matrix.</p><p><strong>Arguments</strong></p><ul><li><code>g</code>: A <code>GNNGraph</code>.</li><li><code>T</code>: result element type.</li><li><code>dir</code>: the edge directionality considered (:out, :in, :both).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/query.jl#L478-L489">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.LinAlg.adjacency_matrix" href="#Graphs.LinAlg.adjacency_matrix"><code>Graphs.LinAlg.adjacency_matrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">adjacency_matrix(g::GNNGraph, T=eltype(g); dir=:out, weighted=true)</code></pre><p>Return the adjacency matrix <code>A</code> for the graph <code>g</code>. </p><p>If <code>dir=:out</code>, <code>A[i,j] &gt; 0</code> denotes the presence of an edge from node <code>i</code> to node <code>j</code>. If <code>dir=:in</code> instead, <code>A[i,j] &gt; 0</code> denotes the presence of an edge from node <code>j</code> to node <code>i</code>.</p><p>User may specify the eltype <code>T</code> of the returned matrix. </p><p>If <code>weighted=true</code>, the <code>A</code> will contain the edge weights if any, otherwise the elements of <code>A</code> will be either 0 or 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/query.jl#L194-L205">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.degree-Union{Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}, Tuple{TT}, Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, TT}} where TT&lt;:Union{Nothing, Type{&lt;:Number}}" href="#Graphs.degree-Union{Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}, Tuple{TT}, Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, TT}} where TT&lt;:Union{Nothing, Type{&lt;:Number}}"><code>Graphs.degree</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">degree(g::GNNGraph, T=nothing; dir=:out, edge_weight=true)</code></pre><p>Return a vector containing the degrees of the nodes in <code>g</code>.</p><p>The gradient is propagated through this function only if <code>edge_weight</code> is <code>true</code> or a vector.</p><p><strong>Arguments</strong></p><ul><li><code>g</code>: A graph.</li><li><code>T</code>: Element type of the returned vector. If <code>nothing</code>, is      chosen based on the graph type and will be an integer      if <code>edge_weight = false</code>. Default <code>nothing</code>.</li><li><code>dir</code>: For <code>dir = :out</code> the degree of a node is counted based on the outgoing edges.        For <code>dir = :in</code>, the ingoing edges are used. If <code>dir = :both</code> we have the sum of the two.</li><li><code>edge_weight</code>: If <code>true</code> and the graph contains weighted edges, the degree will                be weighted. Set to <code>false</code> instead to just count the number of               outgoing/ingoing edges.                Finally, you can also pass a vector of weights to be used               instead of the graph&#39;s own weights.               Default <code>true</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/query.jl#L276-L299">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.degree-Union{Tuple{TT}, Tuple{GNNHeteroGraph, Tuple{Symbol, Symbol, Symbol}}, Tuple{GNNHeteroGraph, Tuple{Symbol, Symbol, Symbol}, TT}} where TT&lt;:Union{Nothing, Type{&lt;:Number}}" href="#Graphs.degree-Union{Tuple{TT}, Tuple{GNNHeteroGraph, Tuple{Symbol, Symbol, Symbol}}, Tuple{GNNHeteroGraph, Tuple{Symbol, Symbol, Symbol}, TT}} where TT&lt;:Union{Nothing, Type{&lt;:Number}}"><code>Graphs.degree</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">degree(g::GNNHeteroGraph, edge_type::EType; dir = :in)</code></pre><p>Return a vector containing the degrees of the nodes in <code>g</code> GNNHeteroGraph given <code>edge_type</code>.</p><p><strong>Arguments</strong></p><ul><li><code>g</code>: A graph.</li><li><code>edge_type</code>: A tuple of symbols <code>(source_t, edge_t, target_t)</code> representing the edge type.</li><li><code>T</code>: Element type of the returned vector. If <code>nothing</code>, is      chosen based on the graph type. Default <code>nothing</code>.</li><li><code>dir</code>: For <code>dir = :out</code> the degree of a node is counted based on the outgoing edges.        For <code>dir = :in</code>, the ingoing edges are used. If <code>dir = :both</code> we have the sum of the two.        Default <code>dir = :out</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/query.jl#L341-L357">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.has_self_loops-Tuple{GNNGraph}" href="#Graphs.has_self_loops-Tuple{GNNGraph}"><code>Graphs.has_self_loops</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_self_loops(g::GNNGraph)</code></pre><p>Return <code>true</code> if <code>g</code> has any self loops.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/query.jl#L597-L601">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.inneighbors-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, Integer}" href="#Graphs.inneighbors-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, Integer}"><code>Graphs.inneighbors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inneighbors(g::GNNGraph, i::Integer)</code></pre><p>Return the neighbors of node <code>i</code> in the graph <code>g</code> through incoming edges.</p><p>See also <a href="#Graphs.neighbors-Tuple{GNNGraph, Integer}"><code>neighbors</code></a> and <a href="#Graphs.outneighbors-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, Integer}"><code>outneighbors</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/query.jl#L128-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.outneighbors-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, Integer}" href="#Graphs.outneighbors-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, Integer}"><code>Graphs.outneighbors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">outneighbors(g::GNNGraph, i::Integer)</code></pre><p>Return the neighbors of node <code>i</code> in the graph <code>g</code> through outgoing edges.</p><p>See also <a href="#Graphs.neighbors-Tuple{GNNGraph, Integer}"><code>neighbors</code></a> and <a href="#Graphs.inneighbors-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, Integer}"><code>inneighbors</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/query.jl#L111-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.neighbors-Tuple{GNNGraph, Integer}" href="#Graphs.neighbors-Tuple{GNNGraph, Integer}"><code>Graphs.neighbors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">neighbors(g::GNNGraph, i::Integer; dir=:out)</code></pre><p>Return the neighbors of node <code>i</code> in the graph <code>g</code>. If <code>dir=:out</code>, return the neighbors through outgoing edges. If <code>dir=:in</code>, return the neighbors through incoming edges.</p><p>See also <a href="#Graphs.outneighbors-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, Integer}"><code>outneighbors</code></a>, <a href="#Graphs.inneighbors-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, Integer}"><code>inneighbors</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/query.jl#L93-L101">source</a></section></article><h2 id="Transform"><a class="docs-heading-anchor" href="#Transform">Transform</a><a id="Transform-1"></a><a class="docs-heading-anchor-permalink" href="#Transform" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.add_edges-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, AbstractVector, AbstractVector}" href="#GNNGraphs.add_edges-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, AbstractVector, AbstractVector}"><code>GNNGraphs.add_edges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_edges(g::GNNGraph, s::AbstractVector, t::AbstractVector; [edata])
add_edges(g::GNNGraph, (s, t); [edata])
add_edges(g::GNNGraph, (s, t, w); [edata])</code></pre><p>Add to graph <code>g</code> the edges with source nodes <code>s</code> and target nodes <code>t</code>. Optionally, pass the edge weight <code>w</code> and the features  <code>edata</code> for the new edges. Returns a new graph sharing part of the underlying data with <code>g</code>.</p><p>If the <code>s</code> or <code>t</code> contain nodes that are not already present in the graph, they are added to the graph as well.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; s, t = [1, 2, 3, 3, 4], [2, 3, 4, 4, 4];

julia&gt; w = Float32[1.0, 2.0, 3.0, 4.0, 5.0];

julia&gt; g = GNNGraph((s, t, w))
GNNGraph:
  num_nodes: 4
  num_edges: 5

julia&gt; add_edges(g, ([2, 3], [4, 1], [10.0, 20.0]))
GNNGraph:
  num_nodes: 4
  num_edges: 7</code></pre><pre><code class="language-julia-repl hljs">julia&gt; g = GNNGraph()
GNNGraph:
    num_nodes: 0
    num_edges: 0

julia&gt; add_edges(g, [1,2], [2,3])
GNNGraph:
    num_nodes: 3
    num_edges: 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/transform.jl#L355-L395">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.add_edges-Tuple{GNNHeteroGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, Tuple{Symbol, Symbol, Symbol}, AbstractVector, AbstractVector}" href="#GNNGraphs.add_edges-Tuple{GNNHeteroGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, Tuple{Symbol, Symbol, Symbol}, AbstractVector, AbstractVector}"><code>GNNGraphs.add_edges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_edges(g::GNNHeteroGraph, edge_t, s, t; [edata, num_nodes])
add_edges(g::GNNHeteroGraph, edge_t =&gt; (s, t); [edata, num_nodes])
add_edges(g::GNNHeteroGraph, edge_t =&gt; (s, t, w); [edata, num_nodes])</code></pre><p>Add to heterograph <code>g</code> edges of type <code>edge_t</code> with source node vector <code>s</code> and target node vector <code>t</code>. Optionally, pass the  edge weights <code>w</code> or the features  <code>edata</code> for the new edges. <code>edge_t</code> is a triplet of symbols <code>(src_t, rel_t, dst_t)</code>. </p><p>If the edge type is not already present in the graph, it is added.  If it involves new node types, they are added to the graph as well. In this case, a dictionary or named tuple of <code>num_nodes</code> can be passed to specify the number of nodes of the new types, otherwise the number of nodes is inferred from the maximum node id in <code>s</code> and <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/transform.jl#L432-L445">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.add_nodes-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, Integer}" href="#GNNGraphs.add_nodes-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, Integer}"><code>GNNGraphs.add_nodes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_nodes(g::GNNGraph, n; [ndata])</code></pre><p>Add <code>n</code> new nodes to graph <code>g</code>. In the  new graph, these nodes will have indexes from <code>g.num_nodes + 1</code> to <code>g.num_nodes + n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/transform.jl#L711-L717">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.add_self_loops-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}" href="#GNNGraphs.add_self_loops-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}"><code>GNNGraphs.add_self_loops</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_self_loops(g::GNNGraph)</code></pre><p>Return a graph with the same features as <code>g</code> but also adding edges connecting the nodes to themselves.</p><p>Nodes with already existing self-loops will obtain a second self-loop.</p><p>If the graphs has edge weights, the new edges will have weight 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/transform.jl#L2-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.add_self_loops-Tuple{GNNHeteroGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, Tuple{Symbol, Symbol, Symbol}}" href="#GNNGraphs.add_self_loops-Tuple{GNNHeteroGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, Tuple{Symbol, Symbol, Symbol}}"><code>GNNGraphs.add_self_loops</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_self_loops(g::GNNHeteroGraph, edge_t::EType)
add_self_loops(g::GNNHeteroGraph)</code></pre><p>If the source node type is the same as the destination node type in <code>edge_t</code>, return a graph with the same features as <code>g</code> but also add self-loops  of the specified type, <code>edge_t</code>. Otherwise, it returns <code>g</code> unchanged.</p><p>Nodes with already existing self-loops of type <code>edge_t</code> will obtain  a second set of self-loops of the same type.</p><p>If the graph has edge weights for edges of type <code>edge_t</code>, the new edges will have weight 1.</p><p>If no edges of type <code>edge_t</code> exist, or all existing edges have no weight,  then all new self loops will have no weight.</p><p>If <code>edge_t</code> is not passed as argument, for the entire graph self-loop is added to each node for every edge type in the graph where the source and destination node types are the same.  This iterates over all edge types present in the graph, applying the self-loop addition logic to each applicable edge type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/transform.jl#L41-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.getgraph-Tuple{GNNGraph, Int64}" href="#GNNGraphs.getgraph-Tuple{GNNGraph, Int64}"><code>GNNGraphs.getgraph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getgraph(g::GNNGraph, i; nmap=false)</code></pre><p>Return the subgraph of <code>g</code> induced by those nodes <code>j</code> for which <code>g.graph_indicator[j] == i</code> or, if <code>i</code> is a collection, <code>g.graph_indicator[j] ∈ i</code>.  In other words, it extract the component graphs from a batched graph. </p><p>If <code>nmap=true</code>, return also a vector <code>v</code> mapping the new nodes to the old ones.  The node <code>i</code> in the subgraph will correspond to the node <code>v[i]</code> in <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/transform.jl#L1057-L1067">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.negative_sample-Tuple{GNNGraph}" href="#GNNGraphs.negative_sample-Tuple{GNNGraph}"><code>GNNGraphs.negative_sample</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">negative_sample(g::GNNGraph; 
                num_neg_edges = g.num_edges, 
                bidirected = is_bidirected(g))</code></pre><p>Return a graph containing random negative edges (i.e. non-edges) from graph <code>g</code> as edges.</p><p>If <code>bidirected=true</code>, the output graph will be bidirected and there will be no leakage from the origin graph. </p><p>See also <a href="#GNNGraphs.is_bidirected-Tuple{GNNGraph}"><code>is_bidirected</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/transform.jl#L1121-L1132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.perturb_edges-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, AbstractFloat}" href="#GNNGraphs.perturb_edges-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, AbstractFloat}"><code>GNNGraphs.perturb_edges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">perturb_edges([rng], g::GNNGraph, perturb_ratio)</code></pre><p>Return a new graph obtained from <code>g</code> by adding random edges, based on a specified <code>perturb_ratio</code>.  The <code>perturb_ratio</code> determines the fraction of new edges to add relative to the current number of edges in the graph.  These new edges are added without creating self-loops. </p><p>The function returns a new <code>GNNGraph</code> instance that shares some of the underlying data with <code>g</code> but includes the additional edges.  The nodes for the new edges are selected randomly, and no edge data (<code>edata</code>) or weights (<code>w</code>) are assigned to these new edges.</p><p><strong>Arguments</strong></p><ul><li><code>g::GNNGraph</code>: The graph to be perturbed.</li><li><code>perturb_ratio</code>: The ratio of the number of new edges to add relative to the current number of edges in the graph. For example, a <code>perturb_ratio</code> of 0.1 means that 10% of the current number of edges will be added as new random edges.</li><li><code>rng</code>: An optionalrandom number generator to ensure reproducible results.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; g = GNNGraph((s, t, w))
GNNGraph:
  num_nodes: 4
  num_edges: 5

julia&gt; perturbed_g = perturb_edges(g, 0.2)
GNNGraph:
  num_nodes: 4
  num_edges: 6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/transform.jl#L520-L549">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.ppr_diffusion-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}" href="#GNNGraphs.ppr_diffusion-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}"><code>GNNGraphs.ppr_diffusion</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ppr_diffusion(g::GNNGraph{&lt;:COO_T}, alpha =0.85f0) -&gt; GNNGraph</code></pre><p>Calculates the Personalized PageRank (PPR) diffusion based on the edge weight matrix of a GNNGraph and updates the graph with new edge weights derived from the PPR matrix. References paper: <a href="http://ilpubs.stanford.edu:8090/422">The pagerank citation ranking: Bringing order to the web</a></p><p>The function performs the following steps:</p><ol><li>Constructs a modified adjacency matrix <code>A</code> using the graph&#39;s edge weights, where <code>A</code> is adjusted by <code>(α - 1) * A + I</code>, with <code>α</code> being the damping factor (<code>alpha_f32</code>) and <code>I</code> the identity matrix.</li><li>Normalizes <code>A</code> to ensure each column sums to 1, representing transition probabilities.</li><li>Applies the PPR formula <code>α * (I + (α - 1) * A)^-1</code> to compute the diffusion matrix.</li><li>Updates the original edge weights of the graph based on the PPR diffusion matrix, assigning new weights for each edge from the PPR matrix.</li></ol><p><strong>Arguments</strong></p><ul><li><code>g::GNNGraph</code>: The input graph for which PPR diffusion is to be calculated. It should have edge weights available.</li><li><code>alpha_f32::Float32</code>: The damping factor used in PPR calculation, controlling the teleport probability in the random walk. Defaults to <code>0.85f0</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A new <code>GNNGraph</code> instance with the same structure as <code>g</code> but with updated edge weights according to the PPR diffusion calculation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/transform.jl#L1249-L1268">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.rand_edge_split-Tuple{GNNGraph, Any}" href="#GNNGraphs.rand_edge_split-Tuple{GNNGraph, Any}"><code>GNNGraphs.rand_edge_split</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rand_edge_split(g::GNNGraph, frac; bidirected=is_bidirected(g)) -&gt; g1, g2</code></pre><p>Randomly partition the edges in <code>g</code> to form two graphs, <code>g1</code> and <code>g2</code>. Both will have the same number of nodes as <code>g</code>. <code>g1</code> will contain a fraction <code>frac</code> of the original edges,  while <code>g2</code> wil contain the rest.</p><p>If <code>bidirected = true</code> makes sure that an edge and its reverse go into the same split. This option is supported only for bidirected graphs with no self-loops and multi-edges.</p><p><code>rand_edge_split</code> is tipically used to create train/test splits in link prediction tasks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/transform.jl#L1174-L1187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.random_walk_pe-Tuple{GNNGraph, Int64}" href="#GNNGraphs.random_walk_pe-Tuple{GNNGraph, Int64}"><code>GNNGraphs.random_walk_pe</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">random_walk_pe(g, walk_length)</code></pre><p>Return the random walk positional encoding from the paper <a href="https://arxiv.org/abs/2110.07875">Graph Neural Networks with Learnable Structural and Positional Representations</a> of the given graph <code>g</code> and the length of the walk <code>walk_length</code> as a matrix of size <code>(walk_length, g.num_nodes)</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/transform.jl#L1213-L1217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.remove_edges-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, AbstractVector{&lt;:Integer}}" href="#GNNGraphs.remove_edges-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, AbstractVector{&lt;:Integer}}"><code>GNNGraphs.remove_edges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_edges(g::GNNGraph, edges_to_remove::AbstractVector{&lt;:Integer})
remove_edges(g::GNNGraph, p=0.5)</code></pre><p>Remove specified edges from a GNNGraph, either by specifying edge indices or by randomly removing edges with a given probability.</p><p><strong>Arguments</strong></p><ul><li><code>g</code>: The input graph from which edges will be removed.</li><li><code>edges_to_remove</code>: Vector of edge indices to be removed. This argument is only required for the first method.</li><li><code>p</code>: Probability of removing each edge. This argument is only required for the second method and defaults to 0.5.</li></ul><p><strong>Returns</strong></p><p>A new GNNGraph with the specified edges removed.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; using GraphNeuralNetworks

# Construct a GNNGraph
julia&gt; g = GNNGraph([1, 1, 2, 2, 3], [2, 3, 1, 3, 1])
GNNGraph:
  num_nodes: 3
  num_edges: 5
  
# Remove the second edge
julia&gt; g_new = remove_edges(g, [2]);

julia&gt; g_new
GNNGraph:
  num_nodes: 3
  num_edges: 4

# Remove edges with a probability of 0.5
julia&gt; g_new = remove_edges(g, 0.5);

julia&gt; g_new
GNNGraph:
  num_nodes: 3
  num_edges: 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/transform.jl#L157-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.remove_multi_edges-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}" href="#GNNGraphs.remove_multi_edges-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}"><code>GNNGraphs.remove_multi_edges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_multi_edges(g::GNNGraph; aggr=+)</code></pre><p>Remove multiple edges (also called parallel edges or repeated edges) from graph <code>g</code>. Possible edge features are aggregated according to <code>aggr</code>, that can take value  <code>+</code>,<code>min</code>, <code>max</code> or <code>mean</code>.</p><p>See also <a href="#GNNGraphs.remove_self_loops-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}"><code>remove_self_loops</code></a>, <a href="#GNNGraphs.has_multi_edges-Tuple{GNNGraph}"><code>has_multi_edges</code></a>, and <a href="#GNNGraphs.to_bidirected-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}"><code>to_bidirected</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/transform.jl#L225-L233">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.remove_nodes-Tuple{GNNGraph, AbstractFloat}" href="#GNNGraphs.remove_nodes-Tuple{GNNGraph, AbstractFloat}"><code>GNNGraphs.remove_nodes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_nodes(g::GNNGraph, p)</code></pre><p>Returns a new graph obtained by dropping nodes from <code>g</code> with independent probabilities <code>p</code>. </p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; g = GNNGraph([1, 1, 2, 2, 3, 4], [1, 2, 3, 1, 3, 1])
GNNGraph:
  num_nodes: 4
  num_edges: 6

julia&gt; g_new = remove_nodes(g, 0.5)
GNNGraph:
  num_nodes: 2
  num_edges: 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/transform.jl#L331-L349">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.remove_nodes-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, AbstractVector}" href="#GNNGraphs.remove_nodes-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, AbstractVector}"><code>GNNGraphs.remove_nodes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_nodes(g::GNNGraph, nodes_to_remove::AbstractVector)</code></pre><p>Remove specified nodes, and their associated edges, from a GNNGraph. This operation reindexes the remaining nodes to maintain a continuous sequence of node indices, starting from 1. Similarly, edges are reindexed to account for the removal of edges connected to the removed nodes.</p><p><strong>Arguments</strong></p><ul><li><code>g</code>: The input graph from which nodes (and their edges) will be removed.</li><li><code>nodes_to_remove</code>: Vector of node indices to be removed.</li></ul><p><strong>Returns</strong></p><p>A new GNNGraph with the specified nodes and all edges associated with these nodes removed. </p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using GraphNeuralNetworks

g = GNNGraph([1, 1, 2, 2, 3], [2, 3, 1, 3, 1])

# Remove nodes with indices 2 and 3, for example
g_new = remove_nodes(g, [2, 3])

# g_new now does not contain nodes 2 and 3, and any edges that were connected to these nodes.
println(g_new)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/transform.jl#L264-L288">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.remove_self_loops-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}" href="#GNNGraphs.remove_self_loops-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}"><code>GNNGraphs.remove_self_loops</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_self_loops(g::GNNGraph)</code></pre><p>Return a graph constructed from <code>g</code> where self-loops (edges from a node to itself) are removed. </p><p>See also <a href="#GNNGraphs.add_self_loops-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}"><code>add_self_loops</code></a> and <a href="#GNNGraphs.remove_multi_edges-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}"><code>remove_multi_edges</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/transform.jl#L118-L125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.set_edge_weight-Tuple{GNNGraph, AbstractVector}" href="#GNNGraphs.set_edge_weight-Tuple{GNNGraph, AbstractVector}"><code>GNNGraphs.set_edge_weight</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_edge_weight(g::GNNGraph, w::AbstractVector)</code></pre><p>Set <code>w</code> as edge weights in the returned graph. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/transform.jl#L728-L732">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.to_bidirected-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}" href="#GNNGraphs.to_bidirected-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}"><code>GNNGraphs.to_bidirected</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">to_bidirected(g)</code></pre><p>Adds a reverse edge for each edge in the graph, then calls  <a href="#GNNGraphs.remove_multi_edges-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}"><code>remove_multi_edges</code></a> with <code>mean</code> aggregation to simplify the graph. </p><p>See also <a href="#GNNGraphs.is_bidirected-Tuple{GNNGraph}"><code>is_bidirected</code></a>. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; s, t = [1, 2, 3, 3, 4], [2, 3, 4, 4, 4];

julia&gt; w = [1.0, 2.0, 3.0, 4.0, 5.0];

julia&gt; e = [10.0, 20.0, 30.0, 40.0, 50.0];

julia&gt; g = GNNGraph(s, t, w, edata = e)
GNNGraph:
    num_nodes = 4
    num_edges = 5
    edata:
        e =&gt; (5,)

julia&gt; g2 = to_bidirected(g)
GNNGraph:
    num_nodes = 4
    num_edges = 7
    edata:
        e =&gt; (7,)

julia&gt; edge_index(g2)
([1, 2, 2, 3, 3, 4, 4], [2, 1, 3, 2, 4, 3, 4])

julia&gt; get_edge_weight(g2)
7-element Vector{Float64}:
 1.0
 1.0
 2.0
 2.0
 3.5
 3.5
 5.0

julia&gt; g2.edata.e
7-element Vector{Float64}:
 10.0
 10.0
 20.0
 20.0
 35.0
 35.0
 50.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/transform.jl#L605-L659">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.to_unidirected-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}" href="#GNNGraphs.to_unidirected-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}"><code>GNNGraphs.to_unidirected</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">to_unidirected(g::GNNGraph)</code></pre><p>Return a graph that for each multiple edge between two nodes in <code>g</code> keeps only an edge in one direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/transform.jl#L676-L681">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MLUtils.batch-Tuple{AbstractVector{&lt;:GNNGraph}}" href="#MLUtils.batch-Tuple{AbstractVector{&lt;:GNNGraph}}"><code>MLUtils.batch</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">batch(gs::Vector{&lt;:GNNGraph})</code></pre><p>Batch together multiple <code>GNNGraph</code>s into a single one  containing the total number of original nodes and edges.</p><p>Equivalent to <a href="#SparseArrays.blockdiag-Tuple{GNNGraph, Vararg{GNNGraph}}"><code>SparseArrays.blockdiag</code></a>. See also <a href="#MLUtils.unbatch-Union{Tuple{GNNGraph{T}}, Tuple{T}} where T&lt;:(Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}})"><code>MLUtils.unbatch</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g1 = rand_graph(4, 6, ndata=ones(8, 4))
GNNGraph:
    num_nodes = 4
    num_edges = 6
    ndata:
        x =&gt; (8, 4)

julia&gt; g2 = rand_graph(7, 4, ndata=zeros(8, 7))
GNNGraph:
    num_nodes = 7
    num_edges = 4
    ndata:
        x =&gt; (8, 7)

julia&gt; g12 = MLUtils.batch([g1, g2])
GNNGraph:
    num_nodes = 11
    num_edges = 10
    num_graphs = 2
    ndata:
        x =&gt; (8, 11)

julia&gt; g12.ndata.x
8×11 Matrix{Float64}:
 1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/transform.jl#L794-L839">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MLUtils.unbatch-Union{Tuple{GNNGraph{T}}, Tuple{T}} where T&lt;:(Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}})" href="#MLUtils.unbatch-Union{Tuple{GNNGraph{T}}, Tuple{T}} where T&lt;:(Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}})"><code>MLUtils.unbatch</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unbatch(g::GNNGraph)</code></pre><p>Opposite of the <a href="#MLUtils.batch-Tuple{AbstractVector{&lt;:GNNGraph}}"><code>MLUtils.batch</code></a> operation, returns  an array of the individual graphs batched together in <code>g</code>.</p><p>See also <a href="#MLUtils.batch-Tuple{AbstractVector{&lt;:GNNGraph}}"><code>MLUtils.batch</code></a> and <a href="#GNNGraphs.getgraph-Tuple{GNNGraph, Int64}"><code>getgraph</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; gbatched = MLUtils.batch([rand_graph(5, 6), rand_graph(10, 8), rand_graph(4,2)])
GNNGraph:
    num_nodes = 19
    num_edges = 16
    num_graphs = 3

julia&gt; MLUtils.unbatch(gbatched)
3-element Vector{GNNGraph{Tuple{Vector{Int64}, Vector{Int64}, Nothing}}}:
 GNNGraph:
    num_nodes = 5
    num_edges = 6

 GNNGraph:
    num_nodes = 10
    num_edges = 8

 GNNGraph:
    num_nodes = 4
    num_edges = 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/transform.jl#L952-L983">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseArrays.blockdiag-Tuple{GNNGraph, Vararg{GNNGraph}}" href="#SparseArrays.blockdiag-Tuple{GNNGraph, Vararg{GNNGraph}}"><code>SparseArrays.blockdiag</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">blockdiag(xs::GNNGraph...)</code></pre><p>Equivalent to <a href="#MLUtils.batch-Tuple{AbstractVector{&lt;:GNNGraph}}"><code>MLUtils.batch</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/transform.jl#L781-L785">source</a></section></article><h2 id="Utils"><a class="docs-heading-anchor" href="#Utils">Utils</a><a id="Utils-1"></a><a class="docs-heading-anchor-permalink" href="#Utils" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.sort_edge_index" href="#GNNGraphs.sort_edge_index"><code>GNNGraphs.sort_edge_index</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sort_edge_index(ei::Tuple) -&gt; u&#39;, v&#39;
sort_edge_index(u, v) -&gt; u&#39;, v&#39;</code></pre><p>Return a sorted version of the tuple of vectors <code>ei = (u, v)</code>, applying a common permutation to <code>u</code> and <code>v</code>. The sorting is lexycographic, that is the pairs <code>(ui, vi)</code>  are sorted first according to the <code>ui</code> and then according to <code>vi</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/utils.jl#L52-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.color_refinement" href="#GNNGraphs.color_refinement"><code>GNNGraphs.color_refinement</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">color_refinement(g::GNNGraph, [x0]) -&gt; x, num_colors, niters</code></pre><p>The color refinement algorithm for graph coloring.  Given a graph <code>g</code> and an initial coloring <code>x0</code>, the algorithm  iteratively refines the coloring until a fixed point is reached.</p><p>At each iteration the algorithm computes a hash of the coloring and the sorted list of colors of the neighbors of each node. This hash is used to determine if the coloring has changed.</p><p><code>math x_i&#39; = hashmap((x_i, sort([x_j for j \in N(i)]))).</code>`</p><p>This algorithm is related to the 1-Weisfeiler-Lehman algorithm for graph isomorphism testing.</p><p><strong>Arguments</strong></p><ul><li><code>g::GNNGraph</code>: The graph to color.</li><li><code>x0::AbstractVector{&lt;:Integer}</code>: The initial coloring. If not provided, all nodes are colored with 1.</li></ul><p><strong>Returns</strong></p><ul><li><code>x::AbstractVector{&lt;:Integer}</code>: The final coloring.</li><li><code>num_colors::Int</code>: The number of colors used.</li><li><code>niters::Int</code>: The number of iterations until convergence.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/utils.jl#L360-L384">source</a></section></article><h2 id="Generate"><a class="docs-heading-anchor" href="#Generate">Generate</a><a id="Generate-1"></a><a class="docs-heading-anchor-permalink" href="#Generate" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.knn_graph-Tuple{AbstractMatrix, Int64}" href="#GNNGraphs.knn_graph-Tuple{AbstractMatrix, Int64}"><code>GNNGraphs.knn_graph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">knn_graph(points::AbstractMatrix, 
          k::Int; 
          graph_indicator = nothing,
          self_loops = false, 
          dir = :in, 
          kws...)</code></pre><p>Create a <code>k</code>-nearest neighbor graph where each node is linked  to its <code>k</code> closest <code>points</code>.  </p><p><strong>Arguments</strong></p><ul><li><code>points</code>: A num<em>features × num</em>nodes matrix storing the Euclidean positions of the nodes.</li><li><code>k</code>: The number of neighbors considered in the kNN algorithm.</li><li><code>graph_indicator</code>: Either nothing or a vector containing the graph assignment of each node,                     in which case the returned graph will be a batch of graphs. </li><li><code>self_loops</code>: If <code>true</code>, consider the node itself among its <code>k</code> nearest neighbors, in which               case the graph will contain self-loops. </li><li><code>dir</code>: The direction of the edges. If <code>dir=:in</code> edges go from the <code>k</code>         neighbors to the central node. If <code>dir=:out</code> we have the opposite        direction.</li><li><code>kws</code>: Further keyword arguments will be passed to the <a href="#GNNGraph"><code>GNNGraph</code></a> constructor.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; n, k = 10, 3;

julia&gt; x = rand(Float32, 3, n);

julia&gt; g = knn_graph(x, k)
GNNGraph:
    num_nodes = 10
    num_edges = 30

julia&gt; graph_indicator = [1,1,1,1,1,2,2,2,2,2];

julia&gt; g = knn_graph(x, k; graph_indicator)
GNNGraph:
    num_nodes = 10
    num_edges = 30
    num_graphs = 2
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/generate.jl#L191-L236">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.radius_graph-Tuple{AbstractMatrix, AbstractFloat}" href="#GNNGraphs.radius_graph-Tuple{AbstractMatrix, AbstractFloat}"><code>GNNGraphs.radius_graph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">radius_graph(points::AbstractMatrix, 
             r::AbstractFloat; 
             graph_indicator = nothing,
             self_loops = false, 
             dir = :in, 
             kws...)</code></pre><p>Create a graph where each node is linked  to its neighbors within a given distance <code>r</code>.  </p><p><strong>Arguments</strong></p><ul><li><code>points</code>: A num<em>features × num</em>nodes matrix storing the Euclidean positions of the nodes.</li><li><code>r</code>: The radius.</li><li><code>graph_indicator</code>: Either nothing or a vector containing the graph assignment of each node,                     in which case the returned graph will be a batch of graphs. </li><li><code>self_loops</code>: If <code>true</code>, consider the node itself among its neighbors, in which               case the graph will contain self-loops. </li><li><code>dir</code>: The direction of the edges. If <code>dir=:in</code> edges go from the        neighbors to the central node. If <code>dir=:out</code> we have the opposite        direction.</li><li><code>kws</code>: Further keyword arguments will be passed to the <a href="#GNNGraph"><code>GNNGraph</code></a> constructor.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; n, r = 10, 0.75;

julia&gt; x = rand(Float32, 3, n);

julia&gt; g = radius_graph(x, r)
GNNGraph:
    num_nodes = 10
    num_edges = 46

julia&gt; graph_indicator = [1,1,1,1,1,2,2,2,2,2];

julia&gt; g = radius_graph(x, r; graph_indicator)
GNNGraph:
    num_nodes = 10
    num_edges = 20
    num_graphs = 2
</code></pre><p><strong>References</strong></p><p>Section B paragraphs 1 and 2 of the paper <a href="https://arxiv.org/pdf/2101.00414.pdf">Dynamic Hidden-Variable Network Models</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/generate.jl#L272-L319">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.rand_bipartite_heterograph-Tuple{Any, Any}" href="#GNNGraphs.rand_bipartite_heterograph-Tuple{Any, Any}"><code>GNNGraphs.rand_bipartite_heterograph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rand_bipartite_heterograph([rng,] 
                           (n1, n2), (m12, m21); 
                           bidirected = true, 
                           node_t = (:A, :B), 
                           edge_t = :to, 
                           kws...)</code></pre><p>Construct an <a href="../heterograph/#GNNHeteroGraph"><code>GNNHeteroGraph</code></a> with random edges representing a bipartite graph. The graph will have two types of nodes, and edges will only connect nodes of different types.</p><p>The first argument is a tuple <code>(n1, n2)</code> specifying the number of nodes of each type. The second argument is a tuple <code>(m12, m21)</code> specifying the number of edges connecting nodes of type <code>1</code> to nodes of type <code>2</code>  and vice versa.</p><p>The type of nodes and edges can be specified with the <code>node_t</code> and <code>edge_t</code> keyword arguments, which default to <code>(:A, :B)</code> and <code>:to</code> respectively.</p><p>If <code>bidirected=true</code> (default), the reverse edge of each edge will be present. In this case <code>m12 == m21</code> is required.</p><p>A random number generator can be passed as the first argument to make the generation reproducible.</p><p>Additional keyword arguments will be passed to the <a href="../heterograph/#GNNHeteroGraph"><code>GNNHeteroGraph</code></a> constructor.</p><p>See <a href="#GNNGraphs.rand_heterograph"><code>rand_heterograph</code></a> for a more general version.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g = rand_bipartite_heterograph((10, 15), 20)
GNNHeteroGraph:
  num_nodes: (:A =&gt; 10, :B =&gt; 15)
  num_edges: ((:A, :to, :B) =&gt; 20, (:B, :to, :A) =&gt; 20)

julia&gt; g = rand_bipartite_heterograph((10, 15), (20, 0), node_t=(:user, :item), edge_t=:-, bidirected=false)
GNNHeteroGraph:
  num_nodes: Dict(:item =&gt; 15, :user =&gt; 10)
  num_edges: Dict((:item, :-, :user) =&gt; 0, (:user, :-, :item) =&gt; 20)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/generate.jl#L135-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.rand_graph-Tuple{Integer, Integer}" href="#GNNGraphs.rand_graph-Tuple{Integer, Integer}"><code>GNNGraphs.rand_graph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rand_graph([rng,] n, m; bidirected=true, edge_weight = nothing, kws...)</code></pre><p>Generate a random (Erdós-Renyi) <code>GNNGraph</code> with <code>n</code> nodes and <code>m</code> edges.</p><p>If <code>bidirected=true</code> the reverse edge of each edge will be present. If <code>bidirected=false</code> instead, <code>m</code> unrelated edges are generated. In any case, the output graph will contain no self-loops or multi-edges.</p><p>A vector can be passed  as <code>edge_weight</code>. Its length has to be equal to <code>m</code> in the directed case, and <code>m÷2</code> in the bidirected one.</p><p>Pass a random number generator as the first argument to make the generation reproducible.</p><p>Additional keyword arguments will be passed to the <a href="#GNNGraph"><code>GNNGraph</code></a> constructor.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g = rand_graph(5, 4, bidirected=false)
GNNGraph:
    num_nodes = 5
    num_edges = 4

julia&gt; edge_index(g)
([1, 3, 3, 4], [5, 4, 5, 2])

# In the bidirected case, edge data will be duplicated on the reverse edges if needed.
julia&gt; g = rand_graph(5, 4, edata=rand(Float32, 16, 2))
GNNGraph:
    num_nodes = 5
    num_edges = 4
    edata:
        e =&gt; (16, 4)

# Each edge has a reverse
julia&gt; edge_index(g)
([1, 3, 3, 4], [3, 4, 1, 3])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/generate.jl#L1-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.rand_heterograph" href="#GNNGraphs.rand_heterograph"><code>GNNGraphs.rand_heterograph</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rand_heterograph([rng,] n, m; bidirected=false, kws...)</code></pre><p>Construct an <a href="../heterograph/#GNNHeteroGraph"><code>GNNHeteroGraph</code></a> with random edges and with number of nodes and edges  specified by <code>n</code> and <code>m</code> respectively. <code>n</code> and <code>m</code> can be any iterable of pairs specifing node/edge types and their numbers.</p><p>Pass a random number generator as a first argument to make the generation reproducible.</p><p>Setting <code>bidirected=true</code> will generate a bidirected graph, i.e. each edge will have a reverse edge. Therefore, for each edge type <code>(:A, :rel, :B)</code> a corresponding reverse edge type <code>(:B, :rel, :A)</code> will be generated.</p><p>Additional keyword arguments will be passed to the <a href="../heterograph/#GNNHeteroGraph"><code>GNNHeteroGraph</code></a> constructor.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g = rand_heterograph((:user =&gt; 10, :movie =&gt; 20),
                            (:user, :rate, :movie) =&gt; 30)
GNNHeteroGraph:
  num_nodes: (:user =&gt; 10, :movie =&gt; 20)         
  num_edges: ((:user, :rate, :movie) =&gt; 30,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/generate.jl#L67-L91">source</a></section></article><h2 id="Operators"><a class="docs-heading-anchor" href="#Operators">Operators</a><a id="Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Operators" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.intersect" href="#Base.intersect"><code>Base.intersect</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>&quot;     intersect(g1::GNNGraph, g2::GNNGraph)</p><p>Intersect two graphs by keeping only the common edges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/operators.jl#L2-L7">source</a></section></article><h2 id="Sampling"><a class="docs-heading-anchor" href="#Sampling">Sampling</a><a id="Sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GNNGraphs.sample_neighbors" href="#GNNGraphs.sample_neighbors"><code>GNNGraphs.sample_neighbors</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sample_neighbors(g, nodes, K=-1; dir=:in, replace=false, dropnodes=false)</code></pre><p>Sample neighboring edges of the given nodes and return the induced subgraph. For each node, a number of inbound (or outbound when <code>dir = :out</code><code>) edges will be randomly chosen.  If</code>dropnodes=false`, the graph returned will then contain all the nodes in the original graph,  but only the sampled edges.</p><p>The returned graph will contain an edge feature <code>EID</code> corresponding to the id of the edge in the original graph. If <code>dropnodes=true</code>, it will also contain a node feature <code>NID</code> with the node ids in the original graph.</p><p><strong>Arguments</strong></p><ul><li><code>g</code>. The graph.</li><li><code>nodes</code>. A list of node IDs to sample neighbors from.</li><li><code>K</code>. The maximum number of edges to be sampled for each node.      If -1, all the neighboring edges will be selected.</li><li><code>dir</code>. Determines whether to sample inbound (<code>:in</code>) or outbound (`<code>:out</code>) edges (Default <code>:in</code>).</li><li><code>replace</code>. If <code>true</code>, sample with replacement.</li><li><code>dropnodes</code>. If <code>true</code>, the resulting subgraph will contain only the nodes involved in the sampled edges.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; g = rand_graph(20, 100)
GNNGraph:
    num_nodes = 20
    num_edges = 100

julia&gt; sample_neighbors(g, 2:3)
GNNGraph:
    num_nodes = 20
    num_edges = 9
    edata:
        EID =&gt; (9,)

julia&gt; sg = sample_neighbors(g, 2:3, dropnodes=true)
GNNGraph:
    num_nodes = 10
    num_edges = 9
    ndata:
        NID =&gt; (10,)
    edata:
        EID =&gt; (9,)

julia&gt; sg.ndata.NID
10-element Vector{Int64}:
  2
  3
 17
 14
 18
 15
 16
 20
  7
 10

julia&gt; sample_neighbors(g, 2:3, 5, replace=true)
GNNGraph:
    num_nodes = 20
    num_edges = 10
    edata:
        EID =&gt; (10,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/sampling.jl#L1-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.induced_subgraph-Tuple{GNNGraph, Vector{Int64}}" href="#Graphs.induced_subgraph-Tuple{GNNGraph, Vector{Int64}}"><code>Graphs.induced_subgraph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">induced_subgraph(graph, nodes)</code></pre><p>Generates a subgraph from the original graph using the provided <code>nodes</code>.  The function includes the nodes&#39; neighbors and creates edges between nodes that are connected in the original graph.  If a node has no neighbors, an isolated node will be added to the subgraph.  Returns A new <code>GNNGraph</code> containing the subgraph with the specified nodes and their features.</p><p><strong>Arguments</strong></p><ul><li><code>graph</code>. The original GNNGraph containing nodes, edges, and node features.</li><li><code>nodes</code>`. A vector of node indices to include in the subgraph.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; s = [1, 2]
2-element Vector{Int64}:
 1
 2

julia&gt; t = [2, 3]
2-element Vector{Int64}:
 2
 3

julia&gt; graph = GNNGraph((s, t), ndata = (; x=rand(Float32, 32, 3), y=rand(Float32, 3)), edata = rand(Float32, 2))
GNNGraph:
  num_nodes: 3
  num_edges: 2
  ndata:
        y = 3-element Vector{Float32}
        x = 32×3 Matrix{Float32}
  edata:
        e = 2-element Vector{Float32}

julia&gt; nodes = [1, 2]
2-element Vector{Int64}:
 1
 2

julia&gt; subgraph = Graphs.induced_subgraph(graph, nodes)
GNNGraph:
  num_nodes: 2
  num_edges: 1
  ndata:
        y = 2-element Vector{Float32}
        x = 32×2 Matrix{Float32}
  edata:
        e = 1-element Vector{Float32}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/38122fe5f6e5cce460358f0c309f640eda3cc589/GNNGraphs/src/sampling.jl#L121-L172">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../tutorials/">« Tutorials</a><a class="docs-footer-nextpage" href="../basic/">Basic Layers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Sunday 3 November 2024 10:37">Sunday 3 November 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
