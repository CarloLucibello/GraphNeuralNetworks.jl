var documenterSearchIndex = {"docs":
[{"location":"api/gnngraph/","page":"GNNGraph","title":"GNNGraph","text":"CurrentModule = GraphNeuralNetworks","category":"page"},{"location":"api/gnngraph/#GNNGraph","page":"GNNGraph","title":"GNNGraph","text":"","category":"section"},{"location":"api/gnngraph/","page":"GNNGraph","title":"GNNGraph","text":"Documentation page for the graph type GNNGraph provided by GraphNeuralNetworks.jl and related methods. ","category":"page"},{"location":"api/gnngraph/","page":"GNNGraph","title":"GNNGraph","text":"Besides the methods documented here, one can rely on the large set of functionalities given by Graphs.jl thanks to the fact that GNNGraph inherits from Graphs.AbstractGraph.","category":"page"},{"location":"api/gnngraph/#Index","page":"GNNGraph","title":"Index","text":"","category":"section"},{"location":"api/gnngraph/","page":"GNNGraph","title":"GNNGraph","text":"Order = [:type, :function]\nPages   = [\"gnngraph.md\"]","category":"page"},{"location":"api/gnngraph/#GNNGraph-type","page":"GNNGraph","title":"GNNGraph type","text":"","category":"section"},{"location":"api/gnngraph/","page":"GNNGraph","title":"GNNGraph","text":"Modules = [GraphNeuralNetworks.GNNGraphs]\nPages   = [\"gnngraph.jl\"]\nPrivate = false","category":"page"},{"location":"api/gnngraph/#GraphNeuralNetworks.GNNGraphs.GNNGraph","page":"GNNGraph","title":"GraphNeuralNetworks.GNNGraphs.GNNGraph","text":"GNNGraph(data; [graph_type, ndata, edata, gdata, num_nodes, graph_indicator, dir])\nGNNGraph(g::GNNGraph; [ndata, edata, gdata])\n\nA type representing a graph structure that also stores  feature arrays associated to nodes, edges, and the graph itself. \n\nA GNNGraph can be constructed out of different data objects  expressing the connections inside the graph. The internal representation type is determined by graph_type.\n\nWhen constructed from another GNNGraph, the internal graph representation is preserved and shared. The node/edge/graph features are retained as well, unless explicitely set by the keyword arguments ndata, edata, and gdata.\n\nA GNNGraph can also represent multiple graphs batched togheter  (see Flux.batch or SparseArrays.blockdiag). The field g.graph_indicator contains the graph membership of each node.\n\nGNNGraphs are always directed graphs, therefore each edge is defined by a source node and a target node (see edge_index). Self loops (edges connecting a node to itself) and multiple edges (more than one edge between the same pair of nodes) are supported.\n\nA GNNGraph is a Graphs.jl's AbstractGraph, therefore it supports most  functionality from that library.\n\nArguments\n\ndata: Some data representing the graph topology. Possible type are \nAn adjacency matrix\nAn adjacency list.\nA tuple containing the source and target vectors (COO representation)\nA Graphs.jl' graph.\ngraph_type: A keyword argument that specifies                the underlying representation used by the GNNGraph.                Currently supported values are \n:coo. Graph represented as a tuple (source, target), such that the k-th edge          connects the node source[k] to node target[k].         Optionally, also edge weights can be given: (source, target, weights).\n:sparse. A sparse adjacency matrix representation.\n:dense. A dense adjacency matrix representation.  \nDefaults to :coo, currently the most supported type.\ndir: The assumed edge direction when given adjacency matrix or adjacency list input data g.        Possible values are :out and :in. Default :out.\nnum_nodes: The number of nodes. If not specified, inferred from g. Default nothing.\ngraph_indicator: For batched graphs, a vector containing the graph assigment of each node. Default nothing.  \nndata: Node features. An array or named tuple of arrays whose last dimension has size num_nodes.\nedata: Edge features. An array or named tuple of arrays whose last dimension has size num_edges.\ngdata: Graph features. An array or named tuple of arrays whose last dimension has size num_graphs. \n\nExamples\n\nusing Flux, GraphNeuralNetworks\n\n# Construct from adjacency list representation\ndata = [[2,3], [1,4,5], [1], [2,5], [2,4]]\ng = GNNGraph(data)\n\n# Number of nodes, edges, and batched graphs\ng.num_nodes  # 5\ng.num_edges  # 10 \ng.num_graphs # 1 \n\n# Same graph in COO representation\ns = [1,1,2,2,2,3,4,4,5,5]\nt = [2,3,1,4,5,3,2,5,2,4]\ng = GNNGraph(s, t)\n\n# From a Graphs' graph\ng = GNNGraph(erdos_renyi(100, 20))\n\n# Add 2 node feature arrays\ng = GNNGraph(g, ndata = (x=rand(100, g.num_nodes), y=rand(g.num_nodes)))\n\n# Add node features and edge features with default names `x` and `e` \ng = GNNGraph(g, ndata = rand(100, g.num_nodes), edata = rand(16, g.num_edges))\n\ng.ndata.x\ng.ndata.e\n\n# Send to gpu\ng = g |> gpu\n\n# Collect edges' source and target nodes.\n# Both source and target are vectors of length num_edges\nsource, target = edge_index(g)\n\n\n\n\n\n","category":"type"},{"location":"api/gnngraph/#Query","page":"GNNGraph","title":"Query","text":"","category":"section"},{"location":"api/gnngraph/","page":"GNNGraph","title":"GNNGraph","text":"Modules = [GraphNeuralNetworks.GNNGraphs]\nPages   = [\"query.jl\"]\nPrivate = false","category":"page"},{"location":"api/gnngraph/#GraphNeuralNetworks.GNNGraphs.adjacency_list-Tuple{GNNGraph, Any}","page":"GNNGraph","title":"GraphNeuralNetworks.GNNGraphs.adjacency_list","text":"adjacency_list(g; dir=:out)\nadjacency_list(g, nodes; dir=:out)\n\nReturn the adjacency list representation (a vector of vectors) of the graph g.\n\nCalling a the adjacency list, if dir=:out than a[i] will contain the neighbors of node i through outgoing edges. If dir=:in, it will contain neighbors from incoming edges instead.\n\nIf nodes is given, return the neighborhood of the nodes in nodes only.\n\n\n\n\n\n","category":"method"},{"location":"api/gnngraph/#GraphNeuralNetworks.GNNGraphs.edge_index-Tuple{GNNGraph{<:Tuple{T, T, V} where {T<:(AbstractVector{<:Integer}), V}}}","page":"GNNGraph","title":"GraphNeuralNetworks.GNNGraphs.edge_index","text":"edge_index(g::GNNGraph)\n\nReturn a tuple containing two vectors, respectively storing  the source and target nodes for each edges in g.\n\ns, t = edge_index(g)\n\n\n\n\n\n","category":"method"},{"location":"api/gnngraph/#GraphNeuralNetworks.GNNGraphs.graph_indicator-Tuple{Any}","page":"GNNGraph","title":"GraphNeuralNetworks.GNNGraphs.graph_indicator","text":"graph_indicator(g)\n\nReturn a vector containing the graph membership (an integer from 1 to g.num_graphs) of each node in the graph.\n\n\n\n\n\n","category":"method"},{"location":"api/gnngraph/#GraphNeuralNetworks.GNNGraphs.has_isolated_nodes-Tuple{GNNGraph}","page":"GNNGraph","title":"GraphNeuralNetworks.GNNGraphs.has_isolated_nodes","text":"has_isolated_nodes(g::GNNGraph; dir=:out)\n\nReturn true if the graph g contains nodes with out-degree (if dir=:out) or in-degree (if dir=:in) equal to zero.\n\n\n\n\n\n","category":"method"},{"location":"api/gnngraph/#GraphNeuralNetworks.GNNGraphs.has_multi_edges-Tuple{GNNGraph}","page":"GNNGraph","title":"GraphNeuralNetworks.GNNGraphs.has_multi_edges","text":"has_multi_edges(g::GNNGraph)\n\nReturn true if g has any multiple edges.\n\n\n\n\n\n","category":"method"},{"location":"api/gnngraph/#GraphNeuralNetworks.GNNGraphs.is_bidirected-Tuple{GNNGraph}","page":"GNNGraph","title":"GraphNeuralNetworks.GNNGraphs.is_bidirected","text":"is_bidirected(g::GNNGraph)\n\nCheck if the directed graph g essentially corresponds to an undirected graph, i.e. if for each edge it also contains the  reverse edge. \n\n\n\n\n\n","category":"method"},{"location":"api/gnngraph/#GraphNeuralNetworks.GNNGraphs.normalized_laplacian","page":"GNNGraph","title":"GraphNeuralNetworks.GNNGraphs.normalized_laplacian","text":"normalized_laplacian(g, T=Float32; add_self_loops=false, dir=:out)\n\nNormalized Laplacian matrix of graph g.\n\nArguments\n\ng: A GNNGraph.\nT: result element type.\nadd_self_loops: add self-loops while calculating the matrix.\ndir: the edge directionality considered (:out, :in, :both).\n\n\n\n\n\n","category":"function"},{"location":"api/gnngraph/#GraphNeuralNetworks.GNNGraphs.scaled_laplacian","page":"GNNGraph","title":"GraphNeuralNetworks.GNNGraphs.scaled_laplacian","text":"scaled_laplacian(g, T=Float32; dir=:out)\n\nScaled Laplacian matrix of graph g, defined as hatL = frac2lambda_max L - I where L is the normalized Laplacian matrix.\n\nArguments\n\ng: A GNNGraph.\nT: result element type.\ndir: the edge directionality considered (:out, :in, :both).\n\n\n\n\n\n","category":"function"},{"location":"api/gnngraph/#Graphs.LinAlg.adjacency_matrix","page":"GNNGraph","title":"Graphs.LinAlg.adjacency_matrix","text":"adjacency_matrix(g::GNNGraph, T=eltype(g); dir=:out, weighted=true)\n\nReturn the adjacency matrix A for the graph g. \n\nIf dir=:out, A[i,j] > 0 denotes the presence of an edge from node i to node j. If dir=:in instead, A[i,j] > 0 denotes the presence of an edge from node j to node i.\n\nUser may specify the eltype T of the returned matrix. \n\nIf weighted=true, the A will contain the edge weigths if any, otherwise the elements of A will be either 0 or 1.\n\n\n\n\n\n","category":"function"},{"location":"api/gnngraph/#Graphs.degree-Union{Tuple{GNNGraph{<:Tuple{T, T, V} where {T<:(AbstractVector{<:Integer}), V}}}, Tuple{TT}, Tuple{GNNGraph{<:Tuple{T, T, V} where {T<:(AbstractVector{<:Integer}), V}}, TT}} where TT<:Union{Nothing, Type{<:Number}}","page":"GNNGraph","title":"Graphs.degree","text":"degree(g::GNNGraph, T=nothing; dir=:out, edge_weight=true)\n\nReturn a vector containing the degrees of the nodes in g.\n\nArguments\n\ng: A graph.\nT: Element type of the returned vector. If nothing, is      chosen based on the graph type and will be an integer      if edge_weight=false.\ndir: For dir=:out the degree of a node is counted based on the outgoing edges.        For dir=:in, the ingoing edges are used. If dir=:both we have the sum of the two.\nedge_weight: If true and the graph contains weighted edges, the degree will                be weighted. Set to false instead to just count the number of               outgoing/ingoing edges.               In alternative, you can also pass a vector of weights to be used               instead of the graph's own weights.\n\n\n\n\n\n","category":"method"},{"location":"api/gnngraph/#Graphs.has_self_loops-Tuple{GNNGraph}","page":"GNNGraph","title":"Graphs.has_self_loops","text":"has_self_loops(g::GNNGraph)\n\nReturn true if g has any self loops.\n\n\n\n\n\n","category":"method"},{"location":"api/gnngraph/","page":"GNNGraph","title":"GNNGraph","text":"Graphs.outneighbors\nGraphs.inneighbors","category":"page"},{"location":"api/gnngraph/#Graphs.outneighbors","page":"GNNGraph","title":"Graphs.outneighbors","text":"outneighbors(g, v)\n\nReturn a list of all neighbors connected to vertex v by an outgoing edge.\n\nImplementation Notes\n\nReturns a reference to the current graph's internal structures, not a copy. Do not modify result. If the graph is modified, the behavior is undefined: the array behind this reference may be modified too, but this is not guaranteed.\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> outneighbors(g, 4)\n1-element Array{Int64,1}:\n 5\n\n\n\n\n\n","category":"function"},{"location":"api/gnngraph/#Graphs.inneighbors","page":"GNNGraph","title":"Graphs.inneighbors","text":"inneighbors(g, v)\n\nReturn a list of all neighbors connected to vertex v by an incoming edge.\n\nImplementation Notes\n\nReturns a reference to the current graph's internal structures, not a copy. Do not modify result. If the graph is modified, the behavior is undefined: the array behind this reference may be modified too, but this is not guaranteed.\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> inneighbors(g, 4)\n2-element Array{Int64,1}:\n 3\n 5\n\n\n\n\n\n","category":"function"},{"location":"api/gnngraph/#Transform","page":"GNNGraph","title":"Transform","text":"","category":"section"},{"location":"api/gnngraph/","page":"GNNGraph","title":"GNNGraph","text":"Modules = [GraphNeuralNetworks.GNNGraphs]\nPages   = [\"transform.jl\"]\nPrivate = false","category":"page"},{"location":"api/gnngraph/#GraphNeuralNetworks.GNNGraphs.add_edges-Tuple{GNNGraph{<:Tuple{T, T, V} where {T<:(AbstractVector{<:Integer}), V}}, AbstractVector{<:Integer}, AbstractVector{<:Integer}}","page":"GNNGraph","title":"GraphNeuralNetworks.GNNGraphs.add_edges","text":"add_edges(g::GNNGraph, s::AbstractVector, t::AbstractVector; [edata])\n\nAdd to graph g the edges with source nodes s and target nodes t. Optionally, pass the features  edata for the new edges. \n\n\n\n\n\n","category":"method"},{"location":"api/gnngraph/#GraphNeuralNetworks.GNNGraphs.add_nodes-Tuple{GNNGraph{<:Tuple{T, T, V} where {T<:(AbstractVector{<:Integer}), V}}, Integer}","page":"GNNGraph","title":"GraphNeuralNetworks.GNNGraphs.add_nodes","text":"add_nodes(g::GNNGraph, n; [ndata])\n\nAdd n new nodes to graph g. In the  new graph, these nodes will have indexes from g.num_nodes + 1 to g.num_nodes + n.\n\n\n\n\n\n","category":"method"},{"location":"api/gnngraph/#GraphNeuralNetworks.GNNGraphs.add_self_loops-Tuple{GNNGraph{<:Tuple{T, T, V} where {T<:(AbstractVector{<:Integer}), V}}}","page":"GNNGraph","title":"GraphNeuralNetworks.GNNGraphs.add_self_loops","text":"add_self_loops(g::GNNGraph)\n\nReturn a graph with the same features as g but also adding edges connecting the nodes to themselves.\n\nNodes with already existing self-loops will obtain a second self-loop.\n\nIf the graphs has edge weights, the new edges will have weight 1.\n\n\n\n\n\n","category":"method"},{"location":"api/gnngraph/#GraphNeuralNetworks.GNNGraphs.getgraph-Tuple{GNNGraph, Int64}","page":"GNNGraph","title":"GraphNeuralNetworks.GNNGraphs.getgraph","text":"getgraph(g::GNNGraph, i; nmap=false)\n\nReturn the subgraph of g induced by those nodes j for which g.graph_indicator[j] == i or, if i is a collection, g.graph_indicator[j] ∈ i.  In other words, it extract the component graphs from a batched graph. \n\nIf nmap=true, return also a vector v mapping the new nodes to the old ones.  The node i in the subgraph will correspond to the node v[i] in g.\n\n\n\n\n\n","category":"method"},{"location":"api/gnngraph/#GraphNeuralNetworks.GNNGraphs.negative_sample-Tuple{GNNGraph}","page":"GNNGraph","title":"GraphNeuralNetworks.GNNGraphs.negative_sample","text":"negative_sample(g::GNNGraph; \n                num_neg_edges = g.num_edges, \n                bidirected = is_bidirected(g))\n\nReturn a graph containing random negative edges (i.e. non-edges) from graph g as edges.\n\nIf bidirected=true, the output graph will be bidirected and there will be no leakage from the origin graph. \n\nSee also is_bidirected.\n\n\n\n\n\n","category":"method"},{"location":"api/gnngraph/#GraphNeuralNetworks.GNNGraphs.rand_edge_split-Tuple{GNNGraph, Any}","page":"GNNGraph","title":"GraphNeuralNetworks.GNNGraphs.rand_edge_split","text":"rand_edge_split(g::GNNGraph, frac; bidirected=is_bidirected(g)) -> g1, g2\n\nRandomly partition the edges in g to form two graphs, g1 and g2. Both will have the same number of nodes as g. g1 will contain a fraction frac of the original edges,  while g2 wil contain the rest.\n\nIf bidirected = true makes sure that an edge and its reverse go into the same split. This option is supported only for bidirected graphs with no self-loops and multi-edges.\n\nrand_edge_split is tipically used to create train/test splits in link prediction tasks.\n\n\n\n\n\n","category":"method"},{"location":"api/gnngraph/#GraphNeuralNetworks.GNNGraphs.remove_multi_edges-Tuple{GNNGraph{<:Tuple{T, T, V} where {T<:(AbstractVector{<:Integer}), V}}}","page":"GNNGraph","title":"GraphNeuralNetworks.GNNGraphs.remove_multi_edges","text":"remove_multi_edges(g::GNNGraph; aggr=+)\n\nRemove multiple edges (also called parallel edges or repeated edges) from graph g. Possible edge features are aggregated according to aggr, that can take value  +,min, max or mean.\n\nSee also remove_self_loops, has_multi_edges, and to_bidirected.\n\n\n\n\n\n","category":"method"},{"location":"api/gnngraph/#GraphNeuralNetworks.GNNGraphs.remove_self_loops-Tuple{GNNGraph{<:Tuple{T, T, V} where {T<:(AbstractVector{<:Integer}), V}}}","page":"GNNGraph","title":"GraphNeuralNetworks.GNNGraphs.remove_self_loops","text":"remove_self_loops(g::GNNGraph)\n\nReturn a graph constructed from g where self-loops (edges from a node to itself) are removed. \n\nSee also add_self_loops and remove_multi_edges.\n\n\n\n\n\n","category":"method"},{"location":"api/gnngraph/#GraphNeuralNetworks.GNNGraphs.set_edge_weight-Tuple{GNNGraph, AbstractVector}","page":"GNNGraph","title":"GraphNeuralNetworks.GNNGraphs.set_edge_weight","text":"set_edge_weight(g::GNNGraph, w::AbstractVector)\n\nSet w as edge weights in the returned graph. \n\n\n\n\n\n","category":"method"},{"location":"api/gnngraph/#GraphNeuralNetworks.GNNGraphs.to_bidirected-Tuple{GNNGraph{<:Tuple{T, T, V} where {T<:(AbstractVector{<:Integer}), V}}}","page":"GNNGraph","title":"GraphNeuralNetworks.GNNGraphs.to_bidirected","text":"to_bidirected(g)\n\nAdds a reverse edge for each edge in the graph, then calls  remove_multi_edges with mean aggregation to simplify the graph. \n\nSee also is_bidirected. \n\nExamples\n\njulia> s, t = [1, 2, 3, 3, 4], [2, 3, 4, 4, 4];\n\njulia> w = [1.0, 2.0, 3.0, 4.0, 5.0];\n\njulia> e = [10.0, 20.0, 30.0, 40.0, 50.0];\n\njulia> g = GNNGraph(s, t, w, edata = e)\nGNNGraph:\n    num_nodes = 4\n    num_edges = 5\n    edata:\n        e => (5,)\n\njulia> g2 = to_bidirected(g)\nGNNGraph:\n    num_nodes = 4\n    num_edges = 7\n    edata:\n        e => (7,)\n\njulia> edge_index(g2)\n([1, 2, 2, 3, 3, 4, 4], [2, 1, 3, 2, 4, 3, 4])\n\njulia> get_edge_weight(g2)\n7-element Vector{Float64}:\n 1.0\n 1.0\n 2.0\n 2.0\n 3.5\n 3.5\n 5.0\n\njulia> g2.edata.e\n7-element Vector{Float64}:\n 10.0\n 10.0\n 20.0\n 20.0\n 35.0\n 35.0\n 50.0\n\n\n\n\n\n","category":"method"},{"location":"api/gnngraph/#GraphNeuralNetworks.GNNGraphs.to_unidirected-Tuple{GNNGraph{<:Tuple{T, T, V} where {T<:(AbstractVector{<:Integer}), V}}}","page":"GNNGraph","title":"GraphNeuralNetworks.GNNGraphs.to_unidirected","text":"to_unidirected(g::GNNGraph)\n\nReturn a graph that for each multiple edge between two nodes in g keeps only an edge in one direction.\n\n\n\n\n\n","category":"method"},{"location":"api/gnngraph/#MLUtils.batch-Tuple{AbstractVector{<:GNNGraph}}","page":"GNNGraph","title":"MLUtils.batch","text":"batch(gs::Vector{<:GNNGraph})\n\nBatch together multiple GNNGraphs into a single one  containing the total number of original nodes and edges.\n\nEquivalent to SparseArrays.blockdiag. See also Flux.unbatch.\n\nExamples\n\njulia> g1 = rand_graph(4, 6, ndata=ones(8, 4))\nGNNGraph:\n    num_nodes = 4\n    num_edges = 6\n    ndata:\n        x => (8, 4)\n\njulia> g2 = rand_graph(7, 4, ndata=zeros(8, 7))\nGNNGraph:\n    num_nodes = 7\n    num_edges = 4\n    ndata:\n        x => (8, 7)\n\njulia> g12 = Flux.batch([g1, g2])\nGNNGraph:\n    num_nodes = 11\n    num_edges = 10\n    num_graphs = 2\n    ndata:\n        x => (8, 11)\n\njulia> g12.ndata.x\n8×11 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n\n\n\n\n\n","category":"method"},{"location":"api/gnngraph/#MLUtils.unbatch-Tuple{GNNGraph}","page":"GNNGraph","title":"MLUtils.unbatch","text":"unbatch(g::GNNGraph)\n\nOpposite of the Flux.batch operation, returns  an array of the individual graphs batched together in g.\n\nSee also Flux.batch and getgraph.\n\nExamples\n\njulia> gbatched = Flux.batch([rand_graph(5, 6), rand_graph(10, 8), rand_graph(4,2)])\nGNNGraph:\n    num_nodes = 19\n    num_edges = 16\n    num_graphs = 3\n\njulia> Flux.unbatch(gbatched)\n3-element Vector{GNNGraph{Tuple{Vector{Int64}, Vector{Int64}, Nothing}}}:\n GNNGraph:\n    num_nodes = 5\n    num_edges = 6\n\n GNNGraph:\n    num_nodes = 10\n    num_edges = 8\n\n GNNGraph:\n    num_nodes = 4\n    num_edges = 2\n\n\n\n\n\n","category":"method"},{"location":"api/gnngraph/#SparseArrays.blockdiag-Tuple{GNNGraph, Vararg{GNNGraph}}","page":"GNNGraph","title":"SparseArrays.blockdiag","text":"blockdiag(xs::GNNGraph...)\n\nEquivalent to Flux.batch.\n\n\n\n\n\n","category":"method"},{"location":"api/gnngraph/#Generate","page":"GNNGraph","title":"Generate","text":"","category":"section"},{"location":"api/gnngraph/","page":"GNNGraph","title":"GNNGraph","text":"Modules = [GraphNeuralNetworks.GNNGraphs]\nPages   = [\"generate.jl\"]\nPrivate = false","category":"page"},{"location":"api/gnngraph/#GraphNeuralNetworks.GNNGraphs.knn_graph-Tuple{AbstractMatrix, Int64}","page":"GNNGraph","title":"GraphNeuralNetworks.GNNGraphs.knn_graph","text":"knn_graph(points::AbstractMatrix, \n          k::Int; \n          graph_indicator = nothing,\n          self_loops = false, \n          dir = :in, \n          kws...)\n\nCreate a k-nearest neighbor graph where each node is linked  to its k closest points.  \n\nArguments\n\npoints: A numfeatures × numnodes matrix storing the Euclidean positions of the nodes.\nk: The number of neighbors considered in the kNN algorithm.\ngraph_indicator: Either nothing or a vector containing the graph assigment of each node,                     in which case the returned graph will be a batch of graphs. \nself_loops: If true, consider the node itself among its k nearest neighbors, in which               case the graph will contain self-loops. \ndir: The direction of the edges. If dir=:in edges go from the k         neighbors to the central node. If dir=:out we have the opposite        direction.\nkws: Further keyword arguments will be passed to the GNNGraph constructor.\n\nExamples\n\njulia> n, k = 10, 3;\n\njulia> x = rand(3, n);\n\njulia> g = knn_graph(x, k)\nGNNGraph:\n    num_nodes = 10\n    num_edges = 30\n\njulia> graph_indicator = [1,1,1,1,1,2,2,2,2,2];\n\njulia> g = knn_graph(x, k; graph_indicator)\nGNNGraph:\n    num_nodes = 10\n    num_edges = 30\n    num_graphs = 2\n\n\n\n\n\n\n","category":"method"},{"location":"api/gnngraph/#GraphNeuralNetworks.GNNGraphs.radius_graph-Tuple{AbstractMatrix, AbstractFloat}","page":"GNNGraph","title":"GraphNeuralNetworks.GNNGraphs.radius_graph","text":"radius_graph(points::AbstractMatrix, \n             r::AbstractFloat; \n             graph_indicator = nothing,\n             self_loops = false, \n             dir = :in, \n             kws...)\n\nCreate a graph where each node is linked  to its neighbors within a given distance r.  \n\nArguments\n\npoints: A numfeatures × numnodes matrix storing the Euclidean positions of the nodes.\nr: The radius.\ngraph_indicator: Either nothing or a vector containing the graph assigment of each node,                     in which case the returned graph will be a batch of graphs. \nself_loops: If true, consider the node itself among its neighbors, in which               case the graph will contain self-loops. \ndir: The direction of the edges. If dir=:in edges go from the        neighbors to the central node. If dir=:out we have the opposite        direction.\nkws: Further keyword arguments will be passed to the GNNGraph constructor.\n\nExamples\n\njulia> n, r = 10, 0.75;\n\njulia> x = rand(3, n);\n\njulia> g = radius_graph(x, r)\nGNNGraph:\n    num_nodes = 10\n    num_edges = 46\n\njulia> graph_indicator = [1,1,1,1,1,2,2,2,2,2];\n\njulia> g = radius_graph(x, r; graph_indicator)\nGNNGraph:\n    num_nodes = 10\n    num_edges = 20\n    num_graphs = 2\n\n\n\n\n\n\n","category":"method"},{"location":"api/gnngraph/#GraphNeuralNetworks.GNNGraphs.rand_graph-Tuple{Integer, Integer}","page":"GNNGraph","title":"GraphNeuralNetworks.GNNGraphs.rand_graph","text":"rand_graph(n, m; bidirected=true, seed=-1, kws...)\n\nGenerate a random (Erdós-Renyi) GNNGraph with n nodes and m edges.\n\nIf bidirected=true the reverse edge of each edge will be present. If bidirected=false instead, m unrelated edges are generated. In any case, the output graph will contain no self-loops or multi-edges.\n\nUse a seed > 0 for reproducibility.\n\nAdditional keyword arguments will be passed to the GNNGraph constructor.\n\nExamples\n\njulia> g = rand_graph(5, 4, bidirected=false)\nGNNGraph:\n    num_nodes = 5\n    num_edges = 4\n\njulia> edge_index(g)\n([1, 3, 3, 4], [5, 4, 5, 2])\n\n# In the bidirected case, edge data will be duplicated on the reverse edges if needed.\njulia> g = rand_graph(5, 4, edata=rand(16, 2))\nGNNGraph:\n    num_nodes = 5\n    num_edges = 4\n    edata:\n        e => (16, 4)\n\n# Each edge has a reverse\njulia> edge_index(g)\n([1, 3, 3, 4], [3, 4, 1, 3])\n\n\n\n\n\n\n","category":"method"},{"location":"api/gnngraph/#Operators","page":"GNNGraph","title":"Operators","text":"","category":"section"},{"location":"api/gnngraph/","page":"GNNGraph","title":"GNNGraph","text":"Modules = [GraphNeuralNetworks.GNNGraphs]\nPages   = [\"operators.jl\"]\nPrivate = false","category":"page"},{"location":"api/gnngraph/","page":"GNNGraph","title":"GNNGraph","text":"Graphs.intersect","category":"page"},{"location":"api/gnngraph/#Base.intersect","page":"GNNGraph","title":"Base.intersect","text":"intersect(g, h)\n\nReturn a graph with edges that are only in both graph g and graph h.\n\nImplementation Notes\n\nThis function may produce a graph with 0-degree vertices. Preserves the eltype of the input graph.\n\nExamples\n\njulia> g1 = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> g2 = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);\n\njulia> foreach(println, edges(intersect(g1, g2)))\nEdge 1 => 2\nEdge 2 => 3\nEdge 3 => 1\n\n\n\n\n\n","category":"function"},{"location":"api/gnngraph/#Sampling","page":"GNNGraph","title":"Sampling","text":"","category":"section"},{"location":"api/gnngraph/","page":"GNNGraph","title":"GNNGraph","text":"Modules = [GraphNeuralNetworks.GNNGraphs]\nPages   = [\"sampling.jl\"]\nPrivate = false","category":"page"},{"location":"api/gnngraph/#GraphNeuralNetworks.GNNGraphs.sample_neighbors","page":"GNNGraph","title":"GraphNeuralNetworks.GNNGraphs.sample_neighbors","text":"sample_neighbors(g, nodes, K=-1; dir=:in, replace=false, dropnodes=false)\n\nSample neighboring edges of the given nodes and return the induced subgraph. For each node, a number of inbound (or outbound when dir = :out) edges will be randomly chosen.  Ifdropnodes=false`, the graph returned will then contain all the nodes in the original graph,  but only the sampled edges.\n\nThe returned graph will contain an edge feature EID corresponding to the id of the edge in the original graph. If dropnodes=true, it will also contain a node feature NID with the node ids in the original graph.\n\nArguments\n\ng. The graph.\nnodes. A list of node IDs to sample neighbors from.\nK. The maximum number of edges to be sampled for each node.      If -1, all the neighboring edges will be selected.\ndir. Determines whether to sample inbound (:in) or outbound (`:out) edges (Default :in).\nreplace. If true, sample with replacement.\ndropnodes. If true, the resulting subgraph will contain only the nodes involved in the sampled edges.\n\nExamples\n\njulia> g = rand_graph(20, 100)\nGNNGraph:\n    num_nodes = 20\n    num_edges = 100\n\njulia> sample_neighbors(g, 2:3)\nGNNGraph:\n    num_nodes = 20\n    num_edges = 9\n    edata:\n        EID => (9,)\n\njulia> sg = sample_neighbors(g, 2:3, dropnodes=true)\nGNNGraph:\n    num_nodes = 10\n    num_edges = 9\n    ndata:\n        NID => (10,)\n    edata:\n        EID => (9,)\n\njulia> sg.ndata.NID\n10-element Vector{Int64}:\n  2\n  3\n 17\n 14\n 18\n 15\n 16\n 20\n  7\n 10\n\njulia> sample_neighbors(g, 2:3, 5, replace=true)\nGNNGraph:\n    num_nodes = 20\n    num_edges = 10\n    edata:\n        EID => (10,)\n\n\n\n\n\n","category":"function"},{"location":"tutorials/graph_classification_pluto/","page":"Graph Classification","title":"Graph Classification","text":"<style>\n    table {\n        display: table !important;\n        margin: 2rem auto !important;\n        border-top: 2pt solid rgba(0,0,0,0.2);\n        border-bottom: 2pt solid rgba(0,0,0,0.2);\n    }\n\n    pre, div {\n        margin-top: 1.4rem !important;\n        margin-bottom: 1.4rem !important;\n    }\n\n    .code-output {\n        padding: 0.7rem 0.5rem !important;\n    }\n\n    .admonition-body {\n        padding: 0em 1.25em !important;\n    }\n</style>\n\n<!-- PlutoStaticHTML.Begin -->\n<!--\n    # This information is used for caching.\n    [PlutoStaticHTML.State]\n    input_sha = \"8548882b696d0bb922c0e72dd300f971cb2f2877da44d80b82b99b60930ff7ec\"\n    julia_version = \"1.7.3\"\n-->\n<pre class='language-julia'><code class='language-julia'>begin\n    using Pkg\n    Pkg.activate(; temp=true)\n    packages = [\n        PackageSpec(; path=joinpath(@__DIR__,\"..\",\"..\",\"..\")),\n        PackageSpec(; name=\"Flux\", version=\"0.13\"),\n        PackageSpec(; name=\"MLDatasets\", version=\"0.7\"),\n    ]\n    Pkg.add(packages)\nend</code></pre>\n\n\n<pre class='language-julia'><code class='language-julia'>begin\n    using Flux\n    using Flux: onecold, onehotbatch, logitcrossentropy\n    using Flux.Data: DataLoader\n    using GraphNeuralNetworks\n    using MLDatasets\n    using LinearAlgebra, Random, Statistics\n    ENV[\"DATADEPS_ALWAYS_ACCEPT\"] = \"true\"  # don't ask for dataset download confirmation\n    Random.seed!(17) # for reproducibility\nend;</code></pre>\n\n\n\n<div class=\"markdown\"><h1>Graph Classification with Graph Neural Networks</h1>\n<p><em>This Pluto noteboook is a julia adaptation of the Pytorch Geometric tutorials that can be found <a href=\"https://pytorch-geometric.readthedocs.io/en/latest/notes/colabs.html\">here</a>.</em></p>\n<p>In this tutorial session we will have a closer look at how to apply <strong>Graph Neural Networks &#40;GNNs&#41; to the task of graph classification</strong>. Graph classification refers to the problem of classifiying entire graphs &#40;in contrast to nodes&#41;, given a <strong>dataset of graphs</strong>, based on some structural graph properties. Here, we want to embed entire graphs, and we want to embed those graphs in such a way so that they are linearly separable given a task at hand.</p>\n<p>The most common task for graph classification is <strong>molecular property prediction</strong>, in which molecules are represented as graphs, and the task may be to infer whether a molecule inhibits HIV virus replication or not.</p>\n<p>The TU Dortmund University has collected a wide range of different graph classification datasets, known as the <a href=\"https://chrsmrrs.github.io/datasets/\"><strong>TUDatasets</strong></a>, which are also accessible via MLDatasets.jl. Let&#39;s load and inspect one of the smaller ones, the <strong>MUTAG dataset</strong>:</p>\n</div>\n\n<pre class='language-julia'><code class='language-julia'>dataset = TUDataset(\"MUTAG\")</code></pre>\n<pre id='var-dataset' class='code-output documenter-example-output'>dataset TUDataset:\n  name        =>    MUTAG\n  metadata    =>    Dict{String, Any} with 1 entry\n  graphs      =>    188-element Vector{MLDatasets.Graph}\n  graph_data  =>    (targets = \"188-element Vector{Int64}\",)\n  num_nodes   =>    3371\n  num_edges   =>    7442\n  num_graphs  =>    188</pre>\n\n<pre class='language-julia'><code class='language-julia'>dataset.graph_data.targets |&gt; union</code></pre>\n<pre id='var-hash194771' class='code-output documenter-example-output'>2-element Vector{Int64}:\n  1\n -1</pre>\n\n<pre class='language-julia'><code class='language-julia'>g1, y1  = dataset[1] #get the first graph and target</code></pre>\n<pre id='var-y1' class='code-output documenter-example-output'>(graphs = Graph(17, 38), targets = 1)</pre>\n\n<pre class='language-julia'><code class='language-julia'>reduce(vcat, g.node_data.targets for (g,_) in dataset) |&gt; union</code></pre>\n<pre id='var-hash163982' class='code-output documenter-example-output'>7-element Vector{Int64}:\n 0\n 1\n 2\n 3\n 4\n 5\n 6</pre>\n\n<pre class='language-julia'><code class='language-julia'>reduce(vcat, g.edge_data.targets for (g,_) in dataset)|&gt; union</code></pre>\n<pre id='var-hash766940' class='code-output documenter-example-output'>4-element Vector{Int64}:\n 0\n 1\n 2\n 3</pre>\n\n\n<div class=\"markdown\"><p>This dataset provides <strong>188 different graphs</strong>, and the task is to classify each graph into <strong>one out of two classes</strong>.</p>\n<p>By inspecting the first graph object of the dataset, we can see that it comes with <strong>17 nodes</strong> and <strong>38 edges</strong>. It also comes with exactly <strong>one graph label</strong>, and provides additional node labels &#40;7 classes&#41; and edge labels &#40;4 classes&#41;. However, for the sake of simplicity, we will not make use of edge labels.</p>\n<p>We have some useful utilities for working with graph datasets, <em>e.g.</em>, we can shuffle the dataset and use the first 150 graphs as training graphs, while using the remaining ones for testing:</p>\n</div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    graphs = mldataset2gnngraph(dataset)\n    graphs = [GNNGraph(g, \n                       ndata=Float32.(onehotbatch(g.ndata.targets, 0:6)),\n                       edata=nothing) \n              for g in graphs]\nend</code></pre>\n<pre id='var-graphs' class='code-output documenter-example-output'>188-element Vector{GNNGraph{Tuple{Vector{Int64}, Vector{Int64}, Nothing}}}:\n GNNGraph(17, 38)\n GNNGraph(13, 28)\n GNNGraph(13, 28)\n GNNGraph(19, 44)\n GNNGraph(11, 22)\n GNNGraph(28, 62)\n GNNGraph(16, 34)\n ⋮\n GNNGraph(22, 50)\n GNNGraph(22, 50)\n GNNGraph(13, 26)\n GNNGraph(12, 26)\n GNNGraph(21, 48)\n GNNGraph(16, 36)</pre>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    shuffled_idxs = randperm(length(graphs))\n    train_idxs = shuffled_idxs[1:150]\n    test_idxs = shuffled_idxs[151:end]\n    train_graphs = graphs[train_idxs]\n    test_graphs = graphs[test_idxs]\n    ytrain = onehotbatch(dataset.graph_data.targets[train_idxs], [-1, 1])\n    ytest = onehotbatch(dataset.graph_data.targets[test_idxs], [-1, 1])\nend</code></pre>\n<pre id='var-train_idxs' class='code-output documenter-example-output'>2×38 OneHotMatrix(::Vector{UInt32}) with eltype Bool:\n ⋅  ⋅  1  ⋅  1  1  1  ⋅  ⋅  1  1  ⋅  1  1  …  1  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  ⋅  ⋅  1\n 1  1  ⋅  1  ⋅  ⋅  ⋅  1  1  ⋅  ⋅  1  ⋅  ⋅     ⋅  ⋅  1  1  1  1  1  1  1  ⋅  1  1  ⋅</pre>\n\n","category":"page"},{"location":"tutorials/graph_classification_pluto/#Mini-batching-of-graphs","page":"Graph Classification","title":"Mini-batching of graphs","text":"","category":"section"},{"location":"tutorials/graph_classification_pluto/","page":"Graph Classification","title":"Graph Classification","text":"<div class=\"markdown\">\n\n<p>Since graphs in graph classification datasets are usually small, a good idea is to <strong>batch the graphs</strong> before inputting them into a Graph Neural Network to guarantee full GPU utilization. In the image or language domain, this procedure is typically achieved by <strong>rescaling</strong> or <strong>padding</strong> each example into a set of equally-sized shapes, and examples are then grouped in an additional dimension. The length of this dimension is then equal to the number of examples grouped in a mini-batch and is typically referred to as the <code>batchsize</code>.</p>\n<p>However, for GNNs the two approaches described above are either not feasible or may result in a lot of unnecessary memory consumption. Therefore, GNN.jl opts for another approach to achieve parallelization across a number of examples. Here, adjacency matrices are stacked in a diagonal fashion &#40;creating a giant graph that holds multiple isolated subgraphs&#41;, and node and target features are simply concatenated in the node dimension &#40;the last dimension&#41;.</p>\n<p>This procedure has some crucial advantages over other batching procedures:</p>\n<ol>\n<li><p>GNN operators that rely on a message passing scheme do not need to be modified since messages are not exchanged between two nodes that belong to different graphs.</p>\n</li>\n<li><p>There is no computational or memory overhead since adjacency matrices are saved in a sparse fashion holding only non-zero entries, <em>i.e.</em>, the edges.</p>\n</li>\n</ol>\n<p>GNN.jl can <strong>batch multiple graphs into a single giant graph</strong> with the help of Flux&#39;s <code>DataLoader</code>:</p>\n</div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    train_loader = DataLoader((train_graphs, ytrain), batchsize=64, shuffle=true)\n    test_loader = DataLoader((test_graphs, ytest), batchsize=64, shuffle=false)\nend</code></pre>\n<pre id='var-test_loader' class='code-output documenter-example-output'>DataLoader{Tuple{Vector{GNNGraph{Tuple{Vector{Int64}, Vector{Int64}, Nothing}}}, Flux.OneHotArray{UInt32, 2, 1, 2, Vector{UInt32}}}, Random._GLOBAL_RNG, Val{nothing}}((GraphNeuralNetworks.GNNGraphs.GNNGraph{Tuple{Vector{Int64}, Vector{Int64}, Nothing}}[GNNGraph(24, 50), GNNGraph(22, 50), GNNGraph(11, 22), GNNGraph(12, 24), GNNGraph(13, 26), GNNGraph(16, 34), GNNGraph(10, 20), GNNGraph(15, 34), GNNGraph(23, 54), GNNGraph(22, 46)  …  GNNGraph(19, 44), GNNGraph(28, 62), GNNGraph(20, 44), GNNGraph(26, 60), GNNGraph(23, 50), GNNGraph(17, 38), GNNGraph(16, 36), GNNGraph(23, 54), GNNGraph(18, 40), GNNGraph(16, 34)], Bool[0 0 … 0 1; 1 1 … 1 0]), 64, false, true, false, false, Val{nothing}(), Random._GLOBAL_RNG())</pre>\n\n<pre class='language-julia'><code class='language-julia'>first(train_loader)</code></pre>\n<pre id='var-hash113787' class='code-output documenter-example-output'>(GNNGraph(1167, 2570), Bool[1 1 … 1 0; 0 0 … 0 1])</pre>\n\n<pre class='language-julia'><code class='language-julia'>collect(train_loader)</code></pre>\n<pre id='var-hash151660' class='code-output documenter-example-output'>3-element Vector{Tuple{GNNGraph{Tuple{Vector{Int64}, Vector{Int64}, Nothing}}, Flux.OneHotArray{UInt32, 2, 1, 2, Vector{UInt32}}}}:\n (GNNGraph(1155, 2572), [1 1 … 0 0; 0 0 … 1 1])\n (GNNGraph(1101, 2406), [0 0 … 0 0; 1 1 … 1 1])\n (GNNGraph(414, 920), [0 1 … 0 0; 1 0 … 1 1])</pre>\n\n<pre class='language-julia'><code class='language-julia'>first(train_loader)[1]</code></pre>\n<pre id='var-hash134244' class='code-output documenter-example-output'>GNNGraph:\n    num_nodes = 1152\n    num_edges = 2554\n    num_graphs = 64\n    ndata:\n        x => 7×1152 Matrix{Float32}</pre>\n\n\n<div class=\"markdown\"><p>Here, we opt for a <code>batch_size</code> of 64, leading to 3 &#40;randomly shuffled&#41; mini-batches, containing all <span class=\"tex\">$2 \\cdot 64&#43;22 &#61; 150$</span> graphs.</p>\n<p>Furthermore, each batched graph object is equipped with a <strong><code>graph_indicator</code> vector</strong>, which maps each node to its respective graph in the batch:</p>\n<p class=\"tex\">$$\\textrm&#123;graph-indicator&#125; &#61; &#91;1, \\ldots, 1, 2, \\ldots, 2, 3, \\ldots &#93;$$</p>\n<h2>Training a Graph Neural Network &#40;GNN&#41;</h2>\n<p>Training a GNN for graph classification usually follows a simple recipe:</p>\n<ol>\n<li><p>Embed each node by performing multiple rounds of message passing</p>\n</li>\n<li><p>Aggregate node embeddings into a unified graph embedding &#40;<strong>readout layer</strong>&#41;</p>\n</li>\n<li><p>Train a final classifier on the graph embedding</p>\n</li>\n</ol>\n<p>There exists multiple <strong>readout layers</strong> in literature, but the most common one is to simply take the average of node embeddings:</p>\n<p class=\"tex\">$$\\mathbf&#123;x&#125;_&#123;\\mathcal&#123;G&#125;&#125; &#61; \\frac&#123;1&#125;&#123;|\\mathcal&#123;V&#125;|&#125; \\sum_&#123;v \\in \\mathcal&#123;V&#125;&#125; \\mathcal&#123;x&#125;^&#123;&#40;L&#41;&#125;_v$$</p>\n<p>GNN.jl provides this functionality via <code>GlobalPool&#40;mean&#41;</code>, which takes in the node embeddings of all nodes in the mini-batch and the assignment vector <code>graph_indicator</code> to compute a graph embedding of size <code>&#91;hidden_channels, batchsize&#93;</code>.</p>\n<p>The final architecture for applying GNNs to the task of graph classification then looks as follows and allows for complete end-to-end training:</p>\n</div>\n\n<pre class='language-julia'><code class='language-julia'>function create_model(nin, nh, nout)\n    GNNChain(GCNConv(nin =&gt; nh, relu),\n             GCNConv(nh =&gt; nh, relu),\n             GCNConv(nh =&gt; nh),\n             GlobalPool(mean),\n             Dropout(0.5),\n             Dense(nh, nout))\nend</code></pre>\n<pre id='var-create_model' class='code-output documenter-example-output'>create_model (generic function with 1 method)</pre>\n\n\n<div class=\"markdown\"><p>Here, we again make use of the <code>GCNConv</code> with <span class=\"tex\">$\\mathrm&#123;ReLU&#125;&#40;x&#41; &#61; \\max&#40;x, 0&#41;$</span> activation for obtaining localized node embeddings, before we apply our final classifier on top of a graph readout layer.</p>\n<p>Let&#39;s train our network for a few epochs to see how well it performs on the training as well as test set:</p>\n</div>\n\n<pre class='language-julia'><code class='language-julia'>function eval_loss_accuracy(model, data_loader, device)\n    loss = 0.\n    acc = 0.\n    ntot = 0\n    for (g, y) in data_loader\n        g, y = g |&gt; device, y |&gt; device\n        n = length(y)\n        ŷ = model(g, g.ndata.x)\n        loss += logitcrossentropy(ŷ, y) * n \n        acc += mean((ŷ .&gt; 0) .== y) * n\n        ntot += n\n    end \n    return (loss = round(loss/ntot, digits=4), acc = round(acc*100/ntot, digits=2))\nend</code></pre>\n<pre id='var-eval_loss_accuracy' class='code-output documenter-example-output'>eval_loss_accuracy (generic function with 1 method)</pre>\n\n<pre class='language-julia'><code class='language-julia'>function train!(model; epochs=200, η=1e-2, infotime=10)\n    # device = Flux.gpu # uncomment this for GPU training\n    device = Flux.cpu\n    model = model |&gt; device\n    ps = Flux.params(model)\n    opt = Adam(1e-3)\n    \n\n    function report(epoch)\n        train = eval_loss_accuracy(model, train_loader, device)\n        test = eval_loss_accuracy(model, test_loader, device)\n        @info (; epoch, train, test)\n    end\n    \n    report(0)\n    for epoch in 1:epochs\n        for (g, y) in train_loader\n            g, y = g |&gt; device, y |&gt; device\n            gs = Flux.gradient(ps) do\n                ŷ = model(g, g.ndata.x)\n                logitcrossentropy(ŷ, y)\n            end\n            Flux.Optimise.update!(opt, ps, gs)\n        end\n        epoch % infotime == 0 && report(epoch)\n    end\nend</code></pre>\n<pre id='var-train!' class='code-output documenter-example-output'>train! (generic function with 1 method)</pre>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    nin = 7  \n    nh = 64\n    nout = 2\n    model = create_model(nin, nh, nout)\n    train!(model)\nend</code></pre>\n\n\n\n<div class=\"markdown\"><p>As one can see, our model reaches around <strong>74&#37; test accuracy</strong>. Reasons for the fluctations in accuracy can be explained by the rather small dataset &#40;only 38 test graphs&#41;, and usually disappear once one applies GNNs to larger datasets.</p>\n<h2>&#40;Optional&#41; Exercise</h2>\n<p>Can we do better than this? As multiple papers pointed out &#40;<a href=\"https://arxiv.org/abs/1810.00826\">Xu et al. &#40;2018&#41;</a>, <a href=\"https://arxiv.org/abs/1810.02244\">Morris et al. &#40;2018&#41;</a>&#41;, applying <strong>neighborhood normalization decreases the expressivity of GNNs in distinguishing certain graph structures</strong>. An alternative formulation &#40;<a href=\"https://arxiv.org/abs/1810.02244\">Morris et al. &#40;2018&#41;</a>&#41; omits neighborhood normalization completely and adds a simple skip-connection to the GNN layer in order to preserve central node information:</p>\n<p class=\"tex\">$$\\mathbf&#123;x&#125;_i^&#123;&#40;\\ell&#43;1&#41;&#125; &#61; \\mathbf&#123;W&#125;^&#123;&#40;\\ell &#43; 1&#41;&#125;_1 \\mathbf&#123;x&#125;_i^&#123;&#40;\\ell&#41;&#125; &#43; \\mathbf&#123;W&#125;^&#123;&#40;\\ell &#43; 1&#41;&#125;_2 \\sum_&#123;j \\in \\mathcal&#123;N&#125;&#40;i&#41;&#125; \\mathbf&#123;x&#125;_j^&#123;&#40;\\ell&#41;&#125;$$</p>\n<p>This layer is implemented under the name <code>GraphConv</code> in GNN.jl.</p>\n<p>As an exercise, you are invited to complete the following code to the extent that it makes use of <code>GraphConv</code> rather than <code>GCNConv</code>. This should bring you close to <strong>82&#37; test accuracy</strong>.</p>\n</div>\n\n","category":"page"},{"location":"tutorials/graph_classification_pluto/#Conclusion","page":"Graph Classification","title":"Conclusion","text":"","category":"section"},{"location":"tutorials/graph_classification_pluto/","page":"Graph Classification","title":"Graph Classification","text":"<div class=\"markdown\">\n\n<p>In this chapter, you have learned how to apply GNNs to the task of graph classification. You have learned how graphs can be batched together for better GPU utilization, and how to apply readout layers for obtaining graph embeddings rather than node embeddings.</p>\n</div>\n\n<!-- PlutoStaticHTML.End -->","category":"page"},{"location":"tutorials/graph_classification_pluto/","page":"Graph Classification","title":"Graph Classification","text":"EditURL = \"https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/master/docs/src/tutorials/graph_classification_pluto.jl\"","category":"page"},{"location":"datasets/#Datasets","page":"Datasets","title":"Datasets","text":"","category":"section"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"GraphNeuralNetworks.jl doesn't come with its own datasets, but leverages those available in the Julia (and non-Julia) ecosystem. In particular, the examples in the GraphNeuralNetworks.jl repository make use of the MLDatasets.jl package. There you will find common graph datasets such as Cora, PubMed, Citeseer, TUDataset and many others.","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"GraphNeuralNetworks.jl provides the mldataset2gnngraph method for interfacing with MLDatasets.jl.","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"mldataset2gnngraph","category":"page"},{"location":"datasets/#GraphNeuralNetworks.mldataset2gnngraph","page":"Datasets","title":"GraphNeuralNetworks.mldataset2gnngraph","text":"mldataset2gnngraph(dataset)\n\nConvert a graph dataset from the package MLDatasets.jl into one or many GNNGraphs.\n\nExamples\n\njulia> using MLDatasets, GraphNeuralNetworks\n\njulia> mldataset2gnngraph(Cora())\nGNNGraph:\n    num_nodes = 2708\n    num_edges = 10556\n    ndata:\n        features => 1433×2708 Matrix{Float32}\n        targets => 2708-element Vector{Int64}\n        train_mask => 2708-element BitVector\n        val_mask => 2708-element BitVector\n        test_mask => 2708-element BitVector\n\n\n\n\n\n","category":"function"},{"location":"dev/#Developer-Notes","page":"Developer Notes","title":"Developer Notes","text":"","category":"section"},{"location":"dev/#Benchmarking","page":"Developer Notes","title":"Benchmarking","text":"","category":"section"},{"location":"dev/","page":"Developer Notes","title":"Developer Notes","text":"You can benchmark the effect on performance of your commits using the script perf/perf.jl.","category":"page"},{"location":"dev/","page":"Developer Notes","title":"Developer Notes","text":"First, checkout and benchmark the master branch:","category":"page"},{"location":"dev/","page":"Developer Notes","title":"Developer Notes","text":"julia> include(\"perf.jl\")\n\njulia> df = run_benchmarks()\n\n# observe results\njulia> for g in groupby(df, :layer); println(g, \"\\n\"); end\n\njulia> @save \"perf_master_20210803_mymachine.jld2\" dfmaster=df","category":"page"},{"location":"dev/","page":"Developer Notes","title":"Developer Notes","text":"Now checkout your branch and do the same:","category":"page"},{"location":"dev/","page":"Developer Notes","title":"Developer Notes","text":"julia> df = run_benchmarks()\n\njulia> @save \"perf_pr_20210803_mymachine.jld2\" dfpr=df","category":"page"},{"location":"dev/","page":"Developer Notes","title":"Developer Notes","text":"Finally, compare the results:","category":"page"},{"location":"dev/","page":"Developer Notes","title":"Developer Notes","text":"julia> @load \"perf_master_20210803_mymachine.jld2\"\n\njulia> @load \"perf_pr_20210803_mymachine.jld2\"\n\njulia> compare(dfpr, dfmaster)","category":"page"},{"location":"api/utils/","page":"Utils","title":"Utils","text":"CurrentModule = GraphNeuralNetworks","category":"page"},{"location":"api/utils/#Utility-Functions","page":"Utils","title":"Utility Functions","text":"","category":"section"},{"location":"api/utils/#Index","page":"Utils","title":"Index","text":"","category":"section"},{"location":"api/utils/","page":"Utils","title":"Utils","text":"Order = [:type, :function]\nPages   = [\"utils.md\"]","category":"page"},{"location":"api/utils/#Docs","page":"Utils","title":"Docs","text":"","category":"section"},{"location":"api/utils/#Graph-wise-operations","page":"Utils","title":"Graph-wise operations","text":"","category":"section"},{"location":"api/utils/","page":"Utils","title":"Utils","text":"GraphNeuralNetworks.reduce_nodes\nGraphNeuralNetworks.reduce_edges\nGraphNeuralNetworks.softmax_nodes\nGraphNeuralNetworks.softmax_edges\nGraphNeuralNetworks.broadcast_nodes\nGraphNeuralNetworks.broadcast_edges","category":"page"},{"location":"api/utils/#GraphNeuralNetworks.reduce_nodes","page":"Utils","title":"GraphNeuralNetworks.reduce_nodes","text":"reduce_nodes(aggr, g, x)\n\nFor a batched graph g, return the graph-wise aggregation of the node features x. The aggregation operator aggr can be +, mean, max, or min. The returned array will have last dimension g.num_graphs.\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#GraphNeuralNetworks.reduce_edges","page":"Utils","title":"GraphNeuralNetworks.reduce_edges","text":"reduce_edges(aggr, g, e)\n\nFor a batched graph g, return the graph-wise aggregation of the edge features e. The aggregation operator aggr can be +, mean, max, or min. The returned array will have last dimension g.num_graphs.\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#GraphNeuralNetworks.softmax_nodes","page":"Utils","title":"GraphNeuralNetworks.softmax_nodes","text":"softmax_nodes(g, x)\n\nGraph-wise softmax of the node features x.\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#GraphNeuralNetworks.softmax_edges","page":"Utils","title":"GraphNeuralNetworks.softmax_edges","text":"softmax_edges(g, e)\n\nGraph-wise softmax of the edge features e.\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#GraphNeuralNetworks.broadcast_nodes","page":"Utils","title":"GraphNeuralNetworks.broadcast_nodes","text":"broadcast_nodes(g, x)\n\nGraph-wise broadcast array x of size (*, g.num_graphs)  to size (*, g.num_nodes).\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#GraphNeuralNetworks.broadcast_edges","page":"Utils","title":"GraphNeuralNetworks.broadcast_edges","text":"broadcast_edges(g, x)\n\nGraph-wise broadcast array x of size (*, g.num_graphs)  to size (*, g.num_edges).\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#Neighborhood-operations","page":"Utils","title":"Neighborhood operations","text":"","category":"section"},{"location":"api/utils/","page":"Utils","title":"Utils","text":"GraphNeuralNetworks.softmax_edge_neighbors","category":"page"},{"location":"api/utils/#GraphNeuralNetworks.softmax_edge_neighbors","page":"Utils","title":"GraphNeuralNetworks.softmax_edge_neighbors","text":"softmax_edge_neighbors(g, e)\n\nSoftmax over each node's neighborhood of the edge features e.\n\nmathbfe_jto i = frace^mathbfe_jto i\n                    sum_jin N(i) e^mathbfe_jto i\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#NNlib","page":"Utils","title":"NNlib","text":"","category":"section"},{"location":"api/utils/","page":"Utils","title":"Utils","text":"Primitive functions implemented in NNlib.jl.","category":"page"},{"location":"api/utils/","page":"Utils","title":"Utils","text":"NNlib.gather!\nNNlib.gather\nNNlib.scatter!\nNNlib.scatter","category":"page"},{"location":"api/utils/#NNlib.gather!","page":"Utils","title":"NNlib.gather!","text":"NNlib.gather!(dst, src, idx)\n\nReverse operation of scatter!. Gathers data from source src  and writes it in destination dst according to the index array idx. For each k in CartesianIndices(idx), assign values to dst according to\n\ndst[:, ... , k] .= src[:, ... , idx[k]...]\n\nNotice that if idx is a vector containing integers, and both dst and src are matrices, previous expression simplifies to\n\ndst[:, k] .= src[:, idx[k]]\n\nand k will run over 1:length(idx). \n\nThe elements of idx can be integers or integer tuples and may be repeated.  A single src column can end up being copied into zero, one,  or multiple dst columns.\n\nSee gather for an allocating version.\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#NNlib.gather","page":"Utils","title":"NNlib.gather","text":"NNlib.gather(src, idx) -> dst\n\nReverse operation of scatter. Gathers data from source src  and writes it in a destination dst according to the index array idx. For each k in CartesianIndices(idx), assign values to dst  according to\n\ndst[:, ... , k] .= src[:, ... , idx[k]...]\n\nNotice that if idx is a vector containing integers and src is a matrix, previous expression simplifies to\n\ndst[:, k] .= src[:, idx[k]]\n\nand k will run over 1:length(idx). \n\nThe elements of idx can be integers or integer tuples and may be repeated.  A single src column can end up being copied into zero, one,  or multiple dst columns.\n\nSee gather! for an in-place version.\n\nExamples\n\njulia> NNlib.gather([1,20,300,4000], [2,4,2])\n3-element Vector{Int64}:\n   20\n 4000\n   20\n\njulia> NNlib.gather([1 2 3; 4 5 6], [1,3,1,3,1])\n2×5 Matrix{Int64}:\n 1  3  1  3  1\n 4  6  4  6  4\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#NNlib.scatter!","page":"Utils","title":"NNlib.scatter!","text":"NNlib.scatter!(op, dst, src, idx)\n\nScatter operation, which writes data in src into dst at locations idx. A binary reduction operator op is applied during the scatter.  For each index k in idx, accumulates values in dst according to\n\ndst[:, ..., idx[k]...] = (op).(dst[:, ..., idx[k]...], src[:, ..., k...])\n\nSee also scatter, gather.\n\nArguments\n\nop: Operations to be applied on dst and src, e.g. +, -, *, /, max, min and mean.\ndst: The destination for src to aggregate to. This argument will be mutated.\nsrc: The source data for aggregating.\nidx: The mapping for aggregation from source (index) to destination (value).         The idx array can contain either integers or tuples.\n\nExamples\n\njulia> NNlib.scatter!(+, ones(3), [10,100], [1,3])\n3-element Vector{Float64}:\n  11.0\n   1.0\n 101.0\n\njulia> NNlib.scatter!(*, fill(0.5, 2, 4), [1 10; 100 1000], [3,2])\n2×4 Matrix{Float64}:\n 0.5    5.0   0.5  0.5\n 0.5  500.0  50.0  0.5\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#NNlib.scatter","page":"Utils","title":"NNlib.scatter","text":"NNlib.scatter(op, src, idx; [init, dstsize])\n\nScatter operation allocating a destination array dst and  calling scatter!(op, dst, src, idx) on it.\n\nIf keyword init is provided, it is used to initialize the content of dst. Otherwise, the init values is inferred from the reduction operator op for some common operators (e.g. init = 0 for op = +). \nIf dstsize is provided, it will be used to define the size of destination array, otherwise it will be inferred by src and idx.\n\nSee scatter! for full details on how idx works.\n\nExamples\n\njulia> NNlib.scatter(+, [10,100,1000], [3,1,2])\n3-element Vector{Int64}:\n  100\n 1000\n   10\n\njulia> NNlib.scatter(+, [1 2 3 4; 5 6 7 8], [2,1,1,5])\n2×5 Matrix{Int64}:\n  5  1  0  0  4\n 13  5  0  0  8\n\njulia> NNlib.scatter(*, [10,200,3000], [1,4,2]; init = 10, dstsize = 6)\n6-element Vector{Int64}:\n   100\n 30000\n    10\n  2000\n    10\n    10\n\n\n\n\n\n","category":"function"},{"location":"gnngraph/#Graphs","page":"Graphs","title":"Graphs","text":"","category":"section"},{"location":"gnngraph/","page":"Graphs","title":"Graphs","text":"The fundamental graph type in GraphNeuralNetworks.jl is the GNNGraph. A GNNGraph g is a directed graph with nodes labeled from 1 to g.num_nodes. The underlying implementation allows for efficient application of graph neural network operators, gpu movement, and storage of node/edge/graph related feature arrays.","category":"page"},{"location":"gnngraph/","page":"Graphs","title":"Graphs","text":"GNNGraph inherits from Graphs.jl's AbstractGraph, therefore it supports most functionality from that library. ","category":"page"},{"location":"gnngraph/#Graph-Creation","page":"Graphs","title":"Graph Creation","text":"","category":"section"},{"location":"gnngraph/","page":"Graphs","title":"Graphs","text":"A GNNGraph can be created from several different data sources encoding the graph topology:","category":"page"},{"location":"gnngraph/","page":"Graphs","title":"Graphs","text":"using GraphNeuralNetworks, Graphs, SparseArrays\n\n\n# Construct a GNNGraph from from a Graphs.jl's graph\nlg = erdos_renyi(10, 30)\ng = GNNGraph(lg)\n\n# Same as above using convenience method rand_graph\ng = rand_graph(10, 60)\n\n# From an adjacency matrix\nA = sprand(10, 10, 0.3)\ng = GNNGraph(A)\n\n# From an adjacency list\nadjlist = [[2,3], [1,3], [1,2,4], [3]]\ng = GNNGraph(adjlist)\n\n# From COO representation\nsource = [1,1,2,2,3,3,3,4]\ntarget = [2,3,1,3,1,2,4,3]\ng = GNNGraph(source, target)","category":"page"},{"location":"gnngraph/","page":"Graphs","title":"Graphs","text":"See also the related methods Graphs.adjacency_matrix, edge_index, and adjacency_list.","category":"page"},{"location":"gnngraph/#Basic-Queries","page":"Graphs","title":"Basic Queries","text":"","category":"section"},{"location":"gnngraph/","page":"Graphs","title":"Graphs","text":"julia> source = [1,1,2,2,3,3,3,4];\n\njulia> target = [2,3,1,3,1,2,4,3];\n\njulia> g = GNNGraph(source, target)\nGNNGraph:\n    num_nodes = 4\n    num_edges = 8\n\n\njulia> @assert g.num_nodes == 4   # number of nodes\n\njulia> @assert g.num_edges == 8   # number of edges\n\njulia> @assert g.num_graphs == 1  # number of subgraphs (a GNNGraph can batch many graphs together)\n\njulia> is_directed(g)      # a GNNGraph is always directed\ntrue\n\njulia> is_bidirected(g)      # for each edge, also the reverse edge is present\ntrue\n\njulia> has_self_loops(g)\nfalse\n\njulia> has_multi_edges(g)      \nfalse","category":"page"},{"location":"gnngraph/#Data-Features","page":"Graphs","title":"Data Features","text":"","category":"section"},{"location":"gnngraph/","page":"Graphs","title":"Graphs","text":"One or more arrays can be associated to nodes, edges, and (sub)graphs of a GNNGraph. They will be stored in the fields g.ndata, g.edata, and g.gdata respectivaly. The data fields are NamedTuples. The array they contain must have last dimension equal to num_nodes (in ndata), num_edges (in edata), or num_graphs (in gdata).","category":"page"},{"location":"gnngraph/","page":"Graphs","title":"Graphs","text":"# Create a graph with a single feature array `x` associated to nodes\ng = GNNGraph(erdos_renyi(10,  30), ndata = (; x = rand(Float32, 32, 10)))\n\ng.ndata.x  # access the features\n\n# Equivalent definition passing directly the array\ng = GNNGraph(erdos_renyi(10,  30), ndata = rand(Float32, 32, 10))\n\ng.ndata.x  # `:x` is the default name for node features\n\n# You can have multiple feature arrays\ng = GNNGraph(erdos_renyi(10,  30), ndata = (; x=rand(Float32, 32, 10), y=rand(Float32, 10)))\n\ng.ndata.y, g.ndata.x\n\n# Attach an array with edge features.\n# Since `GNNGraph`s are directed, the number of edges\n# will be double that of the original Graphs' undirected graph.\ng = GNNGraph(erdos_renyi(10,  30), edata = rand(Float32, 60))\n@assert g.num_edges == 60\n\ng.edata.e\n\n# If we pass only half of the edge features, they will be copied\n# on the reversed edges.\ng = GNNGraph(erdos_renyi(10,  30), edata = rand(Float32, 30))\n\n\n# Create a new graph from previous one, inheriting edge data\n# but replacing node data\ng′ = GNNGraph(g, ndata =(; z = ones(Float32, 16, 10)))\n\ng.ndata.z\ng.edata.e","category":"page"},{"location":"gnngraph/#Edge-weights","page":"Graphs","title":"Edge weights","text":"","category":"section"},{"location":"gnngraph/","page":"Graphs","title":"Graphs","text":"It is common to denote scalar edge features as edge weights. The GNNGraph has specific support for edge weights: they can be stored as part of internal representions of the graph (COO or adjacency matrix). Some graph convolutional layers, most notably the GCNConv, can use the edge weights to perform weighted sums over the nodes' neighborhoods.","category":"page"},{"location":"gnngraph/","page":"Graphs","title":"Graphs","text":"julia> source = [1, 1, 2, 2, 3, 3];\n\njulia> target = [2, 3, 1, 3, 1, 2];\n\njulia> weight = [1.0, 0.5, 2.1, 2.3, 4, 4.1];\n\njulia> g = GNNGraph(source, target, weight)\nGNNGraph:\n    num_nodes = 3\n    num_edges = 6\n\njulia> get_edge_weight(g)\n6-element Vector{Float64}:\n 1.0\n 0.5\n 2.1\n 2.3\n 4.0\n 4.1","category":"page"},{"location":"gnngraph/#Batches-and-Subgraphs","page":"Graphs","title":"Batches and Subgraphs","text":"","category":"section"},{"location":"gnngraph/","page":"Graphs","title":"Graphs","text":"Multiple GNNGraphs can be batched togheter into a single graph that contains the total number of the original nodes  and where the original graphs are disjoint subgraphs.","category":"page"},{"location":"gnngraph/","page":"Graphs","title":"Graphs","text":"using Flux\nusing Flux.Data: DataLoader\n\ndata = [rand_graph(10, 30, ndata=rand(Float32, 3, 10)) for _ in 1:160]\ngall = Flux.batch(data)\n\n# gall is a GNNGraph containing many graphs\n@assert gall.num_graphs == 160 \n@assert gall.num_nodes == 1600   # 10 nodes x 160 graphs\n@assert gall.num_edges == 9600  # 30 undirected edges x 2 directions x 160 graphs\n\n# Let's create a mini-batch from gall\ng23, _ = getgraph(gall, 2:3)\n@assert g23.num_graphs == 2\n@assert g23.num_nodes == 20   # 10 nodes x 160 graphs\n@assert g23.num_edges == 120  # 30 undirected edges x 2 directions x 2 graphs x\n\n# We can pass a GNNGraph to Flux's DataLoader\ntrain_loader = DataLoader(gall, batchsize=16, shuffle=true)\n\nfor g in train_loader\n    @assert g.num_graphs == 16\n    @assert g.num_nodes == 160\n    @assert size(g.ndata.x) = (3, 160)    \n    # .....\nend\n\n# Access the nodes' graph memberships \ngraph_indicator(gall)","category":"page"},{"location":"gnngraph/#DataLoader-and-mini-batch-iteration","page":"Graphs","title":"DataLoader and mini-batch iteration","text":"","category":"section"},{"location":"gnngraph/","page":"Graphs","title":"Graphs","text":"While constructing a batched graph and passing it to the DataLoader is always  an option for mini-batch iteration, the recommended way is to pass an array of graphs directly:","category":"page"},{"location":"gnngraph/","page":"Graphs","title":"Graphs","text":"using Flux.Data: DataLoader\n\ndata = [rand_graph(10, 30, ndata=rand(Float32, 3, 10)) for _ in 1:320]\n\ntrain_loader = DataLoader(data, batchsize=16, shuffle=true)\n\nfor g in train_loader\n    @assert g.num_graphs == 16\n    @assert g.num_nodes == 160\n    @assert size(g.ndata.x) = (3, 160)    \n    # .....\nend","category":"page"},{"location":"gnngraph/#Graph-Manipulation","page":"Graphs","title":"Graph Manipulation","text":"","category":"section"},{"location":"gnngraph/","page":"Graphs","title":"Graphs","text":"g′ = add_self_loops(g)\ng′ = remove_self_loops(g)\ng′ = add_edges(g, [1, 2], [2, 3]) # add edges 1->2 and 2->3","category":"page"},{"location":"gnngraph/#GPU-movement","page":"Graphs","title":"GPU movement","text":"","category":"section"},{"location":"gnngraph/","page":"Graphs","title":"Graphs","text":"Move a GNNGraph to a CUDA device using Flux.gpu method. ","category":"page"},{"location":"gnngraph/","page":"Graphs","title":"Graphs","text":"using Flux: gpu\n\ng_gpu = g |> gpu","category":"page"},{"location":"gnngraph/#JuliaGraphs/Graphs.jl-integration","page":"Graphs","title":"JuliaGraphs/Graphs.jl integration","text":"","category":"section"},{"location":"gnngraph/","page":"Graphs","title":"Graphs","text":"Since GNNGraph <: Graphs.AbstractGraph, we can use any functionality from Graphs.jl.  Moreover, GNNGraphs can be constructed from Graphs.Graph and Graphs.DiGraph.","category":"page"},{"location":"gnngraph/","page":"Graphs","title":"Graphs","text":"julia> import Graphs\n\njulia> using GraphNeuralNetworks\n\n# A Graphs.jl undirected graph\njulia> gu = Graphs.erdos_renyi(10, 20)    \n{10, 20} undirected simple Int64 graph\n\n# Since GNNGraphs are undirected, the edges are doubled when converting \n# to GNNGraph\njulia> GNNGraph(gu)  # Since GNNGraphs are \nGNNGraph:\n    num_nodes = 10\n    num_edges = 40\n\n# A Graphs.jl directed graph\njulia> gd = Graphs.erdos_renyi(10, 20, is_directed=true)\n{10, 20} directed simple Int64 graph\n\njulia> GNNGraph(gd)\nGNNGraph:\n    num_nodes = 10\n    num_edges = 20","category":"page"},{"location":"gsoc/#Graph-Neural-Networks-Summer-of-Code","page":"Summer Of Code","title":"Graph Neural Networks - Summer of Code","text":"","category":"section"},{"location":"gsoc/","page":"Summer Of Code","title":"Summer Of Code","text":"Potential candidates to Google Summer of Code's scholarships can find out about the available projects involving GraphNeuralNetworks.jl on the dedicated page in the Julia Language website.","category":"page"},{"location":"models/#Models","page":"Model Building","title":"Models","text":"","category":"section"},{"location":"models/","page":"Model Building","title":"Model Building","text":"GraphNeuralNetworks.jl provides common graph convolutional layers by which you can assemble arbitrarily deep or complex models. GNN layers are compatible with  Flux.jl ones, therefore expert Flux users are promptly able to define and train  their models. ","category":"page"},{"location":"models/","page":"Model Building","title":"Model Building","text":"In what follows, we discuss two different styles for model creation: the explicit modeling style, more verbose but more flexible,  and the implicit modeling style based on GNNChain, more concise but less flexible.","category":"page"},{"location":"models/#Explicit-modeling","page":"Model Building","title":"Explicit modeling","text":"","category":"section"},{"location":"models/","page":"Model Building","title":"Model Building","text":"In the explicit modeling style, the model is created according to the following steps:","category":"page"},{"location":"models/","page":"Model Building","title":"Model Building","text":"Define a new type for your model (GNN in the example below). Layers and submodels are fields.\nApply Flux.@functor to the new type to make it Flux's compatible (parameters' collection, gpu movement, etc...)\nOptionally define a convenience constructor for your model.\nDefine the forward pass by implementing the call method for your type.\nInstantiate the model. ","category":"page"},{"location":"models/","page":"Model Building","title":"Model Building","text":"Here is an example of this construction:","category":"page"},{"location":"models/","page":"Model Building","title":"Model Building","text":"using Flux, Graphs, GraphNeuralNetworks\n\nstruct GNN                                # step 1\n    conv1\n    bn\n    conv2\n    dropout\n    dense\nend\n\nFlux.@functor GNN                              # step 2\n\nfunction GNN(din::Int, d::Int, dout::Int) # step 3    \n    GNN(GCNConv(din => d),\n        BatchNorm(d),\n        GraphConv(d => d, relu),\n        Dropout(0.5),\n        Dense(d, dout))\nend\n\nfunction (model::GNN)(g::GNNGraph, x)     # step 4\n    x = model.conv1(g, x)\n    x = relu.(model.bn(x))\n    x = model.conv2(g, x)\n    x = model.dropout(x)\n    x = model.dense(x)\n    return x \nend\n\ndin, d, dout = 3, 4, 2 \nmodel = GNN(din, d, dout)                 # step 5\n\ng = rand_graph(10, 30)\nX = randn(Float32, din, 10) \n\ny = model(g, X)  # output size: (dout, g.num_nodes)\ngs = gradient(() -> sum(model(g, X)), Flux.params(model))","category":"page"},{"location":"models/#Implicit-modeling-with-GNNChains","page":"Model Building","title":"Implicit modeling with GNNChains","text":"","category":"section"},{"location":"models/","page":"Model Building","title":"Model Building","text":"While very flexible, the way in which we defined GNN model definition in last section is a bit verbose. In order to simplify things, we provide the GNNChain type. It is very similar  to Flux's well known Chain. It allows to compose layers in a sequential fashion as Chain does, propagating the output of each layer to the next one. In addition, GNNChain  handles propagates the input graph as well, providing it as a first argument to layers subtyping the GNNLayer abstract type. ","category":"page"},{"location":"models/","page":"Model Building","title":"Model Building","text":"Using GNNChain, the previous example becomes","category":"page"},{"location":"models/","page":"Model Building","title":"Model Building","text":"using Flux, Graphs, GraphNeuralNetworks\n\ndin, d, dout = 3, 4, 2 \ng = rand_graph(10, 30)\nX = randn(Float32, din, 10)\n\nmodel = GNNChain(GCNConv(din => d),\n                 BatchNorm(d),\n                 x -> relu.(x),\n                 GCNConv(d => d, relu),\n                 Dropout(0.5),\n                 Dense(d, dout))","category":"page"},{"location":"models/","page":"Model Building","title":"Model Building","text":"The GNNChain only propagates the graph and the node features. More complex scenarios, e.g. when also edge features are updated, have to be handled using the explicit definition of the forward pass. ","category":"page"},{"location":"models/","page":"Model Building","title":"Model Building","text":"A GNNChain opportunely propagates the graph into the branches created by the Flux.Parallel layer:","category":"page"},{"location":"models/","page":"Model Building","title":"Model Building","text":"AddResidual(l) = Parallel(+, identity, l)  # implementing a skip/residual connection\n\nmodel = GNNChain( ResGatedGraphConv(din => d, relu),\n                  AddResidual(ResGatedGraphConv(d => d, relu)),\n                  AddResidual(ResGatedGraphConv(d => d, relu)),\n                  AddResidual(ResGatedGraphConv(d => d, relu)),\n                  GlobalPooling(mean),\n                  Dense(d, dout))\n\ny = model(g, X) # output size: (dout, g.num_graphs)","category":"page"},{"location":"models/#Embedding-a-graph-in-the-model","page":"Model Building","title":"Embedding a graph in the model","text":"","category":"section"},{"location":"models/","page":"Model Building","title":"Model Building","text":"Sometimes it is useful to consider a specific graph as a part of a model instead of  its input. GraphNeuralNetworks.jl provides the WithGraph type to deal with this scenario.","category":"page"},{"location":"models/","page":"Model Building","title":"Model Building","text":"chain = GNNChain(GCNConv(din => d, relu),\n                 GCNConv(d => d))\n\n\ng = rand_graph(10, 30)\n\nmodel = WithGraph(chain, g)\n\nX = randn(Float32, din, 10)\n\n# Pass only X as input, the model already contains the graph.\ny = model(X) ","category":"page"},{"location":"models/","page":"Model Building","title":"Model Building","text":"An example of WithGraph usage is given in the graph neural ODE script in the examples folder.","category":"page"},{"location":"api/pool/","page":"Pooling Layers","title":"Pooling Layers","text":"CurrentModule = GraphNeuralNetworks","category":"page"},{"location":"api/pool/#Pooling-Layers","page":"Pooling Layers","title":"Pooling Layers","text":"","category":"section"},{"location":"api/pool/#Index","page":"Pooling Layers","title":"Index","text":"","category":"section"},{"location":"api/pool/","page":"Pooling Layers","title":"Pooling Layers","text":"Order = [:type, :function]\nPages   = [\"pool.md\"]","category":"page"},{"location":"api/pool/#Docs","page":"Pooling Layers","title":"Docs","text":"","category":"section"},{"location":"api/pool/","page":"Pooling Layers","title":"Pooling Layers","text":"Modules = [GraphNeuralNetworks]\nPages   = [\"layers/pool.jl\"]\nPrivate = false","category":"page"},{"location":"api/pool/#GraphNeuralNetworks.GlobalAttentionPool","page":"Pooling Layers","title":"GraphNeuralNetworks.GlobalAttentionPool","text":"GlobalAttentionPool(fgate, ffeat=identity)\n\nGlobal soft attention layer from the Gated Graph Sequence Neural Networks paper\n\nmathbfu_V = sum_iin V alpha_i f_feat(mathbfx_i)\n\nwhere the coefficients alpha_i are given by a softmax_nodes operation:\n\nalpha_i = frace^f_gate(mathbfx_i)\n                sum_iin V e^f_gate(mathbfx_i)\n\nArguments\n\nfgate: The function f_gate mathbbR^D_in to mathbbR.           It is tipically expressed by a neural network.\nffeat: The function f_feat mathbbR^D_in to mathbbR^D_out.           It is tipically expressed by a neural network.\n\nExamples\n\nchin = 6\nchout = 5    \n\nfgate = Dense(chin, 1)\nffeat = Dense(chin, chout)\npool = GlobalAttentionPool(fgate, ffeat)\n\ng = Flux.batch([GNNGraph(random_regular_graph(10, 4), \n                         ndata=rand(Float32, chin, 10)) \n                for i=1:3])\n\nu = pool(g, g.ndata.x)\n\n@assert size(u) == (chout, g.num_graphs)\n\n\n\n\n\n","category":"type"},{"location":"api/pool/#GraphNeuralNetworks.GlobalPool","page":"Pooling Layers","title":"GraphNeuralNetworks.GlobalPool","text":"GlobalPool(aggr)\n\nGlobal pooling layer for graph neural networks. Takes a graph and feature nodes as inputs and performs the operation\n\nmathbfu_V = square_i in V mathbfx_i\n\nwhere V is the set of nodes of the input graph and  the type of aggregation represented by square is selected by the aggr argument.  Commonly used aggregations are mean, max, and +.\n\nSee also reduce_nodes.\n\nExamples\n\nusing Flux, GraphNeuralNetworks, Graphs\n\npool = GlobalPool(mean)\n\ng = GNNGraph(erdos_renyi(10, 4))\nX = rand(32, 10)\npool(g, X) # => 32x1 matrix\n\n\ng = Flux.batch([GNNGraph(erdos_renyi(10, 4)) for _ in 1:5])\nX = rand(32, 50)\npool(g, X) # => 32x5 matrix\n\n\n\n\n\n","category":"type"},{"location":"api/pool/#GraphNeuralNetworks.TopKPool","page":"Pooling Layers","title":"GraphNeuralNetworks.TopKPool","text":"TopKPool(adj, k, in_channel)\n\nTop-k pooling layer.\n\nArguments\n\nadj: Adjacency matrix  of a graph.\nk: Top-k nodes are selected to pool together.\nin_channel: The dimension of input channel.\n\n\n\n\n\n","category":"type"},{"location":"messagepassing/#Message-Passing","page":"Message Passing","title":"Message Passing","text":"","category":"section"},{"location":"messagepassing/","page":"Message Passing","title":"Message Passing","text":"A generic message passing on graph takes the form","category":"page"},{"location":"messagepassing/","page":"Message Passing","title":"Message Passing","text":"beginaligned\nmathbfm_jto i = phi(mathbfx_i mathbfx_j mathbfe_jto i) \nbarmathbfm_i = square_jin N(i)  mathbfm_jto i \nmathbfx_i = gamma_x(mathbfx_i barmathbfm_i)\nmathbfe_jto i^prime =  gamma_e(mathbfe_j to imathbfm_j to i)\nendaligned","category":"page"},{"location":"messagepassing/","page":"Message Passing","title":"Message Passing","text":"where we refer to phi as to the message function,  and to gamma_x and gamma_e as to the node update and edge update function respectively. The aggregation square is over the neighborhood N(i) of node i,  and it is usually equal either to sum, to max or to a mean operation. ","category":"page"},{"location":"messagepassing/","page":"Message Passing","title":"Message Passing","text":"In GraphNeuralNetworks.jl, the message passing mechanism is exposed by the propagate function. propagate takes care of materializing the node features on each edge, applying the message function, performing the aggregation, and returning barmathbfm.  It is then left to the user to perform further node and edge updates, manipulating arrays of size D_node times num_nodes and    D_edge times num_edges.","category":"page"},{"location":"messagepassing/","page":"Message Passing","title":"Message Passing","text":"propagate is composed of two steps, also available as two independent methods:","category":"page"},{"location":"messagepassing/","page":"Message Passing","title":"Message Passing","text":"apply_edges materializes node features on edges and applyes the message function. \naggregate_neighbors applies a reduction operator on the messages coming from the neighborhood of each node.","category":"page"},{"location":"messagepassing/","page":"Message Passing","title":"Message Passing","text":"The whole propagation mechanism internally relies on the NNlib.gather  and NNlib.scatter methods.","category":"page"},{"location":"messagepassing/#Examples","page":"Message Passing","title":"Examples","text":"","category":"section"},{"location":"messagepassing/#Basic-use-of-apply_edges-and-propagate","page":"Message Passing","title":"Basic use of apply_edges and propagate","text":"","category":"section"},{"location":"messagepassing/","page":"Message Passing","title":"Message Passing","text":"The function apply_edges can be used to broadcast node data on each edge and produce new edge data.","category":"page"},{"location":"messagepassing/","page":"Message Passing","title":"Message Passing","text":"julia> using GraphNeuralNetworks, Graphs, Statistics\n\njulia> g = rand_graph(10, 20)\nGNNGraph:\n    num_nodes = 10\n    num_edges = 20\n\njulia> x = ones(2,10);\n\njulia> z = 2ones(2,10);\n\n# Return an edge features arrays (D × num_edges)\njulia> apply_edges((xi, xj, e) -> xi .+ xj, g, xi=x, xj=z)\n2×20 Matrix{Float64}:\n 3.0  3.0  3.0  3.0  3.0  3.0  3.0  3.0  3.0  3.0  3.0  3.0  3.0  3.0  3.0  3.0  3.0  3.0  3.0  3.0\n 3.0  3.0  3.0  3.0  3.0  3.0  3.0  3.0  3.0  3.0  3.0  3.0  3.0  3.0  3.0  3.0  3.0  3.0  3.0  3.0\n\n# now returning a named tuple\njulia> apply_edges((xi, xj, e) -> (a=xi .+ xj, b=xi .- xj), g, xi=x, xj=z)\n(a = [3.0 3.0 … 3.0 3.0; 3.0 3.0 … 3.0 3.0], b = [-1.0 -1.0 … -1.0 -1.0; -1.0 -1.0 … -1.0 -1.0])\n\n# Here we provide a named tuple input\njulia> apply_edges((xi, xj, e) -> xi.a + xi.b .* xj, g, xi=(a=x,b=z), xj=z)\n2×20 Matrix{Float64}:\n 5.0  5.0  5.0  5.0  5.0  5.0  5.0  5.0  5.0  5.0  5.0  5.0  5.0  5.0  5.0  5.0  5.0  5.0  5.0  5.0\n 5.0  5.0  5.0  5.0  5.0  5.0  5.0  5.0  5.0  5.0  5.0  5.0  5.0  5.0  5.0  5.0  5.0  5.0  5.0  5.0","category":"page"},{"location":"messagepassing/","page":"Message Passing","title":"Message Passing","text":"The function propagate instead performs the apply_edges operation but then also applies a reduction over each node's neighborhood (see aggregate_neighbors).","category":"page"},{"location":"messagepassing/","page":"Message Passing","title":"Message Passing","text":"julia> propagate((xi, xj, e) -> xi .+ xj, g, +, xi=x, xj=z)\n2×10 Matrix{Float64}:\n 3.0  6.0  9.0  9.0  0.0  6.0  6.0  3.0  15.0  3.0\n 3.0  6.0  9.0  9.0  0.0  6.0  6.0  3.0  15.0  3.0\n\n# Previous output can be understood by looking at the degree\njulia> degree(g)\n10-element Vector{Int64}:\n 1\n 2\n 3\n 3\n 0\n 2\n 2\n 1\n 5\n 1","category":"page"},{"location":"messagepassing/#Implementing-a-custom-Graph-Convolutional-Layer","page":"Message Passing","title":"Implementing a custom Graph Convolutional Layer","text":"","category":"section"},{"location":"messagepassing/","page":"Message Passing","title":"Message Passing","text":"Let's implement a simple graph convolutional layer using the message passing framework. The convolution reads ","category":"page"},{"location":"messagepassing/","page":"Message Passing","title":"Message Passing","text":"mathbfx_i = W cdot sum_j in N(i)  mathbfx_j","category":"page"},{"location":"messagepassing/","page":"Message Passing","title":"Message Passing","text":"We will also add a bias and an activation function.","category":"page"},{"location":"messagepassing/","page":"Message Passing","title":"Message Passing","text":"using Flux, Graphs, GraphNeuralNetworks\n\nstruct GCN{A<:AbstractMatrix, B, F} <: GNNLayer\n    weight::A\n    bias::B\n    σ::F\nend\n\nFlux.@functor GCN # allow collecting params, gpu movement, etc...\n\nfunction GCN(ch::Pair{Int,Int}, σ=identity)\n    in, out = ch\n    W = Flux.glorot_uniform(out, in)\n    b = zeros(Float32, out)\n    GCN(W, b, σ)\nend\n\nfunction (l::GCN)(g::GNNGraph, x::AbstractMatrix{T}) where T\n    @assert size(x, 2) == g.num_nodes\n\n    # Computes messages from source/neighbour nodes (j) to target/root nodes (i).\n    # The message function will have to handle matrices of size (*, num_edges).\n    # In this simple case we just let the neighbor features go through.\n    message(xi, xj, e) = xj \n\n    # The + operator gives the sum aggregation.\n    # `mean`, `max`, `min`, and `*` are other possibilities.\n    x = propagate(message, g, +, xj=x) \n\n    return l.σ.(l.weight * x .+ l.bias)\nend","category":"page"},{"location":"messagepassing/","page":"Message Passing","title":"Message Passing","text":"See the GATConv implementation here for a more complex example.","category":"page"},{"location":"messagepassing/#Built-in-message-functions","page":"Message Passing","title":"Built-in message functions","text":"","category":"section"},{"location":"messagepassing/","page":"Message Passing","title":"Message Passing","text":"In order to exploit optimized specializations of the propagate, it is recommended  to use built-in message functions such as copy_xj whenever possible. ","category":"page"},{"location":"tutorials/gnn_intro_pluto/","page":"Intro to Graph Neural Networks","title":"Intro to Graph Neural Networks","text":"<style>\n    table {\n        display: table !important;\n        margin: 2rem auto !important;\n        border-top: 2pt solid rgba(0,0,0,0.2);\n        border-bottom: 2pt solid rgba(0,0,0,0.2);\n    }\n\n    pre, div {\n        margin-top: 1.4rem !important;\n        margin-bottom: 1.4rem !important;\n    }\n\n    .code-output {\n        padding: 0.7rem 0.5rem !important;\n    }\n\n    .admonition-body {\n        padding: 0em 1.25em !important;\n    }\n</style>\n\n<!-- PlutoStaticHTML.Begin -->\n<!--\n    # This information is used for caching.\n    [PlutoStaticHTML.State]\n    input_sha = \"6257807b5880dcfd63d4b336e864594dd022a5023e8ca44680a091da7a4bc7a1\"\n    julia_version = \"1.7.3\"\n-->\n\n<div class=\"markdown\"><h1>Introduction: Hands-on Graph Neural Networks</h1>\n<p><em>This Pluto noteboook is a julia adaptation of the Pytorch Geometric tutorials that can be found <a href=\"https://pytorch-geometric.readthedocs.io/en/latest/notes/colabs.html\">here</a>.</em></p>\n<p>Recently, deep learning on graphs has emerged to one of the hottest research fields in the deep learning community. Here, <strong>Graph Neural Networks &#40;GNNs&#41;</strong> aim to generalize classical deep learning concepts to irregular structured data &#40;in contrast to images or texts&#41; and to enable neural networks to reason about objects and their relations.</p>\n<p>This is done by following a simple <strong>neural message passing scheme</strong>, where node features <span class=\"tex\">$\\mathbf&#123;x&#125;_i^&#123;&#40;\\ell&#41;&#125;$</span> of all nodes <span class=\"tex\">$i \\in \\mathcal&#123;V&#125;$</span> in a graph <span class=\"tex\">$\\mathcal&#123;G&#125; &#61; &#40;\\mathcal&#123;V&#125;, \\mathcal&#123;E&#125;&#41;$</span> are iteratively updated by aggregating localized information from their neighbors <span class=\"tex\">$\\mathcal&#123;N&#125;&#40;i&#41;$</span>:</p>\n<p class=\"tex\">$$\\mathbf&#123;x&#125;_i^&#123;&#40;\\ell &#43; 1&#41;&#125; &#61; f^&#123;&#40;\\ell &#43; 1&#41;&#125;_&#123;\\theta&#125; \\left&#40; \\mathbf&#123;x&#125;_i^&#123;&#40;\\ell&#41;&#125;, \\left\\&#123; \\mathbf&#123;x&#125;_j^&#123;&#40;\\ell&#41;&#125; : j \\in \\mathcal&#123;N&#125;&#40;i&#41; \\right\\&#125; \\right&#41;$$</p>\n<p>This tutorial will introduce you to some fundamental concepts regarding deep learning on graphs via Graph Neural Networks based on the <strong><a href=\"https://github.com/CarloLucibello/GraphNeuralNetworks.jl\">GraphNeuralNetworks.jl library</a></strong>. GNN.jl is an extension library to the popular deep learning framework <a href=\"https://fluxml.ai/Flux.jl/stable/\">Flux.jl</a>, and consists of various methods and utilities to ease the implementation of Graph Neural Networks.</p>\n<p>Let&#39;s first import the packages we need:</p>\n</div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    using Pkg\n    Pkg.activate(; temp=true)\n    packages = [\n        PackageSpec(; path=joinpath(@__DIR__,\"..\",\"..\",\"..\")),\n        PackageSpec(; name=\"Flux\", version=\"0.13\"),\n        PackageSpec(; name=\"MLDatasets\", version=\"0.7\"),\n        PackageSpec(; name=\"GraphMakie\"),\n        PackageSpec(; name=\"Graphs\"),\n        PackageSpec(; name=\"CairoMakie\"),\n        PackageSpec(; name=\"PlutoUI\"),\n    ]\n    Pkg.add(packages)\nend</code></pre>\n\n\n<pre class='language-julia'><code class='language-julia'>begin\n    using Flux\n    using Flux: onecold, onehotbatch, logitcrossentropy\n    using GraphNeuralNetworks\n    import MLDatasets\n    using LinearAlgebra, Random, Statistics\n    import GraphMakie\n    import CairoMakie as Makie\n    using Graphs\n    using PlutoUI\n    ENV[\"DATADEPS_ALWAYS_ACCEPT\"] = \"true\"  # don't ask for dataset download confirmation\n    Random.seed!(17) # for reproducibility\nend;</code></pre>\n\n\n\n<div class=\"markdown\"><p>Following <a href=\"https://arxiv.org/abs/1609.02907\">Kipf et al. &#40;2017&#41;</a>, let&#39;s dive into the world of GNNs by looking at a simple graph-structured example, the well-known <a href=\"https://en.wikipedia.org/wiki/Zachary&#37;27s_karate_club\"><strong>Zachary&#39;s karate club network</strong></a>. This graph describes a social network of 34 members of a karate club and documents links between members who interacted outside the club. Here, we are interested in detecting communities that arise from the member&#39;s interaction.</p>\n<p>GNN.jl provides utilities to convert <a href=\"https://github.com/JuliaML/MLDatasets.jl\">MLDatasets.jl</a>&#39;s datasets to its own type:</p>\n</div>\n\n<pre class='language-julia'><code class='language-julia'>dataset = MLDatasets.KarateClub()</code></pre>\n<pre id='var-dataset' class='code-output documenter-example-output'>dataset KarateClub:\n  metadata    =>    Dict{String, Any} with 0 entries\n  graphs      =>    1-element Vector{MLDatasets.Graph}</pre>\n\n\n<div class=\"markdown\"><p>After initializing the <code>KarateClub</code> dataset, we first can inspect some of its properties. For example, we can see that this dataset holds exactly <strong>one graph</strong>. Furthermore, the graph holds exactly <strong>4 classes</strong>, which represent the community each node belongs to.</p>\n</div>\n\n<pre class='language-julia'><code class='language-julia'>karate = dataset[1]</code></pre>\n<pre id='var-karate' class='code-output documenter-example-output'>Graph:\n  num_nodes   =>    34\n  num_edges   =>    156\n  edge_index  =>    (\"156-element Vector{Int64}\", \"156-element Vector{Int64}\")\n  node_data   =>    (labels_clubs = \"34-element Vector{Int64}\", labels_comm = \"34-element Vector{Int64}\")\n  edge_data   =>    nothing</pre>\n\n<pre class='language-julia'><code class='language-julia'>karate.node_data.labels_comm</code></pre>\n<pre id='var-hash163250' class='code-output documenter-example-output'>34-element Vector{Int64}:\n 1\n 1\n 1\n 1\n 3\n 3\n 3\n ⋮\n 2\n 0\n 0\n 2\n 0\n 0</pre>\n\n\n<div class=\"markdown\"><p>Now we convert the single-graph dataset to a <code>GNNGraph</code>. Moreover, we add a an array of node features, a <strong>34-dimensional feature vector</strong>  for each node which uniquely describes the members of the karate club. We also add a training mask selecting the nodes to be used for training in our semi-supervised node classification task.</p>\n</div>\n\n<pre class='language-julia'><code class='language-julia'>begin \n    # convert a MLDataset.jl's dataset to a GNNGraphs (or a collection of graphs)\n    g = mldataset2gnngraph(dataset)\n    \n    x = zeros(Float32, g.num_nodes, g.num_nodes)\n    x[diagind(x)] .= 1\n    \n    train_mask = [ true, false, false, false,  true, false, false, false,  true,\n        false, false, false, false, false, false, false, false, false, false, false,\n        false, false, false, false,  true, false, false, false, false, false,\n        false, false, false, false]\n\n    labels = g.ndata.labels_comm\n    y = onehotbatch(labels, 0:3)\n    \n    g = GNNGraph(g, ndata=(; x, y, train_mask))\nend</code></pre>\n<pre id='var-labels' class='code-output documenter-example-output'>GNNGraph:\n    num_nodes = 34\n    num_edges = 156\n    ndata:\n        x => 34×34 Matrix{Float32}\n        y => 4×34 OneHotMatrix(::Vector{UInt32}) with eltype Bool\n        train_mask => 34-element Vector{Bool}</pre>\n\n\n<div class=\"markdown\"><p>Let&#39;s now look at the underlying graph in more detail:</p>\n</div>\n\n<pre class='language-julia'><code class='language-julia'>with_terminal() do\n    # Gather some statistics about the graph.\n    println(\"Number of nodes: $(g.num_nodes)\")\n    println(\"Number of edges: $(g.num_edges)\")\n    println(\"Average node degree: $(g.num_edges / g.num_nodes)\")\n    println(\"Number of training nodes: $(sum(g.ndata.train_mask))\")\n    println(\"Training node label rate: $(mean(g.ndata.train_mask))\")\n    # println(\"Has isolated nodes: $(has_isolated_nodes(g))\")\n    println(\"Has self-loops: $(has_self_loops(g))\")\n    println(\"Is undirected: $(is_bidirected(g))\")\nend</code></pre>\n<pre id=\"plutouiterminal\">\nNumber of nodes: 34\nNumber of edges: 156\nAverage node degree: 4.588235294117647\nNumber of training nodes: 4\nTraining node label rate: 0.11764705882352941\nHas self-loops: false\nIs undirected: true\n</pre>\n\n\n\n<div class=\"markdown\"><p>Each graph in GNN.jl is represented by a  <code>GNNGraph</code> object, which holds all the information to describe its graph representation. We can print the data object anytime via <code>print&#40;g&#41;</code> to receive a short summary about its attributes and their shapes.</p>\n<p>The  <code>g</code> object holds 3 attributes:</p>\n<ul>\n<li><p><code>g.ndata</code> contains node related information;</p>\n</li>\n<li><p><code>g.edata</code> holds edge-related information;</p>\n</li>\n<li><p><code>g.gdata</code>: this stores the global data, therefore neither node nor edge specific features.</p>\n</li>\n</ul>\n<p>These attributes are <code>NamedTuples</code> that can store multiple feature arrays: we can access a specific set of features e.g. <code>x</code>, with <code>g.ndata.x</code>.</p>\n<p>In our task, <code>g.ndata.train_mask</code> describes for which nodes we already know their community assigments. In total, we are only aware of the ground-truth labels of 4 nodes &#40;one for each community&#41;, and the task is to infer the community assignment for the remaining nodes.</p>\n<p>The <code>g</code> object also provides some <strong>utility functions</strong> to infer some basic properties of the underlying graph. For example, we can easily infer whether there exists isolated nodes in the graph &#40;<em>i.e.</em> there exists no edge to any node&#41;, whether the graph contains self-loops &#40;<em>i.e.</em>, <span class=\"tex\">$&#40;v, v&#41; \\in \\mathcal&#123;E&#125;$</span>&#41;, or whether the graph is bidirected &#40;<em>i.e.</em>, for each edge <span class=\"tex\">$&#40;v, w&#41; \\in \\mathcal&#123;E&#125;$</span> there also exists the edge <span class=\"tex\">$&#40;w, v&#41; \\in \\mathcal&#123;E&#125;$</span>&#41;.</p>\n<p>Let us now inspect the <code>edge_index</code> method:</p>\n</div>\n\n<pre class='language-julia'><code class='language-julia'>edge_index(g)</code></pre>\n<pre id='var-hash182682' class='code-output documenter-example-output'>([1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  34, 34, 34, 34, 34, 34, 34, 34, 34, 34], [2, 3, 4, 5, 6, 7, 8, 9, 11, 12  …  21, 23, 24, 27, 28, 29, 30, 31, 32, 33])</pre>\n\n\n<div class=\"markdown\"><p>By printing <code>edge_index&#40;g&#41;</code>, we can understand how GNN.jl represents graph connectivity internally. We can see that for each edge, <code>edge_index</code> holds a tuple of two node indices, where the first value describes the node index of the source node and the second value describes the node index of the destination node of an edge.</p>\n<p>This representation is known as the <strong>COO format &#40;coordinate format&#41;</strong> commonly used for representing sparse matrices. Instead of holding the adjacency information in a dense representation <span class=\"tex\">$\\mathbf&#123;A&#125; \\in \\&#123; 0, 1 \\&#125;^&#123;|\\mathcal&#123;V&#125;| \\times |\\mathcal&#123;V&#125;|&#125;$</span>, GNN.jl represents graphs sparsely, which refers to only holding the coordinates/values for which entries in <span class=\"tex\">$\\mathbf&#123;A&#125;$</span> are non-zero.</p>\n<p>Importantly, GNN.jl does not distinguish between directed and undirected graphs, and treats undirected graphs as a special case of directed graphs in which reverse edges exist for every entry in the edge_index.</p>\n<p>Since a <code>GNNGraph</code> is an <code>AbstractGraph</code> from the <code>Graphs.jl</code> library, it supports graph algorithms and visualization tools from the wider julia graph ecosystem:</p>\n</div>\n\n<pre class='language-julia'><code class='language-julia'>GraphMakie.graphplot(g |&gt; to_unidirected, node_size=20, node_color=labels, arrow_show=false) </code></pre>\n<img src=\"data:image/png;base64,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\">\n\n","category":"page"},{"location":"tutorials/gnn_intro_pluto/#Implementing-Graph-Neural-Networks","page":"Intro to Graph Neural Networks","title":"Implementing Graph Neural Networks","text":"","category":"section"},{"location":"tutorials/gnn_intro_pluto/","page":"Intro to Graph Neural Networks","title":"Intro to Graph Neural Networks","text":"<div class=\"markdown\">\n\n<p>After learning about GNN.jl&#39;s data handling, it&#39;s time to implement our first Graph Neural Network&#33;</p>\n<p>For this, we will use on of the most simple GNN operators, the <strong>GCN layer</strong> &#40;<a href=\"https://arxiv.org/abs/1609.02907\">Kipf et al. &#40;2017&#41;</a>&#41;, which is defined as</p>\n<p class=\"tex\">$$\\mathbf&#123;x&#125;_v^&#123;&#40;\\ell &#43; 1&#41;&#125; &#61; \\mathbf&#123;W&#125;^&#123;&#40;\\ell &#43; 1&#41;&#125; \\sum_&#123;w \\in \\mathcal&#123;N&#125;&#40;v&#41; \\, \\cup \\, \\&#123; v \\&#125;&#125; \\frac&#123;1&#125;&#123;c_&#123;w,v&#125;&#125; \\cdot \\mathbf&#123;x&#125;_w^&#123;&#40;\\ell&#41;&#125;$$</p>\n<p>where <span class=\"tex\">$\\mathbf&#123;W&#125;^&#123;&#40;\\ell &#43; 1&#41;&#125;$</span> denotes a trainable weight matrix of shape <code>&#91;num_output_features, num_input_features&#93;</code> and <span class=\"tex\">$c_&#123;w,v&#125;$</span> refers to a fixed normalization coefficient for each edge.</p>\n<p>GNN.jl implements this layer via <code>GCNConv</code>, which can be executed by passing in the node feature representation <code>x</code> and the COO graph connectivity representation <code>edge_index</code>.</p>\n<p>With this, we are ready to create our first Graph Neural Network by defining our network architecture:</p>\n</div>\n\n<pre class='language-julia'><code class='language-julia'>begin \n    struct GCN\n        layers::NamedTuple\n    end\n    \n    Flux.@functor GCN # provides parameter collection, gpu movement and more\n\n    function GCN(num_features, num_classes)\n        layers = (conv1 = GCNConv(num_features =&gt; 4),\n                  conv2 = GCNConv(4 =&gt; 4),\n                  conv3 = GCNConv(4 =&gt; 2),\n                  classifier = Dense(2, num_classes))\n        return GCN(layers)\n    end\n\n    function (gcn::GCN)(g::GNNGraph, x::AbstractMatrix)\n        l = gcn.layers\n        x = l.conv1(g, x)\n        x = tanh.(x)\n        x = l.conv2(g, x)\n        x = tanh.(x)\n        x = l.conv3(g, x)\n        x = tanh.(x)  # Final GNN embedding space.\n        out = l.classifier(x)\n        # Apply a final (linear) classifier.\n        return out, x\n    end\nend</code></pre>\n\n\n\n<div class=\"markdown\"><p>Here, we first initialize all of our building blocks in the constructor and define the computation flow of our network in the call method. We first define and stack <strong>three graph convolution layers</strong>, which corresponds to aggregating 3-hop neighborhood information around each node &#40;all nodes up to 3 &quot;hops&quot; away&#41;. In addition, the <code>GCNConv</code> layers reduce the node feature dimensionality to <span class=\"tex\">$2$</span>, <em>i.e.</em>, <span class=\"tex\">$34 \\rightarrow 4 \\rightarrow 4 \\rightarrow 2$</span>. Each <code>GCNConv</code> layer is enhanced by a <code>tanh</code> non-linearity.</p>\n<p>After that, we apply a single linear transformation &#40;<code>Flux.Dense</code> that acts as a classifier to map our nodes to 1 out of the 4 classes/communities.</p>\n<p>We return both the output of the final classifier as well as the final node embeddings produced by our GNN. We proceed to initialize our final model via <code>GCN&#40;&#41;</code>, and printing our model produces a summary of all its used sub-modules.</p>\n<h3>Embedding the Karate Club Network</h3>\n<p>Let&#39;s take a look at the node embeddings produced by our GNN. Here, we pass in the initial node features <code>x</code> and the graph  information <code>g</code> to the model, and visualize its 2-dimensional embedding.</p>\n</div>\n\n<pre class='language-julia'><code class='language-julia'>begin \n    num_features = 34\n    num_classes = 4\n    gcn = GCN(num_features, num_classes)\nend</code></pre>\n<pre id='var-gcn' class='code-output documenter-example-output'>GCN((conv1 = GCNConv(34 => 4), conv2 = GCNConv(4 => 4), conv3 = GCNConv(4 => 2), classifier = Dense(2 => 4)))</pre>\n\n<pre class='language-julia'><code class='language-julia'>_, h = gcn(g, g.ndata.x)</code></pre>\n<pre id='var-h' class='code-output documenter-example-output'>(Float32[-0.08970785 -0.06863403 … -0.14836365 -0.16208793; 0.049868643 0.05627172 … 0.06776632 0.07252246; 0.022253193 0.031585023 … 0.024983434 0.026079046; -0.035681576 -0.009579982 … -0.07339759 -0.081666455], Float32[0.05733033 0.067928 … 0.07527842 0.08023294; -0.056702822 -0.026260292 … -0.10767874 -0.1190689])</pre>\n\n<pre class='language-julia'><code class='language-julia'>function visualize_embeddings(h; colors=nothing)\n    xs = h[1,:] |&gt; vec\n    ys = h[2,:] |&gt; vec\n    Makie.scatter(xs, ys, color=labels, markersize= 20)\nend</code></pre>\n<pre id='var-visualize_embeddings' class='code-output documenter-example-output'>visualize_embeddings (generic function with 1 method)</pre>\n\n<pre class='language-julia'><code class='language-julia'>visualize_embeddings(h, colors=labels)</code></pre>\n<img src=\"data:image/png;base64,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9mQyOewvHz3u5JEjR/bu3Xv4Q/r7+8vKyrKcmvEl4pamGYu+55CJTHbV7ZTjG6DQpFKpxYsXx2Kx8vLyWCy2atWqUUw+/PDDH9mEJUuWjEl8xoWIW5pmLPqeQyYy31W3U45LwSo8t912WzKZ3Lp1a19f34MPPhiPxx977LGRTt51113Tp09/4kNeeumlMXwSnOAibmmaseh7DpnIfFfdTjkuBavA9Pb2Tp48+eabbx585OKLL168ePFIJ6+77rorr7wy22kZnyJuaZqx6HsOmch8VwfcThmCD7kXmNdff/2tt95atGjR4COLFi3aunXrSCd37dp1xhlnNDU1rVu37sknn+zu7s52csaPiFuaZiz6nkMmMt/VmNspQyjJdQBGZs+ePbFYrKamZvCR2tra/fv39/b2lpSURJ9sa2trbW194IEHpkyZ0tbWVldX98QTT8yePXusngcnsohbmmYs+p5DJjLfVbdThuIVrAJz8ODBWCyWTCYHH0kmkwMDAwcOHIg+mUqlKioqli5dun///pdffnnnzp39/f1LliwZk2fAiS/ilqYZi77nkInMd9XtlKEoWPnumWeeKfnA7bffPmnSpFgs1tnZOThw6NCheDxeUVHxkYNpJsvLy1955ZV77723uLg4FovV19evXLly27Zt/vciiIhbmmYs+p5DJjLfVbdThuLF9nw3f/78F1988eifq6urU6lU7IPXq4/as2dPdXV1aWnpRw7W1tZGnIzFYvX19bFYbN++fZWVlaGfAeNOxN1LMzai7YVRy3xXj/073U45yitY+S6RSMz9QE1NTV1dXX19fXNz8+BAc3PzggULjj2YZrK5uXny5MktLS2Dl3bs2FFeXj5z5sxsPhXGi4hbmmYs+p5DJjLfVbdThpTDbzAyOmvWrEkkEs8+++z777+/YcOGeDy+cePGo5fuv//+a665JpVKpZ9MpVLTpk1rbGzcvHlzR0fH448/XllZeeutt+bsKXHCibilacbSXIKAMtxVt1OGomAVnr6+vmXLlhUVFZWWlpaVla1fv37w0tFPVnZ2dg472draOvgll6KiohUrVgzWMshcxC1NM5bmEgSU+a66nXJc8YGBgRy9dkZGOjo62tvbzzrrrGF/49VQk/39/W1tbZ2dnbNmzUokEtkMyzgVcUvTjEXfc8hEhrvqdsqxFCwAgMB8yB0AIDAFCwAgMAULACAwBQsAIDAFCwAgMAULACAwBQsAIDAFCwAgMAULACAwBQsAIDAFCwAgMAULACAwBQsAIDAFCwAgMAULACAwBQsAIDAFCwAgsP8BtaO5q4WFnF4AAAAASUVORK5CYII=\">\n\n\n<div class=\"markdown\"><p>Remarkably, even before training the weights of our model, the model produces an embedding of nodes that closely resembles the community-structure of the graph. Nodes of the same color &#40;community&#41; are already closely clustered together in the embedding space, although the weights of our model are initialized <strong>completely at random</strong> and we have not yet performed any training so far&#33; This leads to the conclusion that GNNs introduce a strong inductive bias, leading to similar embeddings for nodes that are close to each other in the input graph.</p>\n<h3>Training on the Karate Club Network</h3>\n<p>But can we do better? Let&#39;s look at an example on how to train our network parameters based on the knowledge of the community assignments of 4 nodes in the graph &#40;one for each community&#41;:</p>\n<p>Since everything in our model is differentiable and parameterized, we can add some labels, train the model and observse how the embeddings react. Here, we make use of a semi-supervised or transductive learning procedure: We simply train against one node per class, but are allowed to make use of the complete input graph data.</p>\n<p>Training our model is very similar to any other Flux model. In addition to defining our network architecture, we define a loss criterion &#40;here, <code>logitcrossentropy</code> and initialize a stochastic gradient optimizer &#40;here, <code>Adam</code>&#41;. After that, we perform multiple rounds of optimization, where each round consists of a forward and backward pass to compute the gradients of our model parameters w.r.t. to the loss derived from the forward pass. If you are not new to Flux, this scheme should appear familar to you. </p>\n<p>Note that our semi-supervised learning scenario is achieved by the following line:</p>\n<pre><code>loss &#61; logitcrossentropy&#40;ŷ&#91;:,train_mask&#93;, y&#91;:,train_mask&#93;&#41;</code></pre>\n<p>While we compute node embeddings for all of our nodes, we <strong>only make use of the training nodes for computing the loss</strong>. Here, this is implemented by filtering the output of the classifier <code>out</code> and ground-truth labels <code>data.y</code> to only contain the nodes in the <code>train_mask</code>.</p>\n<p>Let us now start training and see how our node embeddings evolve over time &#40;best experienced by explicitely running the code&#41;:</p>\n</div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    model = GCN(num_features, num_classes)\n    ps = Flux.params(model)\n    opt = Adam(1e-2)\n    epochs = 2000\n\n    emb = h\n    function report(epoch, loss, h)\n        # p = visualize_embeddings(h)\n        @info (; epoch, loss)\n    end\n    \n    report(0, 10., emb)\n    for epoch in 1:epochs\n        loss, gs = Flux.withgradient(ps) do\n            ŷ, emb = model(g, g.ndata.x)\n            logitcrossentropy(ŷ[:,train_mask], y[:,train_mask])\n        end\n        \n        Flux.Optimise.update!(opt, ps, gs)\n        if epoch % 200 == 0\n            report(epoch, loss, emb)\n        end\n    end\nend</code></pre>\n\n\n<pre class='language-julia'><code class='language-julia'>ŷ, emb_final = model(g, g.ndata.x)</code></pre>\n<pre id='var-emb_final' class='code-output documenter-example-output'>(Float32[-8.980148 -7.3440228 … 8.61153 8.587432; 6.336263 4.9611435 … -6.650339 -6.6347194; -1.0895905 0.46424112 … 1.2218909 1.2360924; -0.60901105 -1.7747369 … 1.4859929 1.465473], Float32[0.9967612 0.9978396 … -0.9997212 -0.9945635; -0.99583834 -0.59929174 … 0.9999969 0.999999])</pre>\n\n<pre class='language-julia'><code class='language-julia'># train accuracy\nmean(onecold(ŷ[:, train_mask]) .== onecold(y[:, train_mask]))</code></pre>\n<pre id='var-hash730898' class='code-output documenter-example-output'>1.0</pre>\n\n<pre class='language-julia'><code class='language-julia'># test accuracy\nmean(onecold(ŷ[:, .!train_mask]) .== onecold(y[:, .!train_mask]))</code></pre>\n<pre id='var-hash475999' class='code-output documenter-example-output'>0.8</pre>\n\n<pre class='language-julia'><code class='language-julia'>visualize_embeddings(emb_final, colors=labels)</code></pre>\n<img src=\"data:image/png;base64,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\">\n\n\n<div class=\"markdown\"><p>As one can see, our 3-layer GCN model manages to linearly separating the communities and classifying most of the nodes correctly.</p>\n<p>Furthermore, we did this all with a few lines of code, thanks to the GraphNeuralNetworks.jl which helped us out with data handling and GNN implementations.</p>\n</div>\n\n<!-- PlutoStaticHTML.End -->","category":"page"},{"location":"tutorials/gnn_intro_pluto/","page":"Intro to Graph Neural Networks","title":"Intro to Graph Neural Networks","text":"EditURL = \"https://github.com/CarloLucibello/GraphNeuralNetworks.jl/blob/master/docs/src/tutorials/gnn_intro_pluto.jl\"","category":"page"},{"location":"api/basic/","page":"Basic Layers","title":"Basic Layers","text":"CurrentModule = GraphNeuralNetworks","category":"page"},{"location":"api/basic/#Basic-Layers","page":"Basic Layers","title":"Basic Layers","text":"","category":"section"},{"location":"api/basic/#Index","page":"Basic Layers","title":"Index","text":"","category":"section"},{"location":"api/basic/","page":"Basic Layers","title":"Basic Layers","text":"Order = [:type, :function]\nModules = [GraphNeuralNetworks]\nPages = [\"basic.md\"]","category":"page"},{"location":"api/basic/#Docs","page":"Basic Layers","title":"Docs","text":"","category":"section"},{"location":"api/basic/","page":"Basic Layers","title":"Basic Layers","text":"Modules = [GraphNeuralNetworks]\nPages   = [\"layers/basic.jl\"]\nPrivate = false","category":"page"},{"location":"api/basic/#GraphNeuralNetworks.DotDecoder","page":"Basic Layers","title":"GraphNeuralNetworks.DotDecoder","text":"DotDecoder()\n\nA graph neural network layer that  for given input graph g and node features x, returns the dot product x_i ⋅ xj on each edge. \n\nExamples\n\njulia> g = rand_graph(5, 6)\nGNNGraph:\n    num_nodes = 5\n    num_edges = 6\n\njulia> dotdec = DotDecoder()\nDotDecoder()\n\njulia> dotdec(g, rand(2, 5))\n1×6 Matrix{Float64}:\n 0.345098  0.458305  0.106353  0.345098  0.458305  0.106353\n\n\n\n\n\n","category":"type"},{"location":"api/basic/#GraphNeuralNetworks.GNNChain","page":"Basic Layers","title":"GraphNeuralNetworks.GNNChain","text":"GNNChain(layers...)\nGNNChain(name = layer, ...)\n\nCollects multiple layers / functions to be called in sequence on given input graph and input node features. \n\nIt allows to compose layers in a sequential fashion as Flux.Chain does, propagating the output of each layer to the next one. In addition, GNNChain handles the input graph as well, providing it  as a first argument only to layers subtyping the GNNLayer abstract type. \n\nGNNChain supports indexing and slicing, m[2] or m[1:end-1], and if names are given, m[:name] == m[1] etc.\n\nExamples\n\njulia> using Flux, GraphNeuralNetworks\n\njulia> m = GNNChain(GCNConv(2=>5), \n                    BatchNorm(5), \n                    x -> relu.(x), \n                    Dense(5, 4))\nGNNChain(GCNConv(2 => 5), BatchNorm(5), #7, Dense(5 => 4))\n\njulia> x = randn(Float32, 2, 3);\n\njulia> g = rand_graph(3, 6)\nGNNGraph:\n    num_nodes = 3\n    num_edges = 6\n\njulia> m(g, x)\n4×3 Matrix{Float32}:\n    -0.795592  -0.795592  -0.795592\n    -0.736409  -0.736409  -0.736409\n    0.994925   0.994925   0.994925\n    0.857549   0.857549   0.857549\n\njulia> m2 = GNNChain(enc = m, \n                     dec = DotDecoder())\nGNNChain(enc = GNNChain(GCNConv(2 => 5), BatchNorm(5), #7, Dense(5 => 4)), dec = DotDecoder())\n\njulia> m2(g, x)\n1×6 Matrix{Float32}:\n 2.90053  2.90053  2.90053  2.90053  2.90053  2.90053\n\njulia> m2[:enc](g, x) == m(g, x)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api/basic/#GraphNeuralNetworks.GNNLayer","page":"Basic Layers","title":"GraphNeuralNetworks.GNNLayer","text":"abstract type GNNLayer end\n\nAn abstract type from which graph neural network layers are derived.\n\nSee also GNNChain.\n\n\n\n\n\n","category":"type"},{"location":"api/basic/#GraphNeuralNetworks.WithGraph","page":"Basic Layers","title":"GraphNeuralNetworks.WithGraph","text":"WithGraph(model, g::GNNGraph; traingraph=false)\n\nA type wrapping the model and tying it to the graph g. In the forward pass, can only take feature arrays as inputs, returning model(g, x...; kws...).\n\nIf traingraph=false, the graph's parameters, won't be collected when calling Flux.params on a WithGraph object.\n\nExamples\n\ng = GNNGraph([1,2,3], [2,3,1])\nx = rand(Float32, 2, 3)\nmodel = SAGEConv(2 => 3)\nwg = WithGraph(model, g)\n# No need to feed the graph to `wg`\n@assert wg(x) == model(g, x)\n\ng2 = GNNGraph([1,1,2,3], [2,4,1,1])\nx2 = rand(Float32, 2, 4)\n# WithGraph will ignore the internal graph if fed with a new one. \n@assert wg(g2, x2) == model(g2, x2)\n\n\n\n\n\n","category":"type"},{"location":"api/conv/","page":"Convolutional Layers","title":"Convolutional Layers","text":"CurrentModule = GraphNeuralNetworks","category":"page"},{"location":"api/conv/#Convolutional-Layers","page":"Convolutional Layers","title":"Convolutional Layers","text":"","category":"section"},{"location":"api/conv/","page":"Convolutional Layers","title":"Convolutional Layers","text":"Many different types of graphs convolutional layers have been proposed in the literature. Choosing the right layer for your application could involve a lot of exploration.  Some of the most commonly used layers are the GCNConv and the GATv2Conv. Multiple graph convolutional layers are typically stacked together to create a graph neural network model (see GNNChain).","category":"page"},{"location":"api/conv/","page":"Convolutional Layers","title":"Convolutional Layers","text":"The table below lists all graph convolutional layers implemented in the GraphNeuralNetworks.jl. It also highlights the presence of some additional capabilities with respect to basic message passing:","category":"page"},{"location":"api/conv/","page":"Convolutional Layers","title":"Convolutional Layers","text":"Sparse Ops: implements message passing as multiplication by sparse adjacency matrix instead of the gather/scatter mechanism. This can lead to better cpu performances but it is not supported on gpu yet. \nEdge Weights: supports scalar weights (or equivalently scalar features) on edges. \nEdge Features: supports feature vectors on edges.","category":"page"},{"location":"api/conv/","page":"Convolutional Layers","title":"Convolutional Layers","text":"Layer Sparse Ops Edge Weight Edge Features\nAGNNConv   ✓\nCGConv   \nChebConv   \nEdgeConv   \nGATConv   ✓\nGATv2Conv   ✓\nGatedGraphConv ✓  \nGCNConv ✓ ✓ \nGINConv ✓  \nGMMConv   ✓\nGraphConv ✓  \nMEGNetConv   ✓\nNNConv   ✓\nResGatedGraphConv   \nSAGEConv ✓  ","category":"page"},{"location":"api/conv/#Docs","page":"Convolutional Layers","title":"Docs","text":"","category":"section"},{"location":"api/conv/","page":"Convolutional Layers","title":"Convolutional Layers","text":"Modules = [GraphNeuralNetworks]\nPages   = [\"layers/conv.jl\"]\nPrivate = false","category":"page"},{"location":"api/conv/#GraphNeuralNetworks.AGNNConv","page":"Convolutional Layers","title":"GraphNeuralNetworks.AGNNConv","text":"AGNNConv(init_beta=1f0)\n\nAttention-based Graph Neural Network layer from paper Attention-based Graph Neural Network for Semi-Supervised Learning.\n\nThe forward pass is given by\n\nmathbfx_i = sum_j in N(i) cup i alpha_ij W mathbfx_j\n\nwhere the attention coefficients alpha_ij are given by\n\nalpha_ij =frace^beta cos(mathbfx_i mathbfx_j)\n                  sum_je^beta cos(mathbfx_i mathbfx_j)\n\nwith the cosine distance defined by\n\ncos(mathbfx_i mathbfx_j) = \n  fracmathbfx_i cdot mathbfx_jlVertmathbfx_irVert lVertmathbfx_jrVert\n\nand beta a trainable parameter.\n\nArguments\n\ninit_beta: The initial value of beta.\n\n\n\n\n\n","category":"type"},{"location":"api/conv/#GraphNeuralNetworks.CGConv","page":"Convolutional Layers","title":"GraphNeuralNetworks.CGConv","text":"CGConv((in, ein) => out, f, act=identity; bias=true, init=glorot_uniform, residual=false)\nCGConv(in => out, ...)\n\nThe crystal graph convolutional layer from the paper Crystal Graph Convolutional Neural Networks for an Accurate and Interpretable Prediction of Material Properties. Performs the operation\n\nmathbfx_i = mathbfx_i + sum_jin N(i)sigma(W_f mathbfz_ij + mathbfb_f) act(W_s mathbfz_ij + mathbfb_s)\n\nwhere mathbfz_ij  is the node and edge features concatenation  mathbfx_i mathbfx_j mathbfe_jto i  and sigma is the sigmoid function. The residual mathbfx_i is added only if residual=true and the output size is the same  as the input size.\n\nArguments\n\nin: The dimension of input node features.\nein: The dimension of input edge features. \n\nIf ein is not given, assumes that no edge features are passed as input in the forward pass.\n\nout: The dimension of output node features.\nact: Activation function.\nbias: Add learnable bias.\ninit: Weights' initializer.\nresidual: Add a residual connection.\n\nExamples\n\ng = rand_graph(5, 6)\nx = rand(Float32, 2, g.num_nodes)\ne = rand(Float32, 3, g.num_edges)\n\nl = CGConv((2, 3) => 4, tanh)\ny = l(g, x, e)    # size: (4, num_nodes)\n\n# No edge features\nl = CGConv(2 => 4, tanh)\ny = l(g, x)    # size: (4, num_nodes)\n\n\n\n\n\n","category":"type"},{"location":"api/conv/#GraphNeuralNetworks.ChebConv","page":"Convolutional Layers","title":"GraphNeuralNetworks.ChebConv","text":"ChebConv(in => out, k; bias=true, init=glorot_uniform)\n\nChebyshev spectral graph convolutional layer from paper Convolutional Neural Networks on Graphs with Fast Localized Spectral Filtering.\n\nImplements\n\nX = sum^K-1_k=0  W^(k) Z^(k)\n\nwhere Z^(k) is the k-th term of Chebyshev polynomials, and can be calculated by the following recursive form:\n\nZ^(0) = X \nZ^(1) = hatL X \nZ^(k) = 2 hatL Z^(k-1) - Z^(k-2)\n\nwith hatL the scaled_laplacian.\n\nArguments\n\nin: The dimension of input features.\nout: The dimension of output features.\nk: The order of Chebyshev polynomial.\nbias: Add learnable bias.\ninit: Weights' initializer.\n\n\n\n\n\n","category":"type"},{"location":"api/conv/#GraphNeuralNetworks.EdgeConv","page":"Convolutional Layers","title":"GraphNeuralNetworks.EdgeConv","text":"EdgeConv(nn; aggr=max)\n\nEdge convolutional layer from paper Dynamic Graph CNN for Learning on Point Clouds.\n\nPerforms the operation\n\nmathbfx_i = square_j in N(i) nn(mathbfx_i mathbfx_j - mathbfx_i)\n\nwhere nn generally denotes a learnable function, e.g. a linear layer or a multi-layer perceptron.\n\nArguments\n\nnn: A (possibly learnable) function. \naggr: Aggregation operator for the incoming messages (e.g. +, *, max, min, and mean).\n\n\n\n\n\n","category":"type"},{"location":"api/conv/#GraphNeuralNetworks.GATConv","page":"Convolutional Layers","title":"GraphNeuralNetworks.GATConv","text":"GATConv(in => out, [σ; heads, concat, init, bias, negative_slope, add_self_loops])\nGATConv((in, ein) => out, ...)\n\nGraph attentional layer from the paper Graph Attention Networks.\n\nImplements the operation\n\nmathbfx_i = sum_j in N(i) cup i alpha_ij W mathbfx_j\n\nwhere the attention coefficients alpha_ij are given by\n\nalpha_ij = frac1z_i exp(LeakyReLU(mathbfa^T W mathbfx_i W mathbfx_j))\n\nwith z_i a normalization factor. \n\nIn case ein > 0 is given, edge features of dimension ein will be expected in the forward pass  and the attention coefficients will be calculated as  \n\nalpha_ij = frac1z_i exp(LeakyReLU(mathbfa^T W_e mathbfe_jto i W mathbfx_i W mathbfx_j))\n\nArguments\n\nin: The dimension of input node features.\nein: The dimension of input edge features. Default 0 (i.e. no edge features passed in the forward).\nout: The dimension of output node features.\nσ: Activation function. Default identity.\nbias: Learn the additive bias if true. Default true.\nheads: Number attention heads. Default 1.\nconcat: Concatenate layer output or not. If not, layer output is averaged over the heads. Default true.\nnegative_slope: The parameter of LeakyReLU.Default 0.2.\nadd_self_loops: Add self loops to the graph before performing the convolution. Default true.\n\n\n\n\n\n","category":"type"},{"location":"api/conv/#GraphNeuralNetworks.GATv2Conv","page":"Convolutional Layers","title":"GraphNeuralNetworks.GATv2Conv","text":"GATv2Conv(in => out, [σ; heads, concat, init, bias, negative_slope, add_self_loops])\nGATv2Conv((in, ein) => out, ...)\n\nGATv2 attentional layer from the paper How Attentive are Graph Attention Networks?.\n\nImplements the operation\n\nmathbfx_i = sum_j in N(i) cup i alpha_ij W_1 mathbfx_j\n\nwhere the attention coefficients alpha_ij are given by\n\nalpha_ij = frac1z_i exp(mathbfa^T LeakyReLU(W_2 mathbfx_i + W_1 mathbfx_j))\n\nwith z_i a normalization factor.\n\nIn case ein > 0 is given, edge features of dimension ein will be expected in the forward pass  and the attention coefficients will be calculated as  \n\nalpha_ij = frac1z_i exp(mathbfa^T LeakyReLU(W_3 mathbfe_jto i + W_2 mathbfx_i + W_1 mathbfx_j))\n\nArguments\n\nin: The dimension of input node features.\nein: The dimension of input edge features. Default 0 (i.e. no edge features passed in the forward).\nout: The dimension of output node features.\nσ: Activation function. Default identity.\nbias: Learn the additive bias if true. Default true.\nheads: Number attention heads. Default 1.\nconcat: Concatenate layer output or not. If not, layer output is averaged over the heads. Default true.\nnegative_slope: The parameter of LeakyReLU.Default 0.2.\nadd_self_loops: Add self loops to the graph before performing the convolution. Default true.\n\n\n\n\n\n","category":"type"},{"location":"api/conv/#GraphNeuralNetworks.GCNConv","page":"Convolutional Layers","title":"GraphNeuralNetworks.GCNConv","text":"GCNConv(in => out, σ=identity; [bias, init, add_self_loops, use_edge_weight])\n\nGraph convolutional layer from paper Semi-supervised Classification with Graph Convolutional Networks.\n\nPerforms the operation\n\nmathbfx_i = sum_jin N(i) a_ij W mathbfx_j\n\nwhere a_ij = 1  sqrtN(i)N(j) is a normalization factor computed from the node degrees. \n\nIf the input graph has weighted edges and use_edge_weight=true, than a_ij will be computed as\n\na_ij = frace_jto isqrtsum_j in N(i)  e_jto i sqrtsum_i in N(j)  e_ito j\n\nThe input to the layer is a node feature array X of size (num_features, num_nodes) and optionally an edge weight vector.\n\nArguments\n\nin: Number of input features.\nout: Number of output features.\nσ: Activation function. Default identity.\nbias: Add learnable bias. Default true.\ninit: Weights' initializer. Default glorot_uniform.\nadd_self_loops: Add self loops to the graph before performing the convolution. Default false.\nuse_edge_weight: If true, consider the edge weights in the input graph (if available).                    If add_self_loops=true the new weights will be set to 1. Default false.\n\nExamples\n\n# create data\ns = [1,1,2,3]\nt = [2,3,1,1]\ng = GNNGraph(s, t)\nx = randn(3, g.num_nodes)\n\n# create layer\nl = GCNConv(3 => 5) \n\n# forward pass\ny = l(g, x)       # size:  5 × num_nodes\n\n# convolution with edge weights\nw = [1.1, 0.1, 2.3, 0.5]\ny = l(g, x, w)\n\n# Edge weights can also be embedded in the graph.\ng = GNNGraph(s, t, w)\nl = GCNConv(3 => 5, use_edge_weight=true) \ny = l(g, x) # same as l(g, x, w) \n\n\n\n\n\n","category":"type"},{"location":"api/conv/#GraphNeuralNetworks.GINConv","page":"Convolutional Layers","title":"GraphNeuralNetworks.GINConv","text":"GINConv(f, ϵ; aggr=+)\n\nGraph Isomorphism convolutional layer from paper How Powerful are Graph Neural Networks?.\n\nImplements the graph convolution\n\nmathbfx_i = f_Thetaleft((1 + epsilon) mathbfx_i + sum_j in N(i) mathbfx_j right)\n\nwhere f_Theta typically denotes a learnable function, e.g. a linear layer or a multi-layer perceptron.\n\nArguments\n\nf: A (possibly learnable) function acting on node features. \nϵ: Weighting factor.\n\n\n\n\n\n","category":"type"},{"location":"api/conv/#GraphNeuralNetworks.GMMConv","page":"Convolutional Layers","title":"GraphNeuralNetworks.GMMConv","text":"GMMConv((in, ein) => out, σ=identity; K=1, bias=true, init=glorot_uniform, residual=false)\n\nGraph mixture model convolution layer from the paper Geometric deep learning on graphs and manifolds using mixture model CNNs Performs the operation\n\nmathbfx_i = mathbfx_i + frac1N(i) sum_jin N(i)frac1Ksum_k=1^K mathbfw_k(mathbfe_jto i) odot Theta_k mathbfx_j\n\nwhere w^a_k(e^a) for feature a and kernel k is given by\n\nw^a_k(e^a) = exp(-frac12(e^a - mu^a_k)^T (Sigma^-1)^a_k(e^a - mu^a_k))\n\nTheta_k mu^a_k (Sigma^-1)^a_k are learnable parameters.\n\nThe input to the layer is a node feature array x of size (num_features, num_nodes) and edge pseudo-coordinate array e of size (num_features, num_edges) The residual mathbfx_i is added only if residual=true and the output size is the same  as the input size.\n\nArguments\n\nin: Number of input node features.\nein: Number of input edge features.\nout: Number of output features.\nσ: Activation function. Default identity.\nK: Number of kernels. Default 1.\nbias: Add learnable bias. Default true.\ninit: Weights' initializer. Default glorot_uniform.\nresidual: Residual conncetion. Default false.\n\nExamples\n\n# create data\ns = [1,1,2,3]\nt = [2,3,1,1]\ng = GNNGraph(s,t)\nnin, ein, out, K = 4, 10, 7, 8 \nx = randn(Float32, nin, g.num_nodes)\ne = randn(Float32, ein, g.num_edges)\n\n# create layer\nl = GMMConv((nin, ein) => out, K=K)\n\n# forward pass\nl(g, x, e)\n\n\n\n\n\n","category":"type"},{"location":"api/conv/#GraphNeuralNetworks.GatedGraphConv","page":"Convolutional Layers","title":"GraphNeuralNetworks.GatedGraphConv","text":"GatedGraphConv(out, num_layers; aggr=+, init=glorot_uniform)\n\nGated graph convolution layer from Gated Graph Sequence Neural Networks.\n\nImplements the recursion\n\nmathbfh^(0)_i = mathbfx_i mathbf0 \nmathbfh^(l)_i = GRU(mathbfh^(l-1)_i square_j in N(i) W mathbfh^(l-1)_j)\n\nwhere mathbfh^(l)_i denotes the l-th hidden variables passing through GRU. The dimension of input mathbfx_i needs to be less or equal to out.\n\nArguments\n\nout: The dimension of output features.\nnum_layers: The number of gated recurrent unit.\naggr: Aggregation operator for the incoming messages (e.g. +, *, max, min, and mean).\ninit: Weight initialization function.\n\n\n\n\n\n","category":"type"},{"location":"api/conv/#GraphNeuralNetworks.GraphConv","page":"Convolutional Layers","title":"GraphNeuralNetworks.GraphConv","text":"GraphConv(in => out, σ=identity; aggr=+, bias=true, init=glorot_uniform)\n\nGraph convolution layer from Reference: Weisfeiler and Leman Go Neural: Higher-order Graph Neural Networks.\n\nPerforms:\n\nmathbfx_i = W_1 mathbfx_i + square_j in mathcalN(i) W_2 mathbfx_j\n\nwhere the aggregation type is selected by aggr.\n\nArguments\n\nin: The dimension of input features.\nout: The dimension of output features.\nσ: Activation function.\naggr: Aggregation operator for the incoming messages (e.g. +, *, max, min, and mean).\nbias: Add learnable bias.\ninit: Weights' initializer.\n\n\n\n\n\n","category":"type"},{"location":"api/conv/#GraphNeuralNetworks.MEGNetConv","page":"Convolutional Layers","title":"GraphNeuralNetworks.MEGNetConv","text":"MEGNetConv(ϕe, ϕv; aggr=mean)\nMEGNetConv(in => out; aggr=mean)\n\nConvolution from Graph Networks as a Universal Machine Learning Framework for Molecules and Crystals paper. In the forward pass, takes as inputs node features x and edge features e and returns updated features x' and e' according to \n\nmathbfe_ito j  = phi_e(mathbfx_i  mathbfx_j  mathbfe_ito j)\nmathbfx_i  = phi_v(mathbfx_i square_jin mathcalN(i)mathbfe_jto i)\n\naggr defines the aggregation to be performed.\n\nIf the neural networks ϕe and  ϕv are not provided, they will be constructed from the in and out arguments instead as multi-layer perceptron with one hidden layer and relu  activations.\n\nExamples\n\ng = rand_graph(10, 30)\nx = randn(3, 10)\ne = randn(3, 30)\nm = MEGNetConv(3 => 3)\nx′, e′ = m(g, x, e)\n\n\n\n\n\n","category":"type"},{"location":"api/conv/#GraphNeuralNetworks.NNConv","page":"Convolutional Layers","title":"GraphNeuralNetworks.NNConv","text":"NNConv(in => out, f, σ=identity; aggr=+, bias=true, init=glorot_uniform)\n\nThe continuous kernel-based convolutional operator from the  Neural Message Passing for Quantum Chemistry paper.  This convolution is also known as the edge-conditioned convolution from the  Dynamic Edge-Conditioned Filters in Convolutional Neural Networks on Graphs paper.\n\nPerforms the operation\n\nmathbfx_i = W mathbfx_i + square_j in N(i) f_Theta(mathbfe_jto i)mathbfx_j\n\nwhere f_Theta  denotes a learnable function (e.g. a linear layer or a multi-layer perceptron). Given an input of batched edge features e of size (num_edge_features, num_edges),  the function f will return an batched matrices array whose size is (out, in, num_edges). For convenience, also functions returning a single (out*in, num_edges) matrix are allowed.\n\nArguments\n\nin: The dimension of input features.\nout: The dimension of output features.\nf: A (possibly learnable) function acting on edge features.\naggr: Aggregation operator for the incoming messages (e.g. +, *, max, min, and mean).\nσ: Activation function.\nbias: Add learnable bias.\ninit: Weights' initializer.\n\n\n\n\n\n","category":"type"},{"location":"api/conv/#GraphNeuralNetworks.ResGatedGraphConv","page":"Convolutional Layers","title":"GraphNeuralNetworks.ResGatedGraphConv","text":"ResGatedGraphConv(in => out, act=identity; init=glorot_uniform, bias=true)\n\nThe residual gated graph convolutional operator from the Residual Gated Graph ConvNets paper.\n\nThe layer's forward pass is given by\n\nmathbfx_i = actbig(Umathbfx_i + sum_j in N(i) eta_ij V mathbfx_jbig)\n\nwhere the edge gates eta_ij are given by\n\neta_ij = sigmoid(Amathbfx_i + Bmathbfx_j)\n\nArguments\n\nin: The dimension of input features.\nout: The dimension of output features.\nact: Activation function.\ninit: Weight matrices' initializing function. \nbias: Learn an additive bias if true.\n\n\n\n\n\n","category":"type"},{"location":"api/conv/#GraphNeuralNetworks.SAGEConv","page":"Convolutional Layers","title":"GraphNeuralNetworks.SAGEConv","text":"SAGEConv(in => out, σ=identity; aggr=mean, bias=true, init=glorot_uniform)\n\nGraphSAGE convolution layer from paper Inductive Representation Learning on Large Graphs.\n\nPerforms:\n\nmathbfx_i = W cdot mathbfx_i square_j in mathcalN(i) mathbfx_j\n\nwhere the aggregation type is selected by aggr.\n\nArguments\n\nin: The dimension of input features.\nout: The dimension of output features.\nσ: Activation function.\naggr: Aggregation operator for the incoming messages (e.g. +, *, max, min, and mean).\nbias: Add learnable bias.\ninit: Weights' initializer.\n\n\n\n\n\n","category":"type"},{"location":"api/conv/#GraphNeuralNetworks.SGConv","page":"Convolutional Layers","title":"GraphNeuralNetworks.SGConv","text":"SGConv(int => out, k=1; [bias, init, add_self_loops, use_edge_weight])\n\nSGC layer from Simplifying Graph Convolutional Networks Performs operation\n\nH^K = (tildeD^-12 tildeA tildeD^-12)^K X Theta\n\nwhere tildeA is A + I.\n\nArguments\n\nin: Number of input features.\nout: Number of output features.\nk : Number of hops k. Default 1.\nbias: Add learnable bias. Default true.\ninit: Weights' initializer. Default glorot_uniform.\nadd_self_loops: Add self loops to the graph before performing the convolution. Default false.\nuse_edge_weight: If true, consider the edge weights in the input graph (if available).                    If add_self_loops=true the new weights will be set to 1. Default false.\n\nExamples\n\n# create data\ns = [1,1,2,3]\nt = [2,3,1,1]\ng = GNNGraph(s, t)\nx = randn(3, g.num_nodes)\n\n# create layer\nl = SGConv(3 => 5; add_self_loops = true) \n\n# forward pass\ny = l(g, x)       # size:  5 × num_nodes\n\n# convolution with edge weights\nw = [1.1, 0.1, 2.3, 0.5]\ny = l(g, x, w)\n\n# Edge weights can also be embedded in the graph.\ng = GNNGraph(s, t, w)\nl = SGConv(3 => 5, add_self_loops = true, use_edge_weight=true) \ny = l(g, x) # same as l(g, x, w) \n\n\n\n\n\n","category":"type"},{"location":"api/messagepassing/","page":"Message Passing","title":"Message Passing","text":"CurrentModule = GraphNeuralNetworks","category":"page"},{"location":"api/messagepassing/#Message-Passing","page":"Message Passing","title":"Message Passing","text":"","category":"section"},{"location":"api/messagepassing/#Index","page":"Message Passing","title":"Index","text":"","category":"section"},{"location":"api/messagepassing/","page":"Message Passing","title":"Message Passing","text":"Order = [:type, :function]\nPages   = [\"messagepassing.md\"]","category":"page"},{"location":"api/messagepassing/#Interface","page":"Message Passing","title":"Interface","text":"","category":"section"},{"location":"api/messagepassing/","page":"Message Passing","title":"Message Passing","text":"apply_edges\naggregate_neighbors\npropagate","category":"page"},{"location":"api/messagepassing/#GraphNeuralNetworks.apply_edges","page":"Message Passing","title":"GraphNeuralNetworks.apply_edges","text":"apply_edges(f, g, xi, xj, e)\napply_edges(f, g; [xi, xj, e])\n\nReturns the message from node j to node i . In the message-passing scheme, the incoming messages  from the neighborhood of i will later be aggregated in order to update the features of node i.\n\nThe function operates on batches of edges, therefore xi, xj, and e are tensors whose last dimension is the batch size, or can be named tuples of  such tensors.\n\nArguments\n\ng: A GNNGraph.\nxi: An array or a named tuple containing arrays whose last dimension's size        is g.num_nodes. It will be appropriately materialized on the       target node of each edge (see also edge_index).\nxj: As xi, but now to be materialized on each edge's source node. \ne: An array or a named tuple containing arrays whose last dimension's size is g.num_edges.\nf: A function that takes as inputs the edge-materialized xi, xj, and e.      These are arrays (or named tuples of arrays) whose last dimension' size is the size of      a batch of edges. The output of f has to be an array (or a named tuple of arrays)      with the same batch size. \n\nSee also propagate and aggregate_neighbors.\n\n\n\n\n\n","category":"function"},{"location":"api/messagepassing/#GraphNeuralNetworks.aggregate_neighbors","page":"Message Passing","title":"GraphNeuralNetworks.aggregate_neighbors","text":"aggregate_neighbors(g::GNNGraph, aggr, m)\n\nGiven a graph g, edge features m, and an aggregation operator aggr (e.g +, min, max, mean), returns the new node features \n\nmathbfx_i = square_j in mathcalN(i) mathbfm_jto i\n\nNeighborhood aggregation is the second step of propagate,  where it comes after apply_edges.\n\n\n\n\n\n","category":"function"},{"location":"api/messagepassing/#GraphNeuralNetworks.propagate","page":"Message Passing","title":"GraphNeuralNetworks.propagate","text":"propagate(f, g, aggr; xi, xj, e)  ->  m̄\n\nPerforms message passing on graph g. Takes care of materializing the node features on each edge,  applying the message function, and returning an aggregated message barmathbfm  (depending on the return value of f, an array or a named tuple of  arrays with last dimension's size g.num_nodes).\n\nIt can be decomposed in two steps:\n\nm = apply_edges(f, g, xi, xj, e)\nm̄ = aggregate_neighbors(g, aggr, m)\n\nGNN layers typically call propagate in their forward pass, providing as input f a closure.  \n\nArguments\n\ng: A GNNGraph.\nxi: An array or a named tuple containing arrays whose last dimension's size        is g.num_nodes. It will be appropriately materialized on the       target node of each edge (see also edge_index).\nxj: As xj, but to be materialized on edges' sources. \ne: An array or a named tuple containing arrays whose last dimension's size is g.num_edges.\nf: A generic function that will be passed over to apply_edges.      Has to take as inputs the edge-materialized xi, xj, and e      (arrays or named tuples of arrays whose last dimension' size is the size of      a batch of edges). Its output has to be an array or a named tuple of arrays     with the same batch size.\naggr: Neighborhood aggregation operator. Use +, mean, max, or min. \n\nExamples\n\nusing GraphNeuralNetworks, Flux\n\nstruct GNNConv <: GNNLayer\n    W\n    b\n    σ\nend\n\nFlux.@functor GNNConv\n\nfunction GNNConv(ch::Pair{Int,Int}, σ=identity)\n    in, out = ch\n    W = Flux.glorot_uniform(out, in)\n    b = zeros(Float32, out)\n    GNNConv(W, b, σ)\nend\n\nfunction (l::GNNConv)(g::GNNGraph, x::AbstractMatrix)\n    message(xi, xj, e) = l.W * xj\n    m̄ = propagate(message, g, +, xj=x)\n    return l.σ.(m̄ .+ l.bias)\nend\n\nl = GNNConv(10 => 20)\nl(g, x)\n\nSee also apply_edges and aggregate_neighbors.\n\n\n\n\n\n","category":"function"},{"location":"api/messagepassing/#Built-in-message-functions","page":"Message Passing","title":"Built-in message functions","text":"","category":"section"},{"location":"api/messagepassing/","page":"Message Passing","title":"Message Passing","text":"copy_xi\ncopy_xj\nxi_dot_xj\ne_mul_xj\nw_mul_xj","category":"page"},{"location":"api/messagepassing/#GraphNeuralNetworks.copy_xi","page":"Message Passing","title":"GraphNeuralNetworks.copy_xi","text":"copy_xi(xi, xj, e) = xi\n\n\n\n\n\n","category":"function"},{"location":"api/messagepassing/#GraphNeuralNetworks.copy_xj","page":"Message Passing","title":"GraphNeuralNetworks.copy_xj","text":"copy_xj(xi, xj, e) = xj\n\n\n\n\n\n","category":"function"},{"location":"api/messagepassing/#GraphNeuralNetworks.xi_dot_xj","page":"Message Passing","title":"GraphNeuralNetworks.xi_dot_xj","text":"xi_dot_xj(xi, xj, e) = sum(xi .* xj, dims=1)\n\n\n\n\n\n","category":"function"},{"location":"api/messagepassing/#GraphNeuralNetworks.e_mul_xj","page":"Message Passing","title":"GraphNeuralNetworks.e_mul_xj","text":"e_mul_xj(xi, xj, e) = reshape(e, (...)) .* xj\n\nReshape e into broadcast compatible shape with xj (by prepending singleton dimensions) then perform broadcasted multiplication.\n\n\n\n\n\n","category":"function"},{"location":"api/messagepassing/#GraphNeuralNetworks.w_mul_xj","page":"Message Passing","title":"GraphNeuralNetworks.w_mul_xj","text":"w_mul_xj(xi, xj, w) = reshape(w, (...)) .* xj\n\nSimilar to e_mul_xj but specialized on scalar edge feautures (weights).\n\n\n\n\n\n","category":"function"},{"location":"#GraphNeuralNetworks","page":"Home","title":"GraphNeuralNetworks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is the documentation page for GraphNeuralNetworks.jl, a graph neural network library written in Julia and based on the deep learning framework Flux.jl. GraphNeuralNetworks.jl is largely inspired by PyTorch Geometric, Deep Graph Library, and GeometricFlux.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Among its features:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Implements common graph convolutional layers.\nSupports computations on batched graphs. \nEasy to define custom layers.\nCUDA support.\nIntegration with Graphs.jl.\nExamples of node, edge, and graph level machine learning tasks. ","category":"page"},{"location":"#Package-overview","page":"Home","title":"Package overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let's give a brief overview of the package by solving a   graph regression problem with synthetic data. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Usage examples on real datasets can be found in the examples folder. ","category":"page"},{"location":"#Data-preparation","page":"Home","title":"Data preparation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We create a dataset consisting in multiple random graphs and associated data features. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"using GraphNeuralNetworks, Graphs, Flux, CUDA, Statistics\nusing Flux.Data: DataLoader\n\nall_graphs = GNNGraph[]\n\nfor _ in 1:1000\n    g = GNNGraph(random_regular_graph(10, 4),  \n            ndata=(; x = randn(Float32, 16,10)),  # input node features\n            gdata=(; y = randn(Float32)))         # regression target   \n    push!(all_graphs, g)\nend","category":"page"},{"location":"#Model-building","page":"Home","title":"Model building","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We concisely define our model as a GNNChain containing two graph convolutional layers. If CUDA is available, our model will live on the gpu.","category":"page"},{"location":"","page":"Home","title":"Home","text":"device = CUDA.functional() ? Flux.gpu : Flux.cpu;\n\nmodel = GNNChain(GCNConv(16 => 64),\n                BatchNorm(64),     # Apply batch normalization on node features (nodes dimension is batch dimension)\n                x -> relu.(x),     \n                GCNConv(64 => 64, relu),\n                GlobalPool(mean),  # aggregate node-wise features into graph-wise features\n                Dense(64, 1)) |> device\n\nps = Flux.params(model)\nopt = Adam(1f-4)","category":"page"},{"location":"#Training","page":"Home","title":"Training","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Finally, we use a standard Flux training pipeline to fit our dataset. Flux's DataLoader iterates over mini-batches of graphs  (batched together into a GNNGraph object). ","category":"page"},{"location":"","page":"Home","title":"Home","text":"train_size = round(Int, 0.8 * length(all_graphs))\ntrain_loader = DataLoader(all_graphs[1:train_size], batchsize=32, shuffle=true)\ntest_loader = DataLoader(all_graphs[train_size+1:end], batchsize=32, shuffle=false)\n\nloss(g::GNNGraph) = mean((vec(model(g, g.ndata.x)) - g.gdata.y).^2)\n\nloss(loader) = mean(loss(g |> device) for g in loader)\n\nfor epoch in 1:100\n    for g in train_loader\n        g = g |> device\n        grad = gradient(() -> loss(g), ps)\n        Flux.Optimise.update!(opt, ps, grad)\n    end\n\n    @info (; epoch, train_loss=loss(train_loader), test_loss=loss(test_loader))\nend","category":"page"}]
}
