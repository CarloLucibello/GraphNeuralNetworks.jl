<!DOCTYPE html><HTML lang="en"><head><script charset="utf-8" src="../../../../../../assets/default/multidoc_injector.js" type="text/javascript"></script><script charset="utf-8" type="text/javascript">window.MULTIDOCUMENTER_ROOT_PATH = '/GraphNeuralNetworks.jl/'</script><script charset="utf-8" src="../../../../../../assets/default/flexsearch.bundle.js" type="text/javascript"></script><script charset="utf-8" src="../../../../../../assets/default/flexsearch_integration.js" type="text/javascript"></script><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>GNNGraph · GNNlib.jl</title><meta content="GNNGraph · GNNlib.jl" name="title"/><meta content="GNNGraph · GNNlib.jl" property="og:title"/><meta content="GNNGraph · GNNlib.jl" property="twitter:title"/><meta content="Documentation for GNNlib.jl." name="description"/><meta content="Documentation for GNNlib.jl." property="og:description"/><meta content="Documentation for GNNlib.jl." property="twitter:description"/><script data-outdated-warner="" src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script data-main="../../../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" data-theme-name="catppuccin-mocha" href="../../../assets/themes/catppuccin-mocha.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="catppuccin-macchiato" href="../../../assets/themes/catppuccin-macchiato.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="catppuccin-frappe" href="../../../assets/themes/catppuccin-frappe.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="catppuccin-latte" href="../../../assets/themes/catppuccin-latte.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-dark" data-theme-primary-dark="" href="../../../assets/themes/documenter-dark.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-light" data-theme-primary="" href="../../../assets/themes/documenter-light.css" rel="stylesheet" type="text/css"/><script src="../../../assets/themeswap.js"></script><link href="../../../../../../assets/default/multidoc.css" rel="stylesheet" type="text/css"/><link href="../../../../../../assets/default/flexsearch.css" rel="stylesheet" type="text/css"/></head><body><nav id="multi-page-nav"><a class="brand" href="../../../../../../../../home/runner/work/GraphNeuralNetworks.jl/GraphNeuralNetworks.jl/docs"><img alt="home" src="../../../../../../logo.svg"/></a><div class="hidden-on-mobile" id="nav-items"><a class="nav-link nav-item" href="../../../../../GraphNeuralNetworks.jl/">GraphNeuralNetworks.jl</a><a class="nav-link nav-item" href="../../../../../GNNLux.jl/">GNNLux.jl</a><a class="nav-link nav-item" href="../../../../../GNNGraphs.jl/">GNNGraphs.jl</a><a class="nav-link active nav-item" href="../../../../">GNNlib.jl</a><div class="search nav-item"><input id="search-input" placeholder="Search..."/><ul class="suggestions hidden" id="search-result-container"></ul><div class="search-keybinding">/</div></div></div><button id="multidoc-toggler"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"></path></svg></button></nav><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">GNNlib.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><a class="tocitem" href="../../../guides/messagepassing/">Message Passing</a></li><li><span class="tocitem">API Reference</span><ul><li><input checked="" class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Graphs (GNNGraphs.jl)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href="">GNNGraph</a><ul class="internal"><li><a class="tocitem" href="#GNNGraph-type"><span>GNNGraph type</span></a></li><li><a class="tocitem" href="#DataStore"><span>DataStore</span></a></li><li><a class="tocitem" href="#Query"><span>Query</span></a></li><li><a class="tocitem" href="#Transform"><span>Transform</span></a></li><li><a class="tocitem" href="#Utils"><span>Utils</span></a></li><li><a class="tocitem" href="#Generate"><span>Generate</span></a></li><li><a class="tocitem" href="#Operators"><span>Operators</span></a></li><li><a class="tocitem" href="#Sampling"><span>Sampling</span></a></li></ul></li><li><a class="tocitem" href="../heterograph/">GNNHeteroGraph</a></li><li><a class="tocitem" href="../temporalgraph/">TemporalSnapshotsGNNGraph</a></li><li><a class="tocitem" href="../samplers/">Samplers</a></li><li><a class="tocitem" href="../datasets/">Datasets</a></li></ul></li><li><a class="tocitem" href="../../../api/messagepassing/">Message Passing</a></li><li><a class="tocitem" href="../../../api/utils/">Utils</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" href="#" id="documenter-sidebar-button"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li><a class="is-disabled">Graphs (GNNGraphs.jl)</a></li><li class="is-active"><a href="">GNNGraph</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="">GNNGraph</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/master/GNNlib/docs/src/GNNGraphs/api/gnngraph.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" href="#" id="documenter-settings-button" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" href="javascript:;" id="documenter-article-toggle-button" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="GNNGraph"><a class="docs-heading-anchor" href="#GNNGraph">GNNGraph</a><a id="GNNGraph-1"></a><a class="docs-heading-anchor-permalink" href="#GNNGraph" title="Permalink"></a></h1><p>Documentation page for the graph type <code>GNNGraph</code> provided by GNNGraphs.jl and related methods. </p><p>Besides the methods documented here, one can rely on the large set of functionalities given by <a href="https://github.com/JuliaGraphs/Graphs.jl">Graphs.jl</a> thanks to the fact that <code>GNNGraph</code> inherits from <code>Graphs.AbstractGraph</code>.</p><h2 id="GNNGraph-type"><a class="docs-heading-anchor" href="#GNNGraph-type">GNNGraph type</a><a id="GNNGraph-type-1"></a><a class="docs-heading-anchor-permalink" href="#GNNGraph-type" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#GNNGraphs.GNNGraph" id="GNNGraphs.GNNGraph"><code>GNNGraphs.GNNGraph</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GNNGraph(data; [graph_type, ndata, edata, gdata, num_nodes, graph_indicator, dir])
GNNGraph(g::GNNGraph; [ndata, edata, gdata])</code></pre><p>A type representing a graph structure that also stores feature arrays associated to nodes, edges, and the graph itself.</p><p>The feature arrays are stored in the fields <code>ndata</code>, <code>edata</code>, and <code>gdata</code> as <a href="#DataStore"><code>DataStore</code></a> objects offering a convenient dictionary-like  and namedtuple-like interface. The features can be passed at construction time or added later.</p><p>A <code>GNNGraph</code> can be constructed out of different <code>data</code> objects expressing the connections inside the graph. The internal representation type is determined by <code>graph_type</code>.</p><p>When constructed from another <code>GNNGraph</code>, the internal graph representation is preserved and shared. The node/edge/graph features are retained as well, unless explicitely set by the keyword arguments <code>ndata</code>, <code>edata</code>, and <code>gdata</code>.</p><p>A <code>GNNGraph</code> can also represent multiple graphs batched togheter (see <a href="#MLUtils.batch-Tuple{AbstractVector{&lt;:GNNGraph}}"><code>MLUtils.batch</code></a> or <a href="#SparseArrays.blockdiag-Tuple{GNNGraph, Vararg{GNNGraph}}"><code>SparseArrays.blockdiag</code></a>). The field <code>g.graph_indicator</code> contains the graph membership of each node.</p><p><code>GNNGraph</code>s are always directed graphs, therefore each edge is defined by a source node and a target node (see <a href="#GNNGraphs.edge_index-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}"><code>edge_index</code></a>). Self loops (edges connecting a node to itself) and multiple edges (more than one edge between the same pair of nodes) are supported.</p><p>A <code>GNNGraph</code> is a Graphs.jl's <code>AbstractGraph</code>, therefore it supports most functionality from that library.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: Some data representing the graph topology. Possible type are<ul><li>An adjacency matrix</li><li>An adjacency list.</li><li>A tuple containing the source and target vectors (COO representation)</li><li>A Graphs.jl' graph.</li></ul></li><li><code>graph_type</code>: A keyword argument that specifies               the underlying representation used by the GNNGraph.               Currently supported values are<ul><li><code>:coo</code>. Graph represented as a tuple <code>(source, target)</code>, such that the <code>k</code>-th edge         connects the node <code>source[k]</code> to node <code>target[k]</code>.         Optionally, also edge weights can be given: <code>(source, target, weights)</code>.</li><li><code>:sparse</code>. A sparse adjacency matrix representation.</li><li><code>:dense</code>. A dense adjacency matrix representation.</li></ul>Defaults to <code>:coo</code>, currently the most supported type.</li><li><code>dir</code>: The assumed edge direction when given adjacency matrix or adjacency list input data <code>g</code>.       Possible values are <code>:out</code> and <code>:in</code>. Default <code>:out</code>.</li><li><code>num_nodes</code>: The number of nodes. If not specified, inferred from <code>g</code>. Default <code>nothing</code>.</li><li><code>graph_indicator</code>: For batched graphs, a vector containing the graph assignment of each node. Default <code>nothing</code>.</li><li><code>ndata</code>: Node features. An array or named tuple of arrays whose last dimension has size <code>num_nodes</code>.</li><li><code>edata</code>: Edge features. An array or named tuple of arrays whose last dimension has size <code>num_edges</code>.</li><li><code>gdata</code>: Graph features. An array or named tuple of arrays whose last dimension has size <code>num_graphs</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using GNNGraphs

# Construct from adjacency list representation
data = [[2,3], [1,4,5], [1], [2,5], [2,4]]
g = GNNGraph(data)

# Number of nodes, edges, and batched graphs
g.num_nodes  # 5
g.num_edges  # 10
g.num_graphs # 1

# Same graph in COO representation
s = [1,1,2,2,2,3,4,4,5,5]
t = [2,3,1,4,5,3,2,5,2,4]
g = GNNGraph(s, t)

# From a Graphs' graph
g = GNNGraph(erdos_renyi(100, 20))

# Add 2 node feature arrays at creation time
g = GNNGraph(g, ndata = (x=rand(100, g.num_nodes), y=rand(g.num_nodes)))

# Add 1 edge feature array, after the graph creation
g.edata.z = rand(16, g.num_edges)

# Add node features and edge features with default names `x` and `e`
g = GNNGraph(g, ndata = rand(100, g.num_nodes), edata = rand(16, g.num_edges))

g.ndata.x # or just g.x
g.edata.e # or just g.e

# Collect edges' source and target nodes.
# Both source and target are vectors of length num_edges
source, target = edge_index(g)</code></pre><p>A <code>GNNGraph</code> can be sent to the GPU, for example by using Flux.jl's <code>gpu</code> function or MLDataDevices.jl's utilities.  ```</p></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/gnngraph.jl#L8-L107" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#Base.copy" id="Base.copy"><code>Base.copy</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">copy(g::GNNGraph; deep=false)</code></pre><p>Create a copy of <code>g</code>. If <code>deep</code> is <code>true</code>, then copy will be a deep copy (equivalent to <code>deepcopy(g)</code>), otherwise it will be a shallow copy with the same underlying graph data.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/gnngraph.jl#L215-L220" target="_blank">source</a></section></article><h2 id="DataStore"><a class="docs-heading-anchor" href="#DataStore">DataStore</a><a id="DataStore-1"></a><a class="docs-heading-anchor-permalink" href="#DataStore" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#GNNGraphs.DataStore" id="GNNGraphs.DataStore"><code>GNNGraphs.DataStore</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DataStore([n, data])
DataStore([n,] k1 = x1, k2 = x2, ...)</code></pre><p>A container for feature arrays. The optional argument <code>n</code> enforces that <code>numobs(x) == n</code> for each array contained in the datastore.</p><p>At construction time, the <code>data</code> can be provided as any iterables of pairs of symbols and arrays or as keyword arguments:</p><pre><code class="language-julia-repl hljs">julia&gt; ds = DataStore(3, x = rand(Float32, 2, 3), y = rand(Float32, 3))
DataStore(3) with 2 elements:
  y = 3-element Vector{Float32}
  x = 2×3 Matrix{Float32}

julia&gt; ds = DataStore(3, Dict(:x =&gt; rand(Float32, 2, 3), :y =&gt; rand(Float32, 3))); # equivalent to above</code></pre><p>The <code>DataStore</code> has an interface similar to both dictionaries and named tuples. Arrays can be accessed and added using either the indexing or the property syntax:</p><pre><code class="language-julia-repl hljs">julia&gt; ds = DataStore(x = ones(Float32, 2, 3), y = zeros(Float32, 3))
DataStore() with 2 elements:
  y = 3-element Vector{Float32}
  x = 2×3 Matrix{Float32}

julia&gt; ds.x   # same as `ds[:x]`
2×3 Matrix{Float32}:
 1.0  1.0  1.0
 1.0  1.0  1.0

julia&gt; ds.z = zeros(Float32, 3)  # Add new feature array `z`. Same as `ds[:z] = rand(Float32, 3)`
3-element Vector{Float32}:
 0.0
 0.0
 0.0</code></pre><p>The <code>DataStore</code> can be iterated over, and the keys and values can be accessed using <code>keys(ds)</code> and <code>values(ds)</code>. <code>map(f, ds)</code> applies the function <code>f</code> to each feature array:</p><pre><code class="language-julia-repl hljs">julia&gt; ds2 = map(x -&gt; x .+ 1, ds)
DataStore() with 3 elements:
  y = 3-element Vector{Float32}
  z = 3-element Vector{Float32}
  x = 2×3 Matrix{Float32}

julia&gt; ds2.z
3-element Vector{Float32}:
 1.0
 1.0
 1.0</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/datastore.jl#L1-L58" target="_blank">source</a></section></article><h2 id="Query"><a class="docs-heading-anchor" href="#Query">Query</a><a id="Query-1"></a><a class="docs-heading-anchor-permalink" href="#Query" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#GNNGraphs.adjacency_list-Tuple{GNNGraph, Any}" id="GNNGraphs.adjacency_list-Tuple{GNNGraph, Any}"><code>GNNGraphs.adjacency_list</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">adjacency_list(g; dir=:out)
adjacency_list(g, nodes; dir=:out)</code></pre><p>Return the adjacency list representation (a vector of vectors) of the graph <code>g</code>.</p><p>Calling <code>a</code> the adjacency list, if <code>dir=:out</code> than <code>a[i]</code> will contain the neighbors of node <code>i</code> through outgoing edges. If <code>dir=:in</code>, it will contain neighbors from incoming edges instead.</p><p>If <code>nodes</code> is given, return the neighborhood of the nodes in <code>nodes</code> only.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/query.jl#L162-L175" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#GNNGraphs.edge_index-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}" id="GNNGraphs.edge_index-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}"><code>GNNGraphs.edge_index</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">edge_index(g::GNNGraph)</code></pre><p>Return a tuple containing two vectors, respectively storing  the source and target nodes for each edges in <code>g</code>.</p><pre><code class="language-julia hljs">s, t = edge_index(g)</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/query.jl#L2-L11" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#GNNGraphs.get_graph_type-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}" id="GNNGraphs.get_graph_type-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}"><code>GNNGraphs.get_graph_type</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_graph_type(g::GNNGraph)</code></pre><p>Return the underlying representation for the graph <code>g</code> as a symbol.</p><p>Possible values are:</p><ul><li><code>:coo</code>: Coordinate list representation. The graph is stored as a tuple of vectors <code>(s, t, w)</code>,         where <code>s</code> and <code>t</code> are the source and target nodes of the edges, and <code>w</code> is the edge weights.</li><li><code>:sparse</code>: Sparse matrix representation. The graph is stored as a sparse matrix representing the weighted adjacency matrix.</li><li><code>:dense</code>: Dense matrix representation. The graph is stored as a dense matrix representing the weighted adjacency matrix.</li></ul><p>The default representation for graph constructors GNNGraphs.jl is <code>:coo</code>. The underlying representation can be accessed through the <code>g.graph</code> field.</p><p>See also <a href="#GNNGraph"><code>GNNGraph</code></a>.</p><p><strong>Examples</strong></p><p>The default representation for graph constructors GNNGraphs.jl is <code>:coo</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; g = rand_graph(5, 10)
GNNGraph:
  num_nodes: 5
  num_edges: 10

julia&gt; get_graph_type(g)
:coo</code></pre><p>The <code>GNNGraph</code> constructor can also be used to create graphs with different representations.</p><pre><code class="language-julia-repl hljs">julia&gt; g = GNNGraph([2,3,5], [1,2,4], graph_type=:sparse)
GNNGraph:
  num_nodes: 5
  num_edges: 3

julia&gt; g.graph
5×5 SparseArrays.SparseMatrixCSC{Int64, Int64} with 3 stored entries:
 ⋅  ⋅  ⋅  ⋅  ⋅
 1  ⋅  ⋅  ⋅  ⋅
 ⋅  1  ⋅  ⋅  ⋅
 ⋅  ⋅  ⋅  ⋅  ⋅
 ⋅  ⋅  ⋅  1  ⋅

julia&gt; get_graph_type(g)
:sparse

julia&gt; gcoo = GNNGraph(g, graph_type=:coo);

julia&gt; gcoo.graph
([2, 3, 5], [1, 2, 4], [1, 1, 1])</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/query.jl#L45-L96" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#GNNGraphs.graph_indicator-Tuple{GNNGraph}" id="GNNGraphs.graph_indicator-Tuple{GNNGraph}"><code>GNNGraphs.graph_indicator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">graph_indicator(g::GNNGraph; edges=false)</code></pre><p>Return a vector containing the graph membership (an integer from <code>1</code> to <code>g.num_graphs</code>) of each node in the graph. If <code>edges=true</code>, return the graph membership of each edge instead.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/query.jl#L493-L499" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#GNNGraphs.has_isolated_nodes-Tuple{GNNGraph}" id="GNNGraphs.has_isolated_nodes-Tuple{GNNGraph}"><code>GNNGraphs.has_isolated_nodes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_isolated_nodes(g::GNNGraph; dir=:out)</code></pre><p>Return true if the graph <code>g</code> contains nodes with out-degree (if <code>dir=:out</code>) or in-degree (if <code>dir = :in</code>) equal to zero.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/query.jl#L414-L419" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#GNNGraphs.has_multi_edges-Tuple{GNNGraph}" id="GNNGraphs.has_multi_edges-Tuple{GNNGraph}"><code>GNNGraphs.has_multi_edges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_multi_edges(g::GNNGraph)</code></pre><p>Return <code>true</code> if <code>g</code> has any multiple edges.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/query.jl#L570-L574" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#GNNGraphs.is_bidirected-Tuple{GNNGraph}" id="GNNGraphs.is_bidirected-Tuple{GNNGraph}"><code>GNNGraphs.is_bidirected</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_bidirected(g::GNNGraph)</code></pre><p>Check if the directed graph <code>g</code> essentially corresponds to an undirected graph, i.e. if for each edge it also contains the  reverse edge. </p></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/query.jl#L546-L552" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#GNNGraphs.khop_adj" id="GNNGraphs.khop_adj"><code>GNNGraphs.khop_adj</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">khop_adj(g::GNNGraph,k::Int,T::DataType=eltype(g); dir=:out, weighted=true)</code></pre><p>Return <span>$A^k$</span> where <span>$A$</span> is the adjacency matrix of the graph 'g'.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/query.jl#L581-L586" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#GNNGraphs.laplacian_lambda_max" id="GNNGraphs.laplacian_lambda_max"><code>GNNGraphs.laplacian_lambda_max</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">laplacian_lambda_max(g::GNNGraph, T=Float32; add_self_loops=false, dir=:out)</code></pre><p>Return the largest eigenvalue of the normalized symmetric Laplacian of the graph <code>g</code>.</p><p>If the graph is batched from multiple graphs, return the list of the largest eigenvalue for each graph.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/query.jl#L591-L597" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#GNNGraphs.normalized_laplacian" id="GNNGraphs.normalized_laplacian"><code>GNNGraphs.normalized_laplacian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normalized_laplacian(g, T=Float32; add_self_loops=false, dir=:out)</code></pre><p>Normalized Laplacian matrix of graph <code>g</code>.</p><p><strong>Arguments</strong></p><ul><li><code>g</code>: A <code>GNNGraph</code>.</li><li><code>T</code>: result element type.</li><li><code>add_self_loops</code>: add self-loops while calculating the matrix.</li><li><code>dir</code>: the edge directionality considered (:out, :in, :both).</li></ul></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/query.jl#L430-L441" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#GNNGraphs.scaled_laplacian" id="GNNGraphs.scaled_laplacian"><code>GNNGraphs.scaled_laplacian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">scaled_laplacian(g, T=Float32; dir=:out)</code></pre><p>Scaled Laplacian matrix of graph <code>g</code>, defined as <span>$\hat{L} = \frac{2}{\lambda_{max}} L - I$</span> where <span>$L$</span> is the normalized Laplacian matrix.</p><p><strong>Arguments</strong></p><ul><li><code>g</code>: A <code>GNNGraph</code>.</li><li><code>T</code>: result element type.</li><li><code>dir</code>: the edge directionality considered (:out, :in, :both).</li></ul></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/query.jl#L462-L473" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#Graphs.LinAlg.adjacency_matrix" id="Graphs.LinAlg.adjacency_matrix"><code>Graphs.LinAlg.adjacency_matrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">adjacency_matrix(g::GNNGraph, T=eltype(g); dir=:out, weighted=true)</code></pre><p>Return the adjacency matrix <code>A</code> for the graph <code>g</code>. </p><p>If <code>dir=:out</code>, <code>A[i,j] &gt; 0</code> denotes the presence of an edge from node <code>i</code> to node <code>j</code>. If <code>dir=:in</code> instead, <code>A[i,j] &gt; 0</code> denotes the presence of an edge from node <code>j</code> to node <code>i</code>.</p><p>User may specify the eltype <code>T</code> of the returned matrix. </p><p>If <code>weighted=true</code>, the <code>A</code> will contain the edge weights if any, otherwise the elements of <code>A</code> will be either 0 or 1.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/query.jl#L208-L219" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#Graphs.degree-Union{Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}, Tuple{TT}, Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, TT}} where TT&lt;:Union{Nothing, Type{&lt;:Number}}" id="Graphs.degree-Union{Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}, Tuple{TT}, Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, TT}} where TT&lt;:Union{Nothing, Type{&lt;:Number}}"><code>Graphs.degree</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">degree(g::GNNGraph, T=nothing; dir=:out, edge_weight=true)</code></pre><p>Return a vector containing the degrees of the nodes in <code>g</code>.</p><p>The gradient is propagated through this function only if <code>edge_weight</code> is <code>true</code> or a vector.</p><p><strong>Arguments</strong></p><ul><li><code>g</code>: A graph.</li><li><code>T</code>: Element type of the returned vector. If <code>nothing</code>, is      chosen based on the graph type and will be an integer      if <code>edge_weight = false</code>. Default <code>nothing</code>.</li><li><code>dir</code>: For <code>dir = :out</code> the degree of a node is counted based on the outgoing edges.        For <code>dir = :in</code>, the ingoing edges are used. If <code>dir = :both</code> we have the sum of the two.</li><li><code>edge_weight</code>: If <code>true</code> and the graph contains weighted edges, the degree will                be weighted. Set to <code>false</code> instead to just count the number of               outgoing/ingoing edges.                Finally, you can also pass a vector of weights to be used               instead of the graph's own weights.               Default <code>true</code>.</li></ul></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/query.jl#L290-L313" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#Graphs.has_self_loops-Tuple{GNNGraph}" id="Graphs.has_self_loops-Tuple{GNNGraph}"><code>Graphs.has_self_loops</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_self_loops(g::GNNGraph)</code></pre><p>Return <code>true</code> if <code>g</code> has any self loops.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/query.jl#L560-L564" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#Graphs.inneighbors-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, Integer}" id="Graphs.inneighbors-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, Integer}"><code>Graphs.inneighbors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inneighbors(g::GNNGraph, i::Integer)</code></pre><p>Return the neighbors of node <code>i</code> in the graph <code>g</code> through incoming edges.</p><p>See also <a href="#Graphs.neighbors-Tuple{GNNGraph, Integer}"><code>neighbors</code></a> and <a href="#Graphs.outneighbors-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, Integer}"><code>outneighbors</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/query.jl#L142-L148" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#Graphs.outneighbors-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, Integer}" id="Graphs.outneighbors-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, Integer}"><code>Graphs.outneighbors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">outneighbors(g::GNNGraph, i::Integer)</code></pre><p>Return the neighbors of node <code>i</code> in the graph <code>g</code> through outgoing edges.</p><p>See also <a href="#Graphs.neighbors-Tuple{GNNGraph, Integer}"><code>neighbors</code></a> and <a href="#Graphs.inneighbors-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, Integer}"><code>inneighbors</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/query.jl#L125-L131" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#Graphs.neighbors-Tuple{GNNGraph, Integer}" id="Graphs.neighbors-Tuple{GNNGraph, Integer}"><code>Graphs.neighbors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">neighbors(g::GNNGraph, i::Integer; dir=:out)</code></pre><p>Return the neighbors of node <code>i</code> in the graph <code>g</code>. If <code>dir=:out</code>, return the neighbors through outgoing edges. If <code>dir=:in</code>, return the neighbors through incoming edges.</p><p>See also <a href="#Graphs.outneighbors-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, Integer}"><code>outneighbors</code></a>, <a href="#Graphs.inneighbors-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, Integer}"><code>inneighbors</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/query.jl#L107-L115" target="_blank">source</a></section></article><h2 id="Transform"><a class="docs-heading-anchor" href="#Transform">Transform</a><a id="Transform-1"></a><a class="docs-heading-anchor-permalink" href="#Transform" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#GNNGraphs.add_edges-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, AbstractVector, AbstractVector}" id="GNNGraphs.add_edges-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, AbstractVector, AbstractVector}"><code>GNNGraphs.add_edges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_edges(g::GNNGraph, s::AbstractVector, t::AbstractVector; [edata])
add_edges(g::GNNGraph, (s, t); [edata])
add_edges(g::GNNGraph, (s, t, w); [edata])</code></pre><p>Add to graph <code>g</code> the edges with source nodes <code>s</code> and target nodes <code>t</code>. Optionally, pass the edge weight <code>w</code> and the features  <code>edata</code> for the new edges. Returns a new graph sharing part of the underlying data with <code>g</code>.</p><p>If the <code>s</code> or <code>t</code> contain nodes that are not already present in the graph, they are added to the graph as well.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; s, t = [1, 2, 3, 3, 4], [2, 3, 4, 4, 4];

julia&gt; w = Float32[1.0, 2.0, 3.0, 4.0, 5.0];

julia&gt; g = GNNGraph((s, t, w))
GNNGraph:
  num_nodes: 4
  num_edges: 5

julia&gt; add_edges(g, ([2, 3], [4, 1], [10.0, 20.0]))
GNNGraph:
  num_nodes: 4
  num_edges: 7</code></pre><pre><code class="language-julia-repl hljs">julia&gt; g = GNNGraph()
GNNGraph:
  num_nodes: 0
  num_edges: 0

julia&gt; add_edges(g, [1,2], [2,3])
GNNGraph:
  num_nodes: 3
  num_edges: 2</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/transform.jl#L278-L318" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#GNNGraphs.add_nodes-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, Integer}" id="GNNGraphs.add_nodes-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, Integer}"><code>GNNGraphs.add_nodes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_nodes(g::GNNGraph, n; [ndata])</code></pre><p>Add <code>n</code> new nodes to graph <code>g</code>. In the  new graph, these nodes will have indexes from <code>g.num_nodes + 1</code> to <code>g.num_nodes + n</code>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/transform.jl#L546-L552" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#GNNGraphs.add_self_loops-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}" id="GNNGraphs.add_self_loops-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}"><code>GNNGraphs.add_self_loops</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_self_loops(g::GNNGraph)</code></pre><p>Return a graph with the same features as <code>g</code> but also adding edges connecting the nodes to themselves.</p><p>Nodes with already existing self-loops will obtain a second self-loop.</p><p>If the graphs has edge weights, the new edges will have weight 1.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/transform.jl#L2-L11" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#GNNGraphs.getgraph-Tuple{GNNGraph, Int64}" id="GNNGraphs.getgraph-Tuple{GNNGraph, Int64}"><code>GNNGraphs.getgraph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getgraph(g::GNNGraph, i; nmap=false)</code></pre><p>Return the subgraph of <code>g</code> induced by those nodes <code>j</code> for which <code>g.graph_indicator[j] == i</code> or, if <code>i</code> is a collection, <code>g.graph_indicator[j] ∈ i</code>.  In other words, it extract the component graphs from a batched graph. </p><p>If <code>nmap=true</code>, return also a vector <code>v</code> mapping the new nodes to the old ones.  The node <code>i</code> in the subgraph will correspond to the node <code>v[i]</code> in <code>g</code>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/transform.jl#L814-L824" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#GNNGraphs.negative_sample-Tuple{GNNGraph}" id="GNNGraphs.negative_sample-Tuple{GNNGraph}"><code>GNNGraphs.negative_sample</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">negative_sample(g::GNNGraph; 
                num_neg_edges = g.num_edges, 
                bidirected = is_bidirected(g))</code></pre><p>Return a graph containing random negative edges (i.e. non-edges) from graph <code>g</code> as edges.</p><p>If <code>bidirected=true</code>, the output graph will be bidirected and there will be no leakage from the origin graph. </p><p>See also <a href="#GNNGraphs.is_bidirected-Tuple{GNNGraph}"><code>is_bidirected</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/transform.jl#L878-L889" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#GNNGraphs.perturb_edges-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, AbstractFloat}" id="GNNGraphs.perturb_edges-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, AbstractFloat}"><code>GNNGraphs.perturb_edges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">perturb_edges([rng], g::GNNGraph, perturb_ratio)</code></pre><p>Return a new graph obtained from <code>g</code> by adding random edges, based on a specified <code>perturb_ratio</code>.  The <code>perturb_ratio</code> determines the fraction of new edges to add relative to the current number of edges in the graph.  These new edges are added without creating self-loops. </p><p>The function returns a new <code>GNNGraph</code> instance that shares some of the underlying data with <code>g</code> but includes the additional edges.  The nodes for the new edges are selected randomly, and no edge data (<code>edata</code>) or weights (<code>w</code>) are assigned to these new edges.</p><p><strong>Arguments</strong></p><ul><li><code>g::GNNGraph</code>: The graph to be perturbed.</li><li><code>perturb_ratio</code>: The ratio of the number of new edges to add relative to the current number of edges in the graph. For example, a <code>perturb_ratio</code> of 0.1 means that 10% of the current number of edges will be added as new random edges.</li><li><code>rng</code>: An optionalrandom number generator to ensure reproducible results.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; g = GNNGraph((s, t, w))
GNNGraph:
  num_nodes: 4
  num_edges: 5

julia&gt; perturbed_g = perturb_edges(g, 0.2)
GNNGraph:
  num_nodes: 4
  num_edges: 6</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/transform.jl#L355-L384" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#GNNGraphs.ppr_diffusion-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}" id="GNNGraphs.ppr_diffusion-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}"><code>GNNGraphs.ppr_diffusion</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ppr_diffusion(g::GNNGraph{&lt;:COO_T}, alpha =0.85f0) -&gt; GNNGraph</code></pre><p>Calculates the Personalized PageRank (PPR) diffusion based on the edge weight matrix of a GNNGraph and updates the graph with new edge weights derived from the PPR matrix. References paper: <a href="http://ilpubs.stanford.edu:8090/422">The pagerank citation ranking: Bringing order to the web</a></p><p>The function performs the following steps:</p><ol><li>Constructs a modified adjacency matrix <code>A</code> using the graph's edge weights, where <code>A</code> is adjusted by <code>(α - 1) * A + I</code>, with <code>α</code> being the damping factor (<code>alpha_f32</code>) and <code>I</code> the identity matrix.</li><li>Normalizes <code>A</code> to ensure each column sums to 1, representing transition probabilities.</li><li>Applies the PPR formula <code>α * (I + (α - 1) * A)^-1</code> to compute the diffusion matrix.</li><li>Updates the original edge weights of the graph based on the PPR diffusion matrix, assigning new weights for each edge from the PPR matrix.</li></ol><p><strong>Arguments</strong></p><ul><li><code>g::GNNGraph</code>: The input graph for which PPR diffusion is to be calculated. It should have edge weights available.</li><li><code>alpha_f32::Float32</code>: The damping factor used in PPR calculation, controlling the teleport probability in the random walk. Defaults to <code>0.85f0</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A new <code>GNNGraph</code> instance with the same structure as <code>g</code> but with updated edge weights according to the PPR diffusion calculation.</li></ul></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/transform.jl#L1006-L1025" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#GNNGraphs.rand_edge_split-Tuple{GNNGraph, Any}" id="GNNGraphs.rand_edge_split-Tuple{GNNGraph, Any}"><code>GNNGraphs.rand_edge_split</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rand_edge_split(g::GNNGraph, frac; bidirected=is_bidirected(g)) -&gt; g1, g2</code></pre><p>Randomly partition the edges in <code>g</code> to form two graphs, <code>g1</code> and <code>g2</code>. Both will have the same number of nodes as <code>g</code>. <code>g1</code> will contain a fraction <code>frac</code> of the original edges,  while <code>g2</code> wil contain the rest.</p><p>If <code>bidirected = true</code> makes sure that an edge and its reverse go into the same split. This option is supported only for bidirected graphs with no self-loops and multi-edges.</p><p><code>rand_edge_split</code> is tipically used to create train/test splits in link prediction tasks.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/transform.jl#L931-L944" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#GNNGraphs.random_walk_pe-Tuple{GNNGraph, Int64}" id="GNNGraphs.random_walk_pe-Tuple{GNNGraph, Int64}"><code>GNNGraphs.random_walk_pe</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">random_walk_pe(g, walk_length)</code></pre><p>Return the random walk positional encoding from the paper <a href="https://arxiv.org/abs/2110.07875">Graph Neural Networks with Learnable Structural and Positional Representations</a> of the given graph <code>g</code> and the length of the walk <code>walk_length</code> as a matrix of size <code>(walk_length, g.num_nodes)</code>. </p></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/transform.jl#L970-L974" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#GNNGraphs.remove_edges-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, AbstractVector{&lt;:Integer}}" id="GNNGraphs.remove_edges-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, AbstractVector{&lt;:Integer}}"><code>GNNGraphs.remove_edges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_edges(g::GNNGraph, edges_to_remove::AbstractVector{&lt;:Integer})
remove_edges(g::GNNGraph, p=0.5)</code></pre><p>Remove specified edges from a GNNGraph, either by specifying edge indices or by randomly removing edges with a given probability.</p><p><strong>Arguments</strong></p><ul><li><code>g</code>: The input graph from which edges will be removed.</li><li><code>edges_to_remove</code>: Vector of edge indices to be removed. This argument is only required for the first method.</li><li><code>p</code>: Probability of removing each edge. This argument is only required for the second method and defaults to 0.5.</li></ul><p><strong>Returns</strong></p><p>A new GNNGraph with the specified edges removed.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; using GNNGraphs

# Construct a GNNGraph
julia&gt; g = GNNGraph([1, 1, 2, 2, 3], [2, 3, 1, 3, 1])
GNNGraph:
  num_nodes: 3
  num_edges: 5
  
# Remove the second edge
julia&gt; g_new = remove_edges(g, [2]);

julia&gt; g_new
GNNGraph:
  num_nodes: 3
  num_edges: 4

# Remove edges with a probability of 0.5
julia&gt; g_new = remove_edges(g, 0.5);

julia&gt; g_new
GNNGraph:
  num_nodes: 3
  num_edges: 2</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/transform.jl#L80-L120" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#GNNGraphs.remove_multi_edges-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}" id="GNNGraphs.remove_multi_edges-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}"><code>GNNGraphs.remove_multi_edges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_multi_edges(g::GNNGraph; aggr=+)</code></pre><p>Remove multiple edges (also called parallel edges or repeated edges) from graph <code>g</code>. Possible edge features are aggregated according to <code>aggr</code>, that can take value  <code>+</code>,<code>min</code>, <code>max</code> or <code>mean</code>.</p><p>See also <a href="#GNNGraphs.remove_self_loops-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}"><code>remove_self_loops</code></a>, <a href="#GNNGraphs.has_multi_edges-Tuple{GNNGraph}"><code>has_multi_edges</code></a>, and <a href="#GNNGraphs.to_bidirected-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}"><code>to_bidirected</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/transform.jl#L148-L156" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#GNNGraphs.remove_nodes-Tuple{GNNGraph, AbstractFloat}" id="GNNGraphs.remove_nodes-Tuple{GNNGraph, AbstractFloat}"><code>GNNGraphs.remove_nodes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_nodes(g::GNNGraph, p)</code></pre><p>Returns a new graph obtained by dropping nodes from <code>g</code> with independent probabilities <code>p</code>. </p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; g = GNNGraph([1, 1, 2, 2, 3, 4], [1, 2, 3, 1, 3, 1])
GNNGraph:
  num_nodes: 4
  num_edges: 6

julia&gt; g_new = remove_nodes(g, 0.5)
GNNGraph:
  num_nodes: 2
  num_edges: 2</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/transform.jl#L254-L272" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#GNNGraphs.remove_nodes-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, AbstractVector}" id="GNNGraphs.remove_nodes-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}, AbstractVector}"><code>GNNGraphs.remove_nodes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_nodes(g::GNNGraph, nodes_to_remove::AbstractVector)</code></pre><p>Remove specified nodes, and their associated edges, from a GNNGraph. This operation reindexes the remaining nodes to maintain a continuous sequence of node indices, starting from 1. Similarly, edges are reindexed to account for the removal of edges connected to the removed nodes.</p><p><strong>Arguments</strong></p><ul><li><code>g</code>: The input graph from which nodes (and their edges) will be removed.</li><li><code>nodes_to_remove</code>: Vector of node indices to be removed.</li></ul><p><strong>Returns</strong></p><p>A new GNNGraph with the specified nodes and all edges associated with these nodes removed. </p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using GNNGraphs

g = GNNGraph([1, 1, 2, 2, 3], [2, 3, 1, 3, 1])

# Remove nodes with indices 2 and 3, for example
g_new = remove_nodes(g, [2, 3])

# g_new now does not contain nodes 2 and 3, and any edges that were connected to these nodes.
println(g_new)</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/transform.jl#L187-L211" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#GNNGraphs.remove_self_loops-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}" id="GNNGraphs.remove_self_loops-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}"><code>GNNGraphs.remove_self_loops</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_self_loops(g::GNNGraph)</code></pre><p>Return a graph constructed from <code>g</code> where self-loops (edges from a node to itself) are removed. </p><p>See also <a href="#GNNGraphs.add_self_loops-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}"><code>add_self_loops</code></a> and <a href="#GNNGraphs.remove_multi_edges-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}"><code>remove_multi_edges</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/transform.jl#L41-L48" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#GNNGraphs.set_edge_weight-Tuple{GNNGraph, AbstractVector}" id="GNNGraphs.set_edge_weight-Tuple{GNNGraph, AbstractVector}"><code>GNNGraphs.set_edge_weight</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_edge_weight(g::GNNGraph, w::AbstractVector)</code></pre><p>Set <code>w</code> as edge weights in the returned graph. </p></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/transform.jl#L563-L567" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#GNNGraphs.to_bidirected-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}" id="GNNGraphs.to_bidirected-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}"><code>GNNGraphs.to_bidirected</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">to_bidirected(g)</code></pre><p>Adds a reverse edge for each edge in the graph, then calls  <a href="#GNNGraphs.remove_multi_edges-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}"><code>remove_multi_edges</code></a> with <code>mean</code> aggregation to simplify the graph. </p><p>See also <a href="#GNNGraphs.is_bidirected-Tuple{GNNGraph}"><code>is_bidirected</code></a>. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; s, t = [1, 2, 3, 3, 4], [2, 3, 4, 4, 4];

julia&gt; w = [1.0, 2.0, 3.0, 4.0, 5.0];

julia&gt; e = [10.0, 20.0, 30.0, 40.0, 50.0];

julia&gt; g = GNNGraph(s, t, w, edata = e)
GNNGraph:
  num_nodes: 4
  num_edges: 5
  edata:
        e = 5-element Vector{Float64}

julia&gt; g2 = to_bidirected(g)
GNNGraph:
  num_nodes: 4
  num_edges: 7
  edata:
        e = 7-element Vector{Float64}

julia&gt; edge_index(g2)
([1, 2, 2, 3, 3, 4, 4], [2, 1, 3, 2, 4, 3, 4])

julia&gt; get_edge_weight(g2)
7-element Vector{Float64}:
 1.0
 1.0
 2.0
 2.0
 3.5
 3.5
 5.0

julia&gt; g2.edata.e
7-element Vector{Float64}:
 10.0
 10.0
 20.0
 20.0
 35.0
 35.0
 50.0</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/transform.jl#L440-L494" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#GNNGraphs.to_unidirected-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}" id="GNNGraphs.to_unidirected-Tuple{GNNGraph{&lt;:Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}}}}"><code>GNNGraphs.to_unidirected</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">to_unidirected(g::GNNGraph)</code></pre><p>Return a graph that for each multiple edge between two nodes in <code>g</code> keeps only an edge in one direction.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/transform.jl#L511-L516" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#MLUtils.batch-Tuple{AbstractVector{&lt;:GNNGraph}}" id="MLUtils.batch-Tuple{AbstractVector{&lt;:GNNGraph}}"><code>MLUtils.batch</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">batch(gs::Vector{&lt;:GNNGraph})</code></pre><p>Batch together multiple <code>GNNGraph</code>s into a single one  containing the total number of original nodes and edges.</p><p>Equivalent to <a href="#SparseArrays.blockdiag-Tuple{GNNGraph, Vararg{GNNGraph}}"><code>SparseArrays.blockdiag</code></a>. See also <a href="#MLUtils.unbatch-Union{Tuple{GNNGraph{T}}, Tuple{T}} where T&lt;:(Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}})"><code>MLUtils.unbatch</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g1 = rand_graph(4, 4, ndata=ones(Float32, 3, 4))
GNNGraph:
  num_nodes: 4
  num_edges: 4
  ndata:
        x = 3×4 Matrix{Float32}

julia&gt; g2 = rand_graph(5, 4, ndata=zeros(Float32, 3, 5))
GNNGraph:
  num_nodes: 5
  num_edges: 4
  ndata:
        x = 3×5 Matrix{Float32}

julia&gt; g12 = MLUtils.batch([g1, g2])
GNNGraph:
  num_nodes: 9
  num_edges: 8
  num_graphs: 2
  ndata:
        x = 3×9 Matrix{Float32}

julia&gt; g12.ndata.x
3×9 Matrix{Float32}:
 1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0
 1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0
 1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/transform.jl#L630-L670" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#MLUtils.unbatch-Union{Tuple{GNNGraph{T}}, Tuple{T}} where T&lt;:(Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}})" id="MLUtils.unbatch-Union{Tuple{GNNGraph{T}}, Tuple{T}} where T&lt;:(Tuple{T, T, V} where {T&lt;:(AbstractVector{&lt;:Integer}), V&lt;:Union{Nothing, AbstractVector}})"><code>MLUtils.unbatch</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unbatch(g::GNNGraph)</code></pre><p>Opposite of the <a href="#MLUtils.batch-Tuple{AbstractVector{&lt;:GNNGraph}}"><code>MLUtils.batch</code></a> operation, returns  an array of the individual graphs batched together in <code>g</code>.</p><p>See also <a href="#MLUtils.batch-Tuple{AbstractVector{&lt;:GNNGraph}}"><code>MLUtils.batch</code></a> and <a href="#GNNGraphs.getgraph-Tuple{GNNGraph, Int64}"><code>getgraph</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using MLUtils

julia&gt; gbatched = MLUtils.batch([rand_graph(5, 6), rand_graph(10, 8), rand_graph(4,2)])
GNNGraph:
  num_nodes: 19
  num_edges: 16
  num_graphs: 3

julia&gt; MLUtils.unbatch(gbatched)
3-element Vector{GNNGraph{Tuple{Vector{Int64}, Vector{Int64}, Nothing}}}:
 GNNGraph(5, 6) with no data
 GNNGraph(10, 8) with no data
 GNNGraph(4, 2) with no data</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/transform.jl#L715-L740" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#SparseArrays.blockdiag-Tuple{GNNGraph, Vararg{GNNGraph}}" id="SparseArrays.blockdiag-Tuple{GNNGraph, Vararg{GNNGraph}}"><code>SparseArrays.blockdiag</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">blockdiag(xs::GNNGraph...)</code></pre><p>Equivalent to <a href="#MLUtils.batch-Tuple{AbstractVector{&lt;:GNNGraph}}"><code>MLUtils.batch</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/transform.jl#L617-L621" target="_blank">source</a></section></article><h2 id="Utils"><a class="docs-heading-anchor" href="#Utils">Utils</a><a id="Utils-1"></a><a class="docs-heading-anchor-permalink" href="#Utils" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#GNNGraphs.sort_edge_index" id="GNNGraphs.sort_edge_index"><code>GNNGraphs.sort_edge_index</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sort_edge_index(ei::Tuple) -&gt; u', v'
sort_edge_index(u, v) -&gt; u', v'</code></pre><p>Return a sorted version of the tuple of vectors <code>ei = (u, v)</code>, applying a common permutation to <code>u</code> and <code>v</code>. The sorting is lexycographic, that is the pairs <code>(ui, vi)</code>  are sorted first according to the <code>ui</code> and then according to <code>vi</code>. </p></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/utils.jl#L32-L40" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#GNNGraphs.color_refinement" id="GNNGraphs.color_refinement"><code>GNNGraphs.color_refinement</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">color_refinement(g::GNNGraph, [x0]) -&gt; x, num_colors, niters</code></pre><p>The color refinement algorithm for graph coloring.  Given a graph <code>g</code> and an initial coloring <code>x0</code>, the algorithm  iteratively refines the coloring until a fixed point is reached.</p><p>At each iteration the algorithm computes a hash of the coloring and the sorted list of colors of the neighbors of each node. This hash is used to determine if the coloring has changed.</p><p><code>math x_i' = hashmap((x_i, sort([x_j for j \in N(i)]))).</code>`</p><p>This algorithm is related to the 1-Weisfeiler-Lehman algorithm for graph isomorphism testing.</p><p><strong>Arguments</strong></p><ul><li><code>g::GNNGraph</code>: The graph to color.</li><li><code>x0::AbstractVector{&lt;:Integer}</code>: The initial coloring. If not provided, all nodes are colored with 1.</li></ul><p><strong>Returns</strong></p><ul><li><code>x::AbstractVector{&lt;:Integer}</code>: The final coloring.</li><li><code>num_colors::Int</code>: The number of colors used.</li><li><code>niters::Int</code>: The number of iterations until convergence.</li></ul></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/utils.jl#L340-L364" target="_blank">source</a></section></article><h2 id="Generate"><a class="docs-heading-anchor" href="#Generate">Generate</a><a id="Generate-1"></a><a class="docs-heading-anchor-permalink" href="#Generate" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#GNNGraphs.knn_graph-Tuple{AbstractMatrix, Int64}" id="GNNGraphs.knn_graph-Tuple{AbstractMatrix, Int64}"><code>GNNGraphs.knn_graph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">knn_graph(points::AbstractMatrix, 
          k::Int; 
          graph_indicator = nothing,
          self_loops = false, 
          dir = :in, 
          kws...)</code></pre><p>Create a <code>k</code>-nearest neighbor graph where each node is linked  to its <code>k</code> closest <code>points</code>.  </p><p><strong>Arguments</strong></p><ul><li><code>points</code>: A num<em>features × num</em>nodes matrix storing the Euclidean positions of the nodes.</li><li><code>k</code>: The number of neighbors considered in the kNN algorithm.</li><li><code>graph_indicator</code>: Either nothing or a vector containing the graph assignment of each node,                     in which case the returned graph will be a batch of graphs. </li><li><code>self_loops</code>: If <code>true</code>, consider the node itself among its <code>k</code> nearest neighbors, in which               case the graph will contain self-loops. </li><li><code>dir</code>: The direction of the edges. If <code>dir=:in</code> edges go from the <code>k</code>         neighbors to the central node. If <code>dir=:out</code> we have the opposite        direction.</li><li><code>kws</code>: Further keyword arguments will be passed to the <a href="#GNNGraph"><code>GNNGraph</code></a> constructor.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; n, k = 10, 3;

julia&gt; x = rand(Float32, 3, n);

julia&gt; g = knn_graph(x, k)
GNNGraph:
    num_nodes = 10
    num_edges = 30

julia&gt; graph_indicator = [1,1,1,1,1,2,2,2,2,2];

julia&gt; g = knn_graph(x, k; graph_indicator)
GNNGraph:
    num_nodes = 10
    num_edges = 30
    num_graphs = 2</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/generate.jl#L67-L111" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#GNNGraphs.radius_graph-Tuple{AbstractMatrix, AbstractFloat}" id="GNNGraphs.radius_graph-Tuple{AbstractMatrix, AbstractFloat}"><code>GNNGraphs.radius_graph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">radius_graph(points::AbstractMatrix, 
             r::AbstractFloat; 
             graph_indicator = nothing,
             self_loops = false, 
             dir = :in, 
             kws...)</code></pre><p>Create a graph where each node is linked  to its neighbors within a given distance <code>r</code>.  </p><p><strong>Arguments</strong></p><ul><li><code>points</code>: A num<em>features × num</em>nodes matrix storing the Euclidean positions of the nodes.</li><li><code>r</code>: The radius.</li><li><code>graph_indicator</code>: Either nothing or a vector containing the graph assignment of each node,                     in which case the returned graph will be a batch of graphs. </li><li><code>self_loops</code>: If <code>true</code>, consider the node itself among its neighbors, in which               case the graph will contain self-loops. </li><li><code>dir</code>: The direction of the edges. If <code>dir=:in</code> edges go from the        neighbors to the central node. If <code>dir=:out</code> we have the opposite        direction.</li><li><code>kws</code>: Further keyword arguments will be passed to the <a href="#GNNGraph"><code>GNNGraph</code></a> constructor.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; n, r = 10, 0.75;

julia&gt; x = rand(Float32, 3, n);

julia&gt; g = radius_graph(x, r)
GNNGraph:
    num_nodes = 10
    num_edges = 46

julia&gt; graph_indicator = [1,1,1,1,1,2,2,2,2,2];

julia&gt; g = radius_graph(x, r; graph_indicator)
GNNGraph:
    num_nodes = 10
    num_edges = 20
    num_graphs = 2</code></pre><p><strong>References</strong></p><p>Section B paragraphs 1 and 2 of the paper <a href="https://arxiv.org/pdf/2101.00414.pdf">Dynamic Hidden-Variable Network Models</a></p></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/generate.jl#L147-L195" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#GNNGraphs.rand_graph-Tuple{Integer, Integer}" id="GNNGraphs.rand_graph-Tuple{Integer, Integer}"><code>GNNGraphs.rand_graph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rand_graph([rng,] n, m; bidirected=true, edge_weight = nothing, kws...)</code></pre><p>Generate a random (Erdós-Renyi) <code>GNNGraph</code> with <code>n</code> nodes and <code>m</code> edges.</p><p>If <code>bidirected=true</code> the reverse edge of each edge will be present. If <code>bidirected=false</code> instead, <code>m</code> unrelated edges are generated. In any case, the output graph will contain no self-loops or multi-edges.</p><p>A vector can be passed  as <code>edge_weight</code>. Its length has to be equal to <code>m</code> in the directed case, and <code>m÷2</code> in the bidirected one.</p><p>Pass a random number generator as the first argument to make the generation reproducible.</p><p>Additional keyword arguments will be passed to the <a href="#GNNGraph"><code>GNNGraph</code></a> constructor.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; g = rand_graph(5, 4, bidirected=false)
GNNGraph:
  num_nodes: 5
  num_edges: 4

julia&gt; edge_index(g)
([4, 3, 2, 1], [5, 4, 3, 2])

# In the bidirected case, edge data will be duplicated on the reverse edges if needed.
julia&gt; g = rand_graph(5, 4, edata=rand(Float32, 16, 2))
GNNGraph:
  num_nodes: 5
  num_edges: 4
  edata:
        e = 16×4 Matrix{Float32}

# Each edge has a reverse
julia&gt; edge_index(g)
([1, 1, 5, 3], [5, 3, 1, 1])</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/generate.jl#L1-L40" target="_blank">source</a></section></article><h2 id="Operators"><a class="docs-heading-anchor" href="#Operators">Operators</a><a id="Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Operators" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#Base.intersect" id="Base.intersect"><code>Base.intersect</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">intersect(g1::GNNGraph, g2::GNNGraph)</code></pre><p>Intersect two graphs by keeping only the common edges.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/operators.jl#L2-L6" target="_blank">source</a></section></article><h2 id="Sampling"><a class="docs-heading-anchor" href="#Sampling">Sampling</a><a id="Sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#GNNGraphs.sample_neighbors" id="GNNGraphs.sample_neighbors"><code>GNNGraphs.sample_neighbors</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sample_neighbors(g, nodes, K=-1; dir=:in, replace=false, dropnodes=false)</code></pre><p>Sample neighboring edges of the given nodes and return the induced subgraph. For each node, a number of inbound (or outbound when <code>dir = :out</code><code>) edges will be randomly chosen.  If</code>dropnodes=false`, the graph returned will then contain all the nodes in the original graph,  but only the sampled edges.</p><p>The returned graph will contain an edge feature <code>EID</code> corresponding to the id of the edge in the original graph. If <code>dropnodes=true</code>, it will also contain a node feature <code>NID</code> with the node ids in the original graph.</p><p><strong>Arguments</strong></p><ul><li><code>g</code>. The graph.</li><li><code>nodes</code>. A list of node IDs to sample neighbors from.</li><li><code>K</code>. The maximum number of edges to be sampled for each node.      If -1, all the neighboring edges will be selected.</li><li><code>dir</code>. Determines whether to sample inbound (<code>:in</code>) or outbound (`<code>:out</code>) edges (Default <code>:in</code>).</li><li><code>replace</code>. If <code>true</code>, sample with replacement.</li><li><code>dropnodes</code>. If <code>true</code>, the resulting subgraph will contain only the nodes involved in the sampled edges.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; g = rand_graph(20, 100)
GNNGraph:
    num_nodes = 20
    num_edges = 100

julia&gt; sample_neighbors(g, 2:3)
GNNGraph:
    num_nodes = 20
    num_edges = 9
    edata:
        EID =&gt; (9,)

julia&gt; sg = sample_neighbors(g, 2:3, dropnodes=true)
GNNGraph:
    num_nodes = 10
    num_edges = 9
    ndata:
        NID =&gt; (10,)
    edata:
        EID =&gt; (9,)

julia&gt; sg.ndata.NID
10-element Vector{Int64}:
  2
  3
 17
 14
 18
 15
 16
 20
  7
 10

julia&gt; sample_neighbors(g, 2:3, 5, replace=true)
GNNGraph:
    num_nodes = 20
    num_edges = 10
    edata:
        EID =&gt; (10,)</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/sampling.jl#L1-L67" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#Graphs.induced_subgraph-Tuple{GNNGraph, Vector{Int64}}" id="Graphs.induced_subgraph-Tuple{GNNGraph, Vector{Int64}}"><code>Graphs.induced_subgraph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">induced_subgraph(graph, nodes)</code></pre><p>Generates a subgraph from the original graph using the provided <code>nodes</code>.  The function includes the nodes' neighbors and creates edges between nodes that are connected in the original graph.  If a node has no neighbors, an isolated node will be added to the subgraph.  Returns A new <code>GNNGraph</code> containing the subgraph with the specified nodes and their features.</p><p><strong>Arguments</strong></p><ul><li><code>graph</code>. The original GNNGraph containing nodes, edges, and node features.</li><li><code>nodes</code>`. A vector of node indices to include in the subgraph.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; s = [1, 2]
2-element Vector{Int64}:
 1
 2

julia&gt; t = [2, 3]
2-element Vector{Int64}:
 2
 3

julia&gt; graph = GNNGraph((s, t), ndata = (; x=rand(Float32, 32, 3), y=rand(Float32, 3)), edata = rand(Float32, 2))
GNNGraph:
  num_nodes: 3
  num_edges: 2
  ndata:
        y = 3-element Vector{Float32}
        x = 32×3 Matrix{Float32}
  edata:
        e = 2-element Vector{Float32}

julia&gt; nodes = [1, 2]
2-element Vector{Int64}:
 1
 2

julia&gt; subgraph = Graphs.induced_subgraph(graph, nodes)
GNNGraph:
  num_nodes: 2
  num_edges: 1
  ndata:
        y = 2-element Vector{Float32}
        x = 32×2 Matrix{Float32}
  edata:
        e = 1-element Vector{Float32}</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaGraphs/GraphNeuralNetworks.jl/blob/0219e107814bdc991ad9d925187443ac823c20af/GNNGraphs/src/sampling.jl#L121-L172" target="_blank">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../../guides/messagepassing/">« Message Passing</a><a class="docs-footer-nextpage" href="../heterograph/">GNNHeteroGraph »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label></p><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div><p></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Monday 9 December 2024 08:44">Monday 9 December 2024</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div><div data-docstringscollapsed="true"></div></body></HTML>